/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
  storage: Storage,
  align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
  #[inline]
  pub const fn new(storage: Storage) -> Self {
    Self { storage, align: [] }
  }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
  Storage: AsRef<[u8]> + AsMut<[u8]>,
{
  #[inline]
  pub fn get_bit(&self, index: usize) -> bool {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = self.storage.as_ref()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    byte & mask == mask
  }
  #[inline]
  pub fn set_bit(&mut self, index: usize, val: bool) {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = &mut self.storage.as_mut()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    if val {
      *byte |= mask;
    } else {
      *byte &= !mask;
    }
  }
  #[inline]
  pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    let mut val = 0;
    for i in 0..(bit_width as usize) {
      if self.get_bit(i + bit_offset) {
        let index = if cfg!(target_endian = "big") {
          bit_width as usize - 1 - i
        } else {
          i
        };
        val |= 1 << index;
      }
    }
    val
  }
  #[inline]
  pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    for i in 0..(bit_width as usize) {
      let mask = 1 << i;
      let val_bit_is_set = val & mask == mask;
      let index = if cfg!(target_endian = "big") {
        bit_width as usize - 1 - i
      } else {
        i
      };
      self.set_bit(index + bit_offset, val_bit_is_set);
    }
  }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
  #[inline]
  pub const fn new() -> Self {
    __IncompleteArrayField(::std::marker::PhantomData, [])
  }
  #[inline]
  pub fn as_ptr(&self) -> *const T {
    self as *const _ as *const T
  }
  #[inline]
  pub fn as_mut_ptr(&mut self) -> *mut T {
    self as *mut _ as *mut T
  }
  #[inline]
  pub unsafe fn as_slice(&self, len: usize) -> &[T] {
    ::std::slice::from_raw_parts(self.as_ptr(), len)
  }
  #[inline]
  pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
    ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
  }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
  fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    fmt.write_str("__IncompleteArrayField")
  }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
  #[inline]
  pub const fn new() -> Self {
    __BindgenUnionField(::std::marker::PhantomData)
  }
  #[inline]
  pub unsafe fn as_ref(&self) -> &T {
    ::std::mem::transmute(self)
  }
  #[inline]
  pub unsafe fn as_mut(&mut self) -> &mut T {
    ::std::mem::transmute(self)
  }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
  #[inline]
  fn default() -> Self {
    Self::new()
  }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
  #[inline]
  fn clone(&self) -> Self {
    Self::new()
  }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
  fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    fmt.write_str("__BindgenUnionField")
  }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
  fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
  fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
    true
  }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const LANG_NEUTRAL: u32 = 0;
pub const STORMLIB_VERSION: u32 = 2326;
pub const STORMLIB_VERSION_STRING: &'static [u8; 5usize] = b"9.22\0";
pub const ID_MPQ: u32 = 441536589;
pub const ID_MPQ_USERDATA: u32 = 458313805;
pub const ID_MPK: u32 = 441143373;
pub const ERROR_AVI_FILE: u32 = 10000;
pub const ERROR_UNKNOWN_FILE_KEY: u32 = 10001;
pub const ERROR_CHECKSUM_ERROR: u32 = 10002;
pub const ERROR_INTERNAL_FILE: u32 = 10003;
pub const ERROR_BASE_FILE_MISSING: u32 = 10004;
pub const ERROR_MARKED_FOR_DELETE: u32 = 10005;
pub const ERROR_FILE_INCOMPLETE: u32 = 10006;
pub const ERROR_UNKNOWN_FILE_NAMES: u32 = 10007;
pub const ERROR_CANT_FIND_PATCH_PREFIX: u32 = 10008;
pub const HASH_TABLE_SIZE_MIN: u32 = 4;
pub const HASH_TABLE_SIZE_DEFAULT: u32 = 4096;
pub const HASH_TABLE_SIZE_MAX: u32 = 524288;
pub const HASH_ENTRY_DELETED: u32 = 4294967294;
pub const HASH_ENTRY_FREE: u32 = 4294967295;
pub const HET_ENTRY_DELETED: u32 = 128;
pub const HET_ENTRY_FREE: u32 = 0;
pub const HASH_STATE_SIZE: u32 = 96;
pub const SFILE_OPEN_HARD_DISK_FILE: u32 = 2;
pub const SFILE_OPEN_CDROM_FILE: u32 = 3;
pub const SFILE_OPEN_FROM_MPQ: u32 = 0;
pub const SFILE_OPEN_CHECK_EXISTS: u32 = 4294967292;
pub const SFILE_OPEN_BASE_FILE: u32 = 4294967293;
pub const SFILE_OPEN_ANY_LOCALE: u32 = 4294967294;
pub const SFILE_OPEN_LOCAL_FILE: u32 = 4294967295;
pub const MPQ_FLAG_READ_ONLY: u32 = 1;
pub const MPQ_FLAG_CHANGED: u32 = 2;
pub const MPQ_FLAG_MALFORMED: u32 = 4;
pub const MPQ_FLAG_HASH_TABLE_CUT: u32 = 8;
pub const MPQ_FLAG_BLOCK_TABLE_CUT: u32 = 16;
pub const MPQ_FLAG_CHECK_SECTOR_CRC: u32 = 32;
pub const MPQ_FLAG_SAVING_TABLES: u32 = 64;
pub const MPQ_FLAG_PATCH: u32 = 128;
pub const MPQ_FLAG_WAR3_MAP: u32 = 256;
pub const MPQ_FLAG_LISTFILE_NONE: u32 = 512;
pub const MPQ_FLAG_LISTFILE_NEW: u32 = 1024;
pub const MPQ_FLAG_LISTFILE_FORCE: u32 = 2048;
pub const MPQ_FLAG_ATTRIBUTES_NONE: u32 = 4096;
pub const MPQ_FLAG_ATTRIBUTES_NEW: u32 = 8192;
pub const MPQ_FLAG_SIGNATURE_NONE: u32 = 16384;
pub const MPQ_FLAG_SIGNATURE_NEW: u32 = 32768;
pub const MPQ_SUBTYPE_MPQ: u32 = 0;
pub const MPQ_SUBTYPE_SQP: u32 = 1;
pub const MPQ_SUBTYPE_MPK: u32 = 2;
pub const SFILE_INVALID_SIZE: u32 = 4294967295;
pub const SFILE_INVALID_POS: u32 = 4294967295;
pub const SFILE_INVALID_ATTRIBUTES: u32 = 4294967295;
pub const MPQ_FILE_IMPLODE: u32 = 256;
pub const MPQ_FILE_COMPRESS: u32 = 512;
pub const MPQ_FILE_ENCRYPTED: u32 = 65536;
pub const MPQ_FILE_FIX_KEY: u32 = 131072;
pub const MPQ_FILE_PATCH_FILE: u32 = 1048576;
pub const MPQ_FILE_SINGLE_UNIT: u32 = 16777216;
pub const MPQ_FILE_DELETE_MARKER: u32 = 33554432;
pub const MPQ_FILE_SECTOR_CRC: u32 = 67108864;
pub const MPQ_FILE_SIGNATURE: u32 = 268435456;
pub const MPQ_FILE_EXISTS: u32 = 2147483648;
pub const MPQ_FILE_REPLACEEXISTING: u32 = 2147483648;
pub const MPQ_FILE_COMPRESS_MASK: u32 = 65280;
pub const MPQ_FILE_DEFAULT_INTERNAL: u32 = 4294967295;
pub const MPQ_FILE_VALID_FLAGS: u32 = 2534605568;
pub const MPQ_FILE_VALID_FLAGS_W3X: u32 = 2516779776;
pub const BLOCK_INDEX_MASK: u32 = 268435455;
pub const MPQ_COMPRESSION_HUFFMANN: u32 = 1;
pub const MPQ_COMPRESSION_ZLIB: u32 = 2;
pub const MPQ_COMPRESSION_PKWARE: u32 = 8;
pub const MPQ_COMPRESSION_BZIP2: u32 = 16;
pub const MPQ_COMPRESSION_SPARSE: u32 = 32;
pub const MPQ_COMPRESSION_ADPCM_MONO: u32 = 64;
pub const MPQ_COMPRESSION_ADPCM_STEREO: u32 = 128;
pub const MPQ_COMPRESSION_LZMA: u32 = 18;
pub const MPQ_COMPRESSION_NEXT_SAME: u32 = 4294967295;
pub const MPQ_WAVE_QUALITY_HIGH: u32 = 0;
pub const MPQ_WAVE_QUALITY_MEDIUM: u32 = 1;
pub const MPQ_WAVE_QUALITY_LOW: u32 = 2;
pub const HET_TABLE_SIGNATURE: u32 = 441730376;
pub const BET_TABLE_SIGNATURE: u32 = 441730370;
pub const MPQ_KEY_HASH_TABLE: u32 = 3283040112;
pub const MPQ_KEY_BLOCK_TABLE: u32 = 3968054179;
pub const LISTFILE_NAME: &'static [u8; 11usize] = b"(listfile)\0";
pub const SIGNATURE_NAME: &'static [u8; 12usize] = b"(signature)\0";
pub const ATTRIBUTES_NAME: &'static [u8; 13usize] = b"(attributes)\0";
pub const PATCH_METADATA_NAME: &'static [u8; 17usize] = b"(patch_metadata)\0";
pub const MPQ_FORMAT_VERSION_1: u32 = 0;
pub const MPQ_FORMAT_VERSION_2: u32 = 1;
pub const MPQ_FORMAT_VERSION_3: u32 = 2;
pub const MPQ_FORMAT_VERSION_4: u32 = 3;
pub const MPQ_ATTRIBUTE_CRC32: u32 = 1;
pub const MPQ_ATTRIBUTE_FILETIME: u32 = 2;
pub const MPQ_ATTRIBUTE_MD5: u32 = 4;
pub const MPQ_ATTRIBUTE_PATCH_BIT: u32 = 8;
pub const MPQ_ATTRIBUTE_ALL: u32 = 15;
pub const MPQ_ATTRIBUTES_V1: u32 = 100;
pub const BASE_PROVIDER_FILE: u32 = 0;
pub const BASE_PROVIDER_MAP: u32 = 1;
pub const BASE_PROVIDER_HTTP: u32 = 2;
pub const BASE_PROVIDER_MASK: u32 = 15;
pub const STREAM_PROVIDER_FLAT: u32 = 0;
pub const STREAM_PROVIDER_PARTIAL: u32 = 16;
pub const STREAM_PROVIDER_MPQE: u32 = 32;
pub const STREAM_PROVIDER_BLOCK4: u32 = 48;
pub const STREAM_PROVIDER_MASK: u32 = 240;
pub const STREAM_FLAG_READ_ONLY: u32 = 256;
pub const STREAM_FLAG_WRITE_SHARE: u32 = 512;
pub const STREAM_FLAG_USE_BITMAP: u32 = 1024;
pub const STREAM_OPTIONS_MASK: u32 = 65280;
pub const STREAM_PROVIDERS_MASK: u32 = 255;
pub const STREAM_FLAGS_MASK: u32 = 65535;
pub const MPQ_OPEN_NO_LISTFILE: u32 = 65536;
pub const MPQ_OPEN_NO_ATTRIBUTES: u32 = 131072;
pub const MPQ_OPEN_NO_HEADER_SEARCH: u32 = 262144;
pub const MPQ_OPEN_FORCE_MPQ_V1: u32 = 524288;
pub const MPQ_OPEN_CHECK_SECTOR_CRC: u32 = 1048576;
pub const MPQ_OPEN_PATCH: u32 = 2097152;
pub const MPQ_OPEN_FORCE_LISTFILE: u32 = 4194304;
pub const MPQ_OPEN_READ_ONLY: u32 = 256;
pub const MPQ_CREATE_LISTFILE: u32 = 1048576;
pub const MPQ_CREATE_ATTRIBUTES: u32 = 2097152;
pub const MPQ_CREATE_SIGNATURE: u32 = 4194304;
pub const MPQ_CREATE_ARCHIVE_V1: u32 = 0;
pub const MPQ_CREATE_ARCHIVE_V2: u32 = 16777216;
pub const MPQ_CREATE_ARCHIVE_V3: u32 = 33554432;
pub const MPQ_CREATE_ARCHIVE_V4: u32 = 50331648;
pub const MPQ_CREATE_ARCHIVE_VMASK: u32 = 251658240;
pub const FLAGS_TO_FORMAT_SHIFT: u32 = 24;
pub const SFILE_VERIFY_SECTOR_CRC: u32 = 1;
pub const SFILE_VERIFY_FILE_CRC: u32 = 2;
pub const SFILE_VERIFY_FILE_MD5: u32 = 4;
pub const SFILE_VERIFY_RAW_MD5: u32 = 8;
pub const SFILE_VERIFY_ALL: u32 = 15;
pub const VERIFY_OPEN_ERROR: u32 = 1;
pub const VERIFY_READ_ERROR: u32 = 2;
pub const VERIFY_FILE_HAS_SECTOR_CRC: u32 = 4;
pub const VERIFY_FILE_SECTOR_CRC_ERROR: u32 = 8;
pub const VERIFY_FILE_HAS_CHECKSUM: u32 = 16;
pub const VERIFY_FILE_CHECKSUM_ERROR: u32 = 32;
pub const VERIFY_FILE_HAS_MD5: u32 = 64;
pub const VERIFY_FILE_MD5_ERROR: u32 = 128;
pub const VERIFY_FILE_HAS_RAW_MD5: u32 = 256;
pub const VERIFY_FILE_RAW_MD5_ERROR: u32 = 512;
pub const VERIFY_FILE_ERROR_MASK: u32 = 683;
pub const SFILE_VERIFY_MPQ_HEADER: u32 = 1;
pub const SFILE_VERIFY_HET_TABLE: u32 = 2;
pub const SFILE_VERIFY_BET_TABLE: u32 = 3;
pub const SFILE_VERIFY_HASH_TABLE: u32 = 4;
pub const SFILE_VERIFY_BLOCK_TABLE: u32 = 5;
pub const SFILE_VERIFY_HIBLOCK_TABLE: u32 = 6;
pub const SFILE_VERIFY_FILE: u32 = 7;
pub const SIGNATURE_TYPE_NONE: u32 = 0;
pub const SIGNATURE_TYPE_WEAK: u32 = 1;
pub const SIGNATURE_TYPE_STRONG: u32 = 2;
pub const ERROR_NO_SIGNATURE: u32 = 0;
pub const ERROR_VERIFY_FAILED: u32 = 1;
pub const ERROR_WEAK_SIGNATURE_OK: u32 = 2;
pub const ERROR_WEAK_SIGNATURE_ERROR: u32 = 3;
pub const ERROR_STRONG_SIGNATURE_OK: u32 = 4;
pub const ERROR_STRONG_SIGNATURE_ERROR: u32 = 5;
pub const MD5_DIGEST_SIZE: u32 = 16;
pub const SHA1_DIGEST_SIZE: u32 = 20;
pub const CCB_CHECKING_FILES: u32 = 1;
pub const CCB_CHECKING_HASH_TABLE: u32 = 2;
pub const CCB_COPYING_NON_MPQ_DATA: u32 = 3;
pub const CCB_COMPACTING_FILES: u32 = 4;
pub const CCB_CLOSING_ARCHIVE: u32 = 5;
pub const MPQ_HEADER_SIZE_V1: u32 = 32;
pub const MPQ_HEADER_SIZE_V2: u32 = 44;
pub const MPQ_HEADER_SIZE_V3: u32 = 68;
pub const MPQ_HEADER_SIZE_V4: u32 = 208;
pub const MPQ_HEADER_DWORDS: u32 = 52;
pub type size_t = ::std::os::raw::c_ulonglong;
pub type TCHAR = ::std::os::raw::c_char;
pub type ULONG = ::std::os::raw::c_ulong;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type FLOAT = f32;
pub type PBYTE = *mut BYTE;
pub type LPBYTE = *mut BYTE;
pub type PDWORD = *mut DWORD;
pub type LPDWORD = *mut DWORD;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type LPCVOID = *const ::std::os::raw::c_void;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SHANDLE_PTR = ::std::os::raw::c_longlong;
pub type SIZE_T = ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = u16;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type LPSTR = *mut CHAR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PCZZSTR = *const CHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY {
  pub Mask: KAFFINITY,
  pub Group: WORD,
  pub Reserved: [WORD; 3usize],
}
#[test]
fn bindgen_test_layout__GROUP_AFFINITY() {
  assert_eq!(
    ::std::mem::size_of::<_GROUP_AFFINITY>(),
    16usize,
    concat!("Size of: ", stringify!(_GROUP_AFFINITY))
  );
  assert_eq!(
    ::std::mem::align_of::<_GROUP_AFFINITY>(),
    8usize,
    concat!("Alignment of ", stringify!(_GROUP_AFFINITY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Mask as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Group as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Reserved as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_AFFINITY),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type HRESULT = ::std::os::raw::c_long;
pub type LCID = DWORD;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
  pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
  pub u: _LARGE_INTEGER__bindgen_ty_2,
  pub QuadPart: LONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(HighPart)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(HighPart)
    )
  );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
  assert_eq!(
    ::std::mem::size_of::<_LARGE_INTEGER>(),
    8usize,
    concat!("Size of: ", stringify!(_LARGE_INTEGER))
  );
  assert_eq!(
    ::std::mem::align_of::<_LARGE_INTEGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_LARGE_INTEGER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LARGE_INTEGER>())).u as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER),
      "::",
      stringify!(u)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LARGE_INTEGER>())).QuadPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LARGE_INTEGER),
      "::",
      stringify!(QuadPart)
    )
  );
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
  pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
  pub u: _ULARGE_INTEGER__bindgen_ty_2,
  pub QuadPart: ULONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
  pub LowPart: DWORD,
  pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_1),
      "::",
      stringify!(HighPart)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
  pub LowPart: DWORD,
  pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER__bindgen_ty_2),
      "::",
      stringify!(HighPart)
    )
  );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
  assert_eq!(
    ::std::mem::size_of::<_ULARGE_INTEGER>(),
    8usize,
    concat!("Size of: ", stringify!(_ULARGE_INTEGER))
  );
  assert_eq!(
    ::std::mem::align_of::<_ULARGE_INTEGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ULARGE_INTEGER>())).u as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER),
      "::",
      stringify!(u)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ULARGE_INTEGER>())).QuadPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ULARGE_INTEGER),
      "::",
      stringify!(QuadPart)
    )
  );
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
  pub LowPart: DWORD,
  pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LUID() {
  assert_eq!(
    ::std::mem::size_of::<_LUID>(),
    8usize,
    concat!("Size of: ", stringify!(_LUID))
  );
  assert_eq!(
    ::std::mem::align_of::<_LUID>(),
    4usize,
    concat!("Alignment of ", stringify!(_LUID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LUID>())).LowPart as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID),
      "::",
      stringify!(LowPart)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LUID>())).HighPart as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID),
      "::",
      stringify!(HighPart)
    )
  );
}
pub type LUID = _LUID;
pub type DWORDLONG = ULONGLONG;
pub type BOOLEAN = BYTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
  pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_SINGLE_LIST_ENTRY>(),
    8usize,
    concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SINGLE_LIST_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SINGLE_LIST_ENTRY>())).Next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SINGLE_LIST_ENTRY),
      "::",
      stringify!(Next)
    )
  );
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
  pub Data1: ::std::os::raw::c_ulong,
  pub Data2: ::std::os::raw::c_ushort,
  pub Data3: ::std::os::raw::c_ushort,
  pub Data4: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
  assert_eq!(
    ::std::mem::size_of::<_GUID>(),
    16usize,
    concat!("Size of: ", stringify!(_GUID))
  );
  assert_eq!(
    ::std::mem::align_of::<_GUID>(),
    4usize,
    concat!("Alignment of ", stringify!(_GUID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GUID>())).Data1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GUID>())).Data2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GUID>())).Data3 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GUID>())).Data4 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GUID),
      "::",
      stringify!(Data4)
    )
  );
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type IID = GUID;
pub type CLSID = GUID;
pub type FMTID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64 {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_AMD64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).BeginAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).HandlerAddress as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_AMD64>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_AMD64>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_AMD64))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_AMD64),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_AMD64 = _SCOPE_TABLE_AMD64;
pub type SCOPE_TABLE = SCOPE_TABLE_AMD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_ARM__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_ARM__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_ARM__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).BeginAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).HandlerAddress as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_ARM>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_ARM>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_ARM = _SCOPE_TABLE_ARM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM64 {
  pub Count: DWORD,
  pub ScopeRecord: [_SCOPE_TABLE_ARM64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM64__bindgen_ty_1 {
  pub BeginAddress: DWORD,
  pub EndAddress: DWORD,
  pub HandlerAddress: DWORD,
  pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM64__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_ARM64__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_ARM64__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).BeginAddress as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(BeginAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).EndAddress as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(EndAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).HandlerAddress as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(HandlerAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).JumpTarget as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
      "::",
      stringify!(JumpTarget)
    )
  );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM64() {
  assert_eq!(
    ::std::mem::size_of::<_SCOPE_TABLE_ARM64>(),
    20usize,
    concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM64))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCOPE_TABLE_ARM64>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM64))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64>())).Count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64),
      "::",
      stringify!(Count)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64>())).ScopeRecord as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCOPE_TABLE_ARM64),
      "::",
      stringify!(ScopeRecord)
    )
  );
}
pub type SCOPE_TABLE_ARM64 = _SCOPE_TABLE_ARM64;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = DWORD;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
  pub GenericRead: ACCESS_MASK,
  pub GenericWrite: ACCESS_MASK,
  pub GenericExecute: ACCESS_MASK,
  pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
  assert_eq!(
    ::std::mem::size_of::<_GENERIC_MAPPING>(),
    16usize,
    concat!("Size of: ", stringify!(_GENERIC_MAPPING))
  );
  assert_eq!(
    ::std::mem::align_of::<_GENERIC_MAPPING>(),
    4usize,
    concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericRead as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericRead)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericWrite as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericWrite)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericExecute as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericExecute)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericAll as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_MAPPING),
      "::",
      stringify!(GenericAll)
    )
  );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
  pub Luid: LUID,
  pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__LUID_AND_ATTRIBUTES() {
  assert_eq!(
    ::std::mem::size_of::<_LUID_AND_ATTRIBUTES>(),
    12usize,
    concat!("Size of: ", stringify!(_LUID_AND_ATTRIBUTES))
  );
  assert_eq!(
    ::std::mem::align_of::<_LUID_AND_ATTRIBUTES>(),
    4usize,
    concat!("Alignment of ", stringify!(_LUID_AND_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LUID_AND_ATTRIBUTES>())).Luid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID_AND_ATTRIBUTES),
      "::",
      stringify!(Luid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LUID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_LUID_AND_ATTRIBUTES),
      "::",
      stringify!(Attributes)
    )
  );
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
  pub Value: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
  assert_eq!(
    ::std::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
    6usize,
    concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
    1usize,
    concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_IDENTIFIER_AUTHORITY>())).Value as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_IDENTIFIER_AUTHORITY),
      "::",
      stringify!(Value)
    )
  );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
  pub Revision: BYTE,
  pub SubAuthorityCount: BYTE,
  pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
  pub SubAuthority: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
  assert_eq!(
    ::std::mem::size_of::<_SID>(),
    12usize,
    concat!("Size of: ", stringify!(_SID))
  );
  assert_eq!(
    ::std::mem::align_of::<_SID>(),
    4usize,
    concat!("Alignment of ", stringify!(_SID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID>())).SubAuthorityCount as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(SubAuthorityCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID>())).IdentifierAuthority as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(IdentifierAuthority)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID>())).SubAuthority as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID),
      "::",
      stringify!(SubAuthority)
    )
  );
}
pub type SID = _SID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_SID {
  pub Sid: SID,
  pub Buffer: [BYTE; 68usize],
  _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout__SE_SID() {
  assert_eq!(
    ::std::mem::size_of::<_SE_SID>(),
    68usize,
    concat!("Size of: ", stringify!(_SE_SID))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_SID>(),
    4usize,
    concat!("Alignment of ", stringify!(_SE_SID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_SID>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SID),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_SID>())).Buffer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SID),
      "::",
      stringify!(Buffer)
    )
  );
}
pub type SE_SID = _SE_SID;
pub const _SID_NAME_USE_SidTypeUser: _SID_NAME_USE = 1;
pub const _SID_NAME_USE_SidTypeGroup: _SID_NAME_USE = 2;
pub const _SID_NAME_USE_SidTypeDomain: _SID_NAME_USE = 3;
pub const _SID_NAME_USE_SidTypeAlias: _SID_NAME_USE = 4;
pub const _SID_NAME_USE_SidTypeWellKnownGroup: _SID_NAME_USE = 5;
pub const _SID_NAME_USE_SidTypeDeletedAccount: _SID_NAME_USE = 6;
pub const _SID_NAME_USE_SidTypeInvalid: _SID_NAME_USE = 7;
pub const _SID_NAME_USE_SidTypeUnknown: _SID_NAME_USE = 8;
pub const _SID_NAME_USE_SidTypeComputer: _SID_NAME_USE = 9;
pub const _SID_NAME_USE_SidTypeLabel: _SID_NAME_USE = 10;
pub const _SID_NAME_USE_SidTypeLogonSession: _SID_NAME_USE = 11;
pub type _SID_NAME_USE = ::std::os::raw::c_int;
pub use self::_SID_NAME_USE as SID_NAME_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
  pub Sid: PSID,
  pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES() {
  assert_eq!(
    ::std::mem::size_of::<_SID_AND_ATTRIBUTES>(),
    16usize,
    concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SID_AND_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES),
      "::",
      stringify!(Attributes)
    )
  );
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_AND_ATTRIBUTES_ARRAY = [SID_AND_ATTRIBUTES; 1usize];
pub type SID_HASH_ENTRY = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
  pub SidCount: DWORD,
  pub SidAttr: PSID_AND_ATTRIBUTES,
  pub Hash: [SID_HASH_ENTRY; 32usize],
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES_HASH() {
  assert_eq!(
    ::std::mem::size_of::<_SID_AND_ATTRIBUTES_HASH>(),
    272usize,
    concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES_HASH))
  );
  assert_eq!(
    ::std::mem::align_of::<_SID_AND_ATTRIBUTES_HASH>(),
    8usize,
    concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES_HASH))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).SidCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(SidCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).SidAttr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(SidAttr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).Hash as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SID_AND_ATTRIBUTES_HASH),
      "::",
      stringify!(Hash)
    )
  );
}
pub type SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL {
  pub AclRevision: BYTE,
  pub Sbz1: BYTE,
  pub AclSize: WORD,
  pub AceCount: WORD,
  pub Sbz2: WORD,
}
#[test]
fn bindgen_test_layout__ACL() {
  assert_eq!(
    ::std::mem::size_of::<_ACL>(),
    8usize,
    concat!("Size of: ", stringify!(_ACL))
  );
  assert_eq!(
    ::std::mem::align_of::<_ACL>(),
    2usize,
    concat!("Alignment of ", stringify!(_ACL))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).AclRevision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AclRevision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).AclSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AclSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).AceCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(AceCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACL>())).Sbz2 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACL),
      "::",
      stringify!(Sbz2)
    )
  );
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACE_HEADER {
  pub AceType: BYTE,
  pub AceFlags: BYTE,
  pub AceSize: WORD,
}
#[test]
fn bindgen_test_layout__ACE_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_ACE_HEADER>(),
    4usize,
    concat!("Size of: ", stringify!(_ACE_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_ACE_HEADER>(),
    2usize,
    concat!("Alignment of ", stringify!(_ACE_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceFlags as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACE_HEADER),
      "::",
      stringify!(AceSize)
    )
  );
}
pub type ACE_HEADER = _ACE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_AUDIT_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_AUDIT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ALARM_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ALARM_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_RESOURCE_ATTRIBUTE_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SCOPED_POLICY_ID_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_SCOPED_POLICY_ID_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_MANDATORY_LABEL_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_MANDATORY_LABEL_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESS_TRUST_LABEL_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).SidStart as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_PROCESS_TRUST_LABEL_ACE = _SYSTEM_PROCESS_TRUST_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ACCESS_FILTER_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ACCESS_FILTER_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ACCESS_FILTER_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ACCESS_FILTER_ACE = _SYSTEM_ACCESS_FILTER_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_OBJECT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).ObjectType as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).InheritedObjectType as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).SidStart as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_OBJECT_ACE = _SYSTEM_AUDIT_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_OBJECT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).ObjectType as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).InheritedObjectType as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).SidStart as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_OBJECT_ACE = _SYSTEM_ALARM_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_CALLBACK_ACE = _SYSTEM_AUDIT_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).Header as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).Mask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).SidStart as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_CALLBACK_ACE = _SYSTEM_ALARM_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).InheritedObjectType as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
  pub Header: ACE_HEADER,
  pub Mask: ACCESS_MASK,
  pub Flags: DWORD,
  pub ObjectType: GUID,
  pub InheritedObjectType: GUID,
  pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_OBJECT_ACE() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Header as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Header)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Mask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).ObjectType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(ObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).InheritedObjectType as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(InheritedObjectType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).SidStart as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
      "::",
      stringify!(SidStart)
    )
  );
}
pub type SYSTEM_ALARM_CALLBACK_OBJECT_ACE = _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub type SECURITY_DESCRIPTOR_CONTROL = WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
  pub Revision: BYTE,
  pub Sbz1: BYTE,
  pub Control: SECURITY_DESCRIPTOR_CONTROL,
  pub Owner: DWORD,
  pub Group: DWORD,
  pub Sacl: DWORD,
  pub Dacl: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR_RELATIVE() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
    20usize,
    concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Revision as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Control as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Owner as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Owner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Group as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Sacl as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Sacl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Dacl as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
      "::",
      stringify!(Dacl)
    )
  );
}
pub type SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR {
  pub Revision: BYTE,
  pub Sbz1: BYTE,
  pub Control: SECURITY_DESCRIPTOR_CONTROL,
  pub Owner: PSID,
  pub Group: PSID,
  pub Sacl: PACL,
  pub Dacl: PACL,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_DESCRIPTOR>(),
    40usize,
    concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Sbz1 as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Sbz1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Control as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Owner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Owner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Group as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Sacl as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Sacl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Dacl as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Dacl)
    )
  );
}
pub type SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_OBJECT_AI_PARAMS {
  pub Size: DWORD,
  pub ConstraintMask: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_OBJECT_AI_PARAMS() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_OBJECT_AI_PARAMS>(),
    8usize,
    concat!("Size of: ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_OBJECT_AI_PARAMS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_OBJECT_AI_PARAMS>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_OBJECT_AI_PARAMS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_OBJECT_AI_PARAMS>())).ConstraintMask as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_OBJECT_AI_PARAMS),
      "::",
      stringify!(ConstraintMask)
    )
  );
}
pub type SECURITY_OBJECT_AI_PARAMS = _SECURITY_OBJECT_AI_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_LIST {
  pub Level: WORD,
  pub Sbz: WORD,
  pub ObjectType: *mut GUID,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE_LIST() {
  assert_eq!(
    ::std::mem::size_of::<_OBJECT_TYPE_LIST>(),
    16usize,
    concat!("Size of: ", stringify!(_OBJECT_TYPE_LIST))
  );
  assert_eq!(
    ::std::mem::align_of::<_OBJECT_TYPE_LIST>(),
    8usize,
    concat!("Alignment of ", stringify!(_OBJECT_TYPE_LIST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).Sbz as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(Sbz)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).ObjectType as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OBJECT_TYPE_LIST),
      "::",
      stringify!(ObjectType)
    )
  );
}
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
  pub PrivilegeCount: DWORD,
  pub Control: DWORD,
  pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__PRIVILEGE_SET() {
  assert_eq!(
    ::std::mem::size_of::<_PRIVILEGE_SET>(),
    20usize,
    concat!("Size of: ", stringify!(_PRIVILEGE_SET))
  );
  assert_eq!(
    ::std::mem::align_of::<_PRIVILEGE_SET>(),
    4usize,
    concat!("Alignment of ", stringify!(_PRIVILEGE_SET))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).PrivilegeCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(PrivilegeCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).Control as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(Control)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).Privilege as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PRIVILEGE_SET),
      "::",
      stringify!(Privilege)
    )
  );
}
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub type ACCESS_REASON = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_REASONS {
  pub Data: [ACCESS_REASON; 32usize],
}
#[test]
fn bindgen_test_layout__ACCESS_REASONS() {
  assert_eq!(
    ::std::mem::size_of::<_ACCESS_REASONS>(),
    128usize,
    concat!("Size of: ", stringify!(_ACCESS_REASONS))
  );
  assert_eq!(
    ::std::mem::align_of::<_ACCESS_REASONS>(),
    4usize,
    concat!("Alignment of ", stringify!(_ACCESS_REASONS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_ACCESS_REASONS>())).Data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ACCESS_REASONS),
      "::",
      stringify!(Data)
    )
  );
}
pub type PACCESS_REASONS = *mut _ACCESS_REASONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_SECURITY_DESCRIPTOR {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__SE_SECURITY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_SE_SECURITY_DESCRIPTOR>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_SECURITY_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_SECURITY_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).SecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_SECURITY_DESCRIPTOR),
      "::",
      stringify!(SecurityDescriptor)
    )
  );
}
pub type SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR;
pub type PSE_SECURITY_DESCRIPTOR = *mut _SE_SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REQUEST {
  pub Size: DWORD,
  pub SeSecurityDescriptor: PSE_SECURITY_DESCRIPTOR,
  pub DesiredAccess: ACCESS_MASK,
  pub PreviouslyGrantedAccess: ACCESS_MASK,
  pub PrincipalSelfSid: PSID,
  pub GenericMapping: PGENERIC_MAPPING,
  pub ObjectTypeListCount: DWORD,
  pub ObjectTypeList: POBJECT_TYPE_LIST,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_SE_ACCESS_REQUEST>(),
    56usize,
    concat!("Size of: ", stringify!(_SE_ACCESS_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_ACCESS_REQUEST>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_ACCESS_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).SeSecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(SeSecurityDescriptor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).DesiredAccess as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(DesiredAccess)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).PreviouslyGrantedAccess as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(PreviouslyGrantedAccess)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).PrincipalSelfSid as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(PrincipalSelfSid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).GenericMapping as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(GenericMapping)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).ObjectTypeListCount as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(ObjectTypeListCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).ObjectTypeList as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REQUEST),
      "::",
      stringify!(ObjectTypeList)
    )
  );
}
pub type SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REPLY {
  pub Size: DWORD,
  pub ResultListCount: DWORD,
  pub GrantedAccess: PACCESS_MASK,
  pub AccessStatus: PDWORD,
  pub AccessReason: PACCESS_REASONS,
  pub Privileges: *mut PPRIVILEGE_SET,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REPLY() {
  assert_eq!(
    ::std::mem::size_of::<_SE_ACCESS_REPLY>(),
    40usize,
    concat!("Size of: ", stringify!(_SE_ACCESS_REPLY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_ACCESS_REPLY>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_ACCESS_REPLY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).ResultListCount as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(ResultListCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).GrantedAccess as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(GrantedAccess)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).AccessStatus as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(AccessStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).AccessReason as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(AccessReason)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).Privileges as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_ACCESS_REPLY),
      "::",
      stringify!(Privileges)
    )
  );
}
pub type SE_ACCESS_REPLY = _SE_ACCESS_REPLY;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityAnonymous: _SECURITY_IMPERSONATION_LEVEL = 0;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityIdentification: _SECURITY_IMPERSONATION_LEVEL = 1;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityImpersonation: _SECURITY_IMPERSONATION_LEVEL = 2;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityDelegation: _SECURITY_IMPERSONATION_LEVEL = 3;
pub type _SECURITY_IMPERSONATION_LEVEL = ::std::os::raw::c_int;
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER {
  pub User: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__TOKEN_USER() {
  assert_eq!(
    ::std::mem::size_of::<_TOKEN_USER>(),
    16usize,
    concat!("Size of: ", stringify!(_TOKEN_USER))
  );
  assert_eq!(
    ::std::mem::align_of::<_TOKEN_USER>(),
    8usize,
    concat!("Alignment of ", stringify!(_TOKEN_USER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_TOKEN_USER>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_TOKEN_USER),
      "::",
      stringify!(User)
    )
  );
}
pub type TOKEN_USER = _TOKEN_USER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SE_TOKEN_USER {
  pub __bindgen_anon_1: _SE_TOKEN_USER__bindgen_ty_1,
  pub __bindgen_anon_2: _SE_TOKEN_USER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_1 {
  pub TokenUser: TOKEN_USER,
  pub User: SID_AND_ATTRIBUTES,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_1>())).TokenUser as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_1),
      "::",
      stringify!(TokenUser)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_1>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_1),
      "::",
      stringify!(User)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_2 {
  pub Sid: SID,
  pub Buffer: [BYTE; 68usize],
  _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
    68usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
    4usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_2>())).Sid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_2),
      "::",
      stringify!(Sid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_2>())).Buffer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_TOKEN_USER__bindgen_ty_2),
      "::",
      stringify!(Buffer)
    )
  );
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER() {
  assert_eq!(
    ::std::mem::size_of::<_SE_TOKEN_USER>(),
    88usize,
    concat!("Size of: ", stringify!(_SE_TOKEN_USER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_TOKEN_USER>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_TOKEN_USER))
  );
}
pub type SE_TOKEN_USER = _SE_TOKEN_USER;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
  pub Length: DWORD,
  pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
  pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
  pub EffectiveOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SECURITY_QUALITY_OF_SERVICE() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_QUALITY_OF_SERVICE>(),
    12usize,
    concat!("Size of: ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_QUALITY_OF_SERVICE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).Length as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ImpersonationLevel as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(ImpersonationLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ContextTrackingMode as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(ContextTrackingMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).EffectiveOnly as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_QUALITY_OF_SERVICE),
      "::",
      stringify!(EffectiveOnly)
    )
  );
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_IMPERSONATION_STATE {
  pub Token: PACCESS_TOKEN,
  pub CopyOnOpen: BOOLEAN,
  pub EffectiveOnly: BOOLEAN,
  pub Level: SECURITY_IMPERSONATION_LEVEL,
}
#[test]
fn bindgen_test_layout__SE_IMPERSONATION_STATE() {
  assert_eq!(
    ::std::mem::size_of::<_SE_IMPERSONATION_STATE>(),
    16usize,
    concat!("Size of: ", stringify!(_SE_IMPERSONATION_STATE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SE_IMPERSONATION_STATE>(),
    8usize,
    concat!("Alignment of ", stringify!(_SE_IMPERSONATION_STATE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).Token as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(Token)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).CopyOnOpen as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(CopyOnOpen)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).EffectiveOnly as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(EffectiveOnly)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).Level as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SE_IMPERSONATION_STATE),
      "::",
      stringify!(Level)
    )
  );
}
pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = DWORD;
pub type SE_SIGNING_LEVEL = BYTE;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureNone: _SE_IMAGE_SIGNATURE_TYPE = 0;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureEmbedded: _SE_IMAGE_SIGNATURE_TYPE = 1;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCache: _SE_IMAGE_SIGNATURE_TYPE = 2;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogCached: _SE_IMAGE_SIGNATURE_TYPE = 3;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogNotCached: _SE_IMAGE_SIGNATURE_TYPE = 4;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogHint: _SE_IMAGE_SIGNATURE_TYPE = 5;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignaturePackageCatalog: _SE_IMAGE_SIGNATURE_TYPE = 6;
pub type _SE_IMAGE_SIGNATURE_TYPE = ::std::os::raw::c_int;
pub use self::_SE_IMAGE_SIGNATURE_TYPE as SE_IMAGE_SIGNATURE_TYPE;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeInvalidType: _SE_LEARNING_MODE_DATA_TYPE = 0;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeSettings: _SE_LEARNING_MODE_DATA_TYPE = 1;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeMax: _SE_LEARNING_MODE_DATA_TYPE = 2;
pub type _SE_LEARNING_MODE_DATA_TYPE = ::std::os::raw::c_int;
pub use self::_SE_LEARNING_MODE_DATA_TYPE as SE_LEARNING_MODE_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_CAPABILITIES {
  pub AppContainerSid: PSID,
  pub Capabilities: PSID_AND_ATTRIBUTES,
  pub CapabilityCount: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_CAPABILITIES() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_CAPABILITIES>(),
    24usize,
    concat!("Size of: ", stringify!(_SECURITY_CAPABILITIES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_CAPABILITIES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_CAPABILITIES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).AppContainerSid as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(AppContainerSid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).Capabilities as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(Capabilities)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).CapabilityCount as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(CapabilityCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).Reserved as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_CAPABILITIES),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type SECURITY_CAPABILITIES = _SECURITY_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SILOOBJECT_BASIC_INFORMATION {
  pub SiloId: DWORD,
  pub SiloParentId: DWORD,
  pub NumberOfProcesses: DWORD,
  pub IsInServerSilo: BOOLEAN,
  pub Reserved: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__SILOOBJECT_BASIC_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SILOOBJECT_BASIC_INFORMATION>(),
    16usize,
    concat!("Size of: ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SILOOBJECT_BASIC_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).SiloId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(SiloId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).SiloParentId as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(SiloParentId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).NumberOfProcesses as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(NumberOfProcesses)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).IsInServerSilo as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(IsInServerSilo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).Reserved as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_SILOOBJECT_BASIC_INFORMATION),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type SILOOBJECT_BASIC_INFORMATION = _SILOOBJECT_BASIC_INFORMATION;
pub const _SERVERSILO_STATE_SERVERSILO_INITING: _SERVERSILO_STATE = 0;
pub const _SERVERSILO_STATE_SERVERSILO_STARTED: _SERVERSILO_STATE = 1;
pub const _SERVERSILO_STATE_SERVERSILO_SHUTTING_DOWN: _SERVERSILO_STATE = 2;
pub const _SERVERSILO_STATE_SERVERSILO_TERMINATING: _SERVERSILO_STATE = 3;
pub const _SERVERSILO_STATE_SERVERSILO_TERMINATED: _SERVERSILO_STATE = 4;
pub type _SERVERSILO_STATE = ::std::os::raw::c_int;
pub use self::_SERVERSILO_STATE as SERVERSILO_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVERSILO_BASIC_INFORMATION {
  pub ServiceSessionId: DWORD,
  pub State: SERVERSILO_STATE,
  pub ExitStatus: DWORD,
}
#[test]
fn bindgen_test_layout__SERVERSILO_BASIC_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SERVERSILO_BASIC_INFORMATION>(),
    12usize,
    concat!("Size of: ", stringify!(_SERVERSILO_BASIC_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVERSILO_BASIC_INFORMATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVERSILO_BASIC_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).ServiceSessionId as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(ServiceSessionId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).State as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(State)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).ExitStatus as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVERSILO_BASIC_INFORMATION),
      "::",
      stringify!(ExitStatus)
    )
  );
}
pub type SERVERSILO_BASIC_INFORMATION = _SERVERSILO_BASIC_INFORMATION;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorCore: _LOGICAL_PROCESSOR_RELATIONSHIP =
  0;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNode: _LOGICAL_PROCESSOR_RELATIONSHIP = 1;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationCache: _LOGICAL_PROCESSOR_RELATIONSHIP = 2;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorPackage:
  _LOGICAL_PROCESSOR_RELATIONSHIP = 3;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationGroup: _LOGICAL_PROCESSOR_RELATIONSHIP = 4;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationAll: _LOGICAL_PROCESSOR_RELATIONSHIP = 65535;
pub type _LOGICAL_PROCESSOR_RELATIONSHIP = ::std::os::raw::c_int;
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP as LOGICAL_PROCESSOR_RELATIONSHIP;
pub const _PROCESSOR_CACHE_TYPE_CacheUnified: _PROCESSOR_CACHE_TYPE = 0;
pub const _PROCESSOR_CACHE_TYPE_CacheInstruction: _PROCESSOR_CACHE_TYPE = 1;
pub const _PROCESSOR_CACHE_TYPE_CacheData: _PROCESSOR_CACHE_TYPE = 2;
pub const _PROCESSOR_CACHE_TYPE_CacheTrace: _PROCESSOR_CACHE_TYPE = 3;
pub type _PROCESSOR_CACHE_TYPE = ::std::os::raw::c_int;
pub use self::_PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_DESCRIPTOR {
  pub Level: BYTE,
  pub Associativity: BYTE,
  pub LineSize: WORD,
  pub Size: DWORD,
  pub Type: PROCESSOR_CACHE_TYPE,
}
#[test]
fn bindgen_test_layout__CACHE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_CACHE_DESCRIPTOR>(),
    12usize,
    concat!("Size of: ", stringify!(_CACHE_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_CACHE_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_CACHE_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Associativity as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Associativity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).LineSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(LineSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Type as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_DESCRIPTOR),
      "::",
      stringify!(Type)
    )
  );
}
pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
  pub ProcessorMask: ULONG_PTR,
  pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
  pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
  pub ProcessorCore: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  pub NumaNode: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
  pub Cache: CACHE_DESCRIPTOR,
  pub Reserved: [ULONGLONG; 2usize],
  _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub Flags: BYTE,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Flags)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
  pub NodeNumber: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>()))
        .NodeNumber as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(NodeNumber)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).ProcessorCore
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(ProcessorCore)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).NumaNode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(NumaNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).Cache
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(Cache)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).Reserved
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>())).ProcessorMask as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
      "::",
      stringify!(ProcessorMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>())).Relationship as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
      "::",
      stringify!(Relationship)
    )
  );
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_RELATIONSHIP {
  pub Flags: BYTE,
  pub EfficiencyClass: BYTE,
  pub Reserved: [BYTE; 20usize],
  pub GroupCount: WORD,
  pub GroupMask: [GROUP_AFFINITY; 1usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_RELATIONSHIP() {
  assert_eq!(
    ::std::mem::size_of::<_PROCESSOR_RELATIONSHIP>(),
    40usize,
    concat!("Size of: ", stringify!(_PROCESSOR_RELATIONSHIP))
  );
  assert_eq!(
    ::std::mem::align_of::<_PROCESSOR_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).EfficiencyClass as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(EfficiencyClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).Reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).GroupCount as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(GroupCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).GroupMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NUMA_NODE_RELATIONSHIP {
  pub NodeNumber: DWORD,
  pub Reserved: [BYTE; 20usize],
  pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__NUMA_NODE_RELATIONSHIP() {
  assert_eq!(
    ::std::mem::size_of::<_NUMA_NODE_RELATIONSHIP>(),
    40usize,
    concat!("Size of: ", stringify!(_NUMA_NODE_RELATIONSHIP))
  );
  assert_eq!(
    ::std::mem::align_of::<_NUMA_NODE_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_NUMA_NODE_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).NodeNumber as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(NodeNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).GroupMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NUMA_NODE_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_RELATIONSHIP {
  pub Level: BYTE,
  pub Associativity: BYTE,
  pub LineSize: WORD,
  pub CacheSize: DWORD,
  pub Type: PROCESSOR_CACHE_TYPE,
  pub Reserved: [BYTE; 20usize],
  pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__CACHE_RELATIONSHIP() {
  assert_eq!(
    ::std::mem::size_of::<_CACHE_RELATIONSHIP>(),
    48usize,
    concat!("Size of: ", stringify!(_CACHE_RELATIONSHIP))
  );
  assert_eq!(
    ::std::mem::align_of::<_CACHE_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_CACHE_RELATIONSHIP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Level as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Level)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Associativity as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Associativity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).LineSize as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(LineSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).CacheSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(CacheSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Type as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Reserved as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).GroupMask as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_CACHE_RELATIONSHIP),
      "::",
      stringify!(GroupMask)
    )
  );
}
pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESSOR_GROUP_INFO {
  pub MaximumProcessorCount: BYTE,
  pub ActiveProcessorCount: BYTE,
  pub Reserved: [BYTE; 38usize],
  pub ActiveProcessorMask: KAFFINITY,
}
#[test]
fn bindgen_test_layout__PROCESSOR_GROUP_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_PROCESSOR_GROUP_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_PROCESSOR_GROUP_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_PROCESSOR_GROUP_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESSOR_GROUP_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).MaximumProcessorCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(MaximumProcessorCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).ActiveProcessorCount as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(ActiveProcessorCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).Reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).ActiveProcessorMask as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESSOR_GROUP_INFO),
      "::",
      stringify!(ActiveProcessorMask)
    )
  );
}
pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GROUP_RELATIONSHIP {
  pub MaximumGroupCount: WORD,
  pub ActiveGroupCount: WORD,
  pub Reserved: [BYTE; 20usize],
  pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__GROUP_RELATIONSHIP() {
  assert_eq!(
    ::std::mem::size_of::<_GROUP_RELATIONSHIP>(),
    72usize,
    concat!("Size of: ", stringify!(_GROUP_RELATIONSHIP))
  );
  assert_eq!(
    ::std::mem::align_of::<_GROUP_RELATIONSHIP>(),
    8usize,
    concat!("Alignment of ", stringify!(_GROUP_RELATIONSHIP))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).MaximumGroupCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(MaximumGroupCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).ActiveGroupCount as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(ActiveGroupCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).GroupInfo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_GROUP_RELATIONSHIP),
      "::",
      stringify!(GroupInfo)
    )
  );
}
pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
  pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
  pub Size: DWORD,
  pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
  pub Processor: PROCESSOR_RELATIONSHIP,
  pub NumaNode: NUMA_NODE_RELATIONSHIP,
  pub Cache: CACHE_RELATIONSHIP,
  pub Group: GROUP_RELATIONSHIP,
  _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
    72usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Processor
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Processor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).NumaNode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(NumaNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Cache
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Cache)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Group
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Group)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
    80usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>())).Relationship as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
      "::",
      stringify!(Relationship)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
      "::",
      stringify!(Size)
    )
  );
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const _CPU_SET_INFORMATION_TYPE_CpuSetInformation: _CPU_SET_INFORMATION_TYPE = 0;
pub type _CPU_SET_INFORMATION_TYPE = ::std::os::raw::c_int;
pub use self::_CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
  pub Size: DWORD,
  pub Type: CPU_SET_INFORMATION_TYPE,
  pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
  pub CpuSet: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
  pub Id: DWORD,
  pub Group: WORD,
  pub LogicalProcessorIndex: BYTE,
  pub CoreIndex: BYTE,
  pub LastLevelCacheIndex: BYTE,
  pub NumaNodeIndex: BYTE,
  pub EfficiencyClass: BYTE,
  pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  pub __bindgen_anon_2: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
  pub AllocationTag: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub AllFlags: BYTE,
  pub __bindgen_anon_1:
    _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
  assert_eq!(
    ::std::mem::size_of::<
      _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    >(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
      )
    )
  );
  assert_eq!(
    ::std::mem::align_of::<
      _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    >(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
      )
    )
  );
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  #[inline]
  pub fn Parked(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_Parked(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Allocated(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_Allocated(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn AllocatedToTargetProcess(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_AllocatedToTargetProcess(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn RealTime(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_RealTime(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn ReservedFlags(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
  }
  #[inline]
  pub fn set_ReservedFlags(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(4usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Parked: BYTE,
    Allocated: BYTE,
    AllocatedToTargetProcess: BYTE,
    RealTime: BYTE,
    ReservedFlags: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Parked: u8 = unsafe { ::std::mem::transmute(Parked) };
      Parked as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let Allocated: u8 = unsafe { ::std::mem::transmute(Allocated) };
      Allocated as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let AllocatedToTargetProcess: u8 = unsafe { ::std::mem::transmute(AllocatedToTargetProcess) };
      AllocatedToTargetProcess as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let RealTime: u8 = unsafe { ::std::mem::transmute(RealTime) };
      RealTime as u64
    });
    __bindgen_bitfield_unit.set(4usize, 4u8, {
      let ReservedFlags: u8 = unsafe { ::std::mem::transmute(ReservedFlags) };
      ReservedFlags as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
      )))
      .AllFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AllFlags)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
  pub Reserved: DWORD,
  pub SchedulingClass: BYTE,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
      )))
      .Reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
      )))
      .SchedulingClass as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(SchedulingClass)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).Id
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Id)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).Group
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Group)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .LogicalProcessorIndex as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(LogicalProcessorIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).CoreIndex
        as *const _ as usize
    },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(CoreIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .LastLevelCacheIndex as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(LastLevelCacheIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .NumaNodeIndex as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(NumaNodeIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .EfficiencyClass as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(EfficiencyClass)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
        .AllocationTag as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AllocationTag)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>())).CpuSet as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1),
      "::",
      stringify!(CpuSet)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION>(),
    32usize,
    concat!("Size of: ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION>())).Type as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_CPU_SET_INFORMATION),
      "::",
      stringify!(Type)
    )
  );
}
pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
  pub CycleTime: DWORD64,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>())).CycleTime as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION),
      "::",
      stringify!(CycleTime)
    )
  );
}
pub type SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCRUB_DATA_INPUT {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub MaximumIos: DWORD,
  pub ObjectId: [DWORD; 4usize],
  pub Reserved: [DWORD; 25usize],
  pub ResumeContext: [BYTE; 816usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCRUB_DATA_INPUT>(),
    944usize,
    concat!("Size of: ", stringify!(_SCRUB_DATA_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCRUB_DATA_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCRUB_DATA_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).MaximumIos as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(MaximumIos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).ObjectId as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(ObjectId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Reserved as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).ResumeContext as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_INPUT),
      "::",
      stringify!(ResumeContext)
    )
  );
}
pub type SCRUB_DATA_INPUT = _SCRUB_DATA_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT {
  pub Offset: LONGLONG,
  pub Length: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT() {
  assert_eq!(
    ::std::mem::size_of::<_SCRUB_PARITY_EXTENT>(),
    16usize,
    concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCRUB_PARITY_EXTENT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT>())).Offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT>())).Length as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT),
      "::",
      stringify!(Length)
    )
  );
}
pub type SCRUB_PARITY_EXTENT = _SCRUB_PARITY_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT_DATA {
  pub Size: WORD,
  pub Flags: WORD,
  pub NumberOfParityExtents: WORD,
  pub MaximumNumberOfParityExtents: WORD,
  pub ParityExtents: [SCRUB_PARITY_EXTENT; 1usize],
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_SCRUB_PARITY_EXTENT_DATA>(),
    24usize,
    concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCRUB_PARITY_EXTENT_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).Flags as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).NumberOfParityExtents as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(NumberOfParityExtents)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).MaximumNumberOfParityExtents as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(MaximumNumberOfParityExtents)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).ParityExtents as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_PARITY_EXTENT_DATA),
      "::",
      stringify!(ParityExtents)
    )
  );
}
pub type SCRUB_PARITY_EXTENT_DATA = _SCRUB_PARITY_EXTENT_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCRUB_DATA_OUTPUT {
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Status: DWORD,
  pub ErrorFileOffset: ULONGLONG,
  pub ErrorLength: ULONGLONG,
  pub NumberOfBytesRepaired: ULONGLONG,
  pub NumberOfBytesFailed: ULONGLONG,
  pub InternalFileReference: ULONGLONG,
  pub ResumeContextLength: WORD,
  pub ParityExtentDataOffset: WORD,
  pub Reserved: [DWORD; 9usize],
  pub NumberOfMetadataBytesProcessed: ULONGLONG,
  pub NumberOfDataBytesProcessed: ULONGLONG,
  pub TotalNumberOfMetadataBytesInUse: ULONGLONG,
  pub TotalNumberOfDataBytesInUse: ULONGLONG,
  pub ResumeContext: [BYTE; 816usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCRUB_DATA_OUTPUT>(),
    944usize,
    concat!("Size of: ", stringify!(_SCRUB_DATA_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCRUB_DATA_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCRUB_DATA_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Status as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Status)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ErrorFileOffset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ErrorFileOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ErrorLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ErrorLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfBytesRepaired as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfBytesRepaired)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfBytesFailed as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfBytesFailed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).InternalFileReference as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(InternalFileReference)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ResumeContextLength as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ResumeContextLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ParityExtentDataOffset as *const _ as usize
    },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ParityExtentDataOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Reserved as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfMetadataBytesProcessed as *const _
        as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfMetadataBytesProcessed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfDataBytesProcessed as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(NumberOfDataBytesProcessed)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).TotalNumberOfMetadataBytesInUse as *const _
        as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(TotalNumberOfMetadataBytesInUse)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).TotalNumberOfDataBytesInUse as *const _
        as usize
    },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(TotalNumberOfDataBytesInUse)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ResumeContext as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCRUB_DATA_OUTPUT),
      "::",
      stringify!(ResumeContext)
    )
  );
}
pub type SCRUB_DATA_OUTPUT = _SCRUB_DATA_OUTPUT;
pub const _SharedVirtualDiskSupportType_SharedVirtualDisksUnsupported:
  _SharedVirtualDiskSupportType = 0;
pub const _SharedVirtualDiskSupportType_SharedVirtualDisksSupported: _SharedVirtualDiskSupportType =
  1;
pub const _SharedVirtualDiskSupportType_SharedVirtualDiskSnapshotsSupported:
  _SharedVirtualDiskSupportType = 3;
pub const _SharedVirtualDiskSupportType_SharedVirtualDiskCDPSnapshotsSupported:
  _SharedVirtualDiskSupportType = 7;
pub type _SharedVirtualDiskSupportType = ::std::os::raw::c_int;
pub use self::_SharedVirtualDiskSupportType as SharedVirtualDiskSupportType;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateNone:
  _SharedVirtualDiskHandleState = 0;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateFileShared:
  _SharedVirtualDiskHandleState = 1;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateHandleShared:
  _SharedVirtualDiskHandleState = 3;
pub type _SharedVirtualDiskHandleState = ::std::os::raw::c_int;
pub use self::_SharedVirtualDiskHandleState as SharedVirtualDiskHandleState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARED_VIRTUAL_DISK_SUPPORT {
  pub SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
  pub HandleState: SharedVirtualDiskHandleState,
}
#[test]
fn bindgen_test_layout__SHARED_VIRTUAL_DISK_SUPPORT() {
  assert_eq!(
    ::std::mem::size_of::<_SHARED_VIRTUAL_DISK_SUPPORT>(),
    8usize,
    concat!("Size of: ", stringify!(_SHARED_VIRTUAL_DISK_SUPPORT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHARED_VIRTUAL_DISK_SUPPORT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SHARED_VIRTUAL_DISK_SUPPORT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHARED_VIRTUAL_DISK_SUPPORT>())).SharedVirtualDiskSupport as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHARED_VIRTUAL_DISK_SUPPORT),
      "::",
      stringify!(SharedVirtualDiskSupport)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHARED_VIRTUAL_DISK_SUPPORT>())).HandleState as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHARED_VIRTUAL_DISK_SUPPORT),
      "::",
      stringify!(HandleState)
    )
  );
}
pub type SHARED_VIRTUAL_DISK_SUPPORT = _SHARED_VIRTUAL_DISK_SUPPORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHUFFLE_FILE_DATA {
  pub StartingOffset: LONGLONG,
  pub Length: LONGLONG,
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__SHUFFLE_FILE_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_SHUFFLE_FILE_DATA>(),
    24usize,
    concat!("Size of: ", stringify!(_SHUFFLE_FILE_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHUFFLE_FILE_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHUFFLE_FILE_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).StartingOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHUFFLE_FILE_DATA),
      "::",
      stringify!(StartingOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).Length as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHUFFLE_FILE_DATA),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).Flags as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHUFFLE_FILE_DATA),
      "::",
      stringify!(Flags)
    )
  );
}
pub type SHUFFLE_FILE_DATA = _SHUFFLE_FILE_DATA;
pub const _SYSTEM_POWER_STATE_PowerSystemUnspecified: _SYSTEM_POWER_STATE = 0;
pub const _SYSTEM_POWER_STATE_PowerSystemWorking: _SYSTEM_POWER_STATE = 1;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping1: _SYSTEM_POWER_STATE = 2;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping2: _SYSTEM_POWER_STATE = 3;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping3: _SYSTEM_POWER_STATE = 4;
pub const _SYSTEM_POWER_STATE_PowerSystemHibernate: _SYSTEM_POWER_STATE = 5;
pub const _SYSTEM_POWER_STATE_PowerSystemShutdown: _SYSTEM_POWER_STATE = 6;
pub const _SYSTEM_POWER_STATE_PowerSystemMaximum: _SYSTEM_POWER_STATE = 7;
pub type _SYSTEM_POWER_STATE = ::std::os::raw::c_int;
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
pub const POWER_ACTION_PowerActionNone: POWER_ACTION = 0;
pub const POWER_ACTION_PowerActionReserved: POWER_ACTION = 1;
pub const POWER_ACTION_PowerActionSleep: POWER_ACTION = 2;
pub const POWER_ACTION_PowerActionHibernate: POWER_ACTION = 3;
pub const POWER_ACTION_PowerActionShutdown: POWER_ACTION = 4;
pub const POWER_ACTION_PowerActionShutdownReset: POWER_ACTION = 5;
pub const POWER_ACTION_PowerActionShutdownOff: POWER_ACTION = 6;
pub const POWER_ACTION_PowerActionWarmEject: POWER_ACTION = 7;
pub const POWER_ACTION_PowerActionDisplayOff: POWER_ACTION = 8;
pub type POWER_ACTION = ::std::os::raw::c_int;
pub const SYSTEM_POWER_CONDITION_PoAc: SYSTEM_POWER_CONDITION = 0;
pub const SYSTEM_POWER_CONDITION_PoDc: SYSTEM_POWER_CONDITION = 1;
pub const SYSTEM_POWER_CONDITION_PoHot: SYSTEM_POWER_CONDITION = 2;
pub const SYSTEM_POWER_CONDITION_PoConditionMaximum: SYSTEM_POWER_CONDITION = 3;
pub type SYSTEM_POWER_CONDITION = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SET_POWER_SETTING_VALUE {
  pub Version: DWORD,
  pub Guid: GUID,
  pub PowerCondition: SYSTEM_POWER_CONDITION,
  pub DataLength: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_SET_POWER_SETTING_VALUE() {
  assert_eq!(
    ::std::mem::size_of::<SET_POWER_SETTING_VALUE>(),
    32usize,
    concat!("Size of: ", stringify!(SET_POWER_SETTING_VALUE))
  );
  assert_eq!(
    ::std::mem::align_of::<SET_POWER_SETTING_VALUE>(),
    4usize,
    concat!("Alignment of ", stringify!(SET_POWER_SETTING_VALUE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Guid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Guid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).PowerCondition as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(PowerCondition)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).DataLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(DataLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SET_POWER_SETTING_VALUE),
      "::",
      stringify!(Data)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BATTERY_REPORTING_SCALE {
  pub Granularity: DWORD,
  pub Capacity: DWORD,
}
#[test]
fn bindgen_test_layout_BATTERY_REPORTING_SCALE() {
  assert_eq!(
    ::std::mem::size_of::<BATTERY_REPORTING_SCALE>(),
    8usize,
    concat!("Size of: ", stringify!(BATTERY_REPORTING_SCALE))
  );
  assert_eq!(
    ::std::mem::align_of::<BATTERY_REPORTING_SCALE>(),
    4usize,
    concat!("Alignment of ", stringify!(BATTERY_REPORTING_SCALE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<BATTERY_REPORTING_SCALE>())).Granularity as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(BATTERY_REPORTING_SCALE),
      "::",
      stringify!(Granularity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<BATTERY_REPORTING_SCALE>())).Capacity as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(BATTERY_REPORTING_SCALE),
      "::",
      stringify!(Capacity)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POWER_ACTION_POLICY {
  pub Action: POWER_ACTION,
  pub Flags: DWORD,
  pub EventCode: DWORD,
}
#[test]
fn bindgen_test_layout_POWER_ACTION_POLICY() {
  assert_eq!(
    ::std::mem::size_of::<POWER_ACTION_POLICY>(),
    12usize,
    concat!("Size of: ", stringify!(POWER_ACTION_POLICY))
  );
  assert_eq!(
    ::std::mem::align_of::<POWER_ACTION_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(POWER_ACTION_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).Action as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(Action)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).EventCode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(POWER_ACTION_POLICY),
      "::",
      stringify!(EventCode)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_LEVEL {
  pub Enable: BOOLEAN,
  pub Spare: [BYTE; 3usize],
  pub BatteryLevel: DWORD,
  pub PowerPolicy: POWER_ACTION_POLICY,
  pub MinSystemState: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_LEVEL() {
  assert_eq!(
    ::std::mem::size_of::<SYSTEM_POWER_LEVEL>(),
    24usize,
    concat!("Size of: ", stringify!(SYSTEM_POWER_LEVEL))
  );
  assert_eq!(
    ::std::mem::align_of::<SYSTEM_POWER_LEVEL>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_POWER_LEVEL))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).Enable as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(Enable)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).Spare as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(Spare)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).BatteryLevel as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(BatteryLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).PowerPolicy as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(PowerPolicy)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).MinSystemState as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_LEVEL),
      "::",
      stringify!(MinSystemState)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_POLICY {
  pub Revision: DWORD,
  pub PowerButton: POWER_ACTION_POLICY,
  pub SleepButton: POWER_ACTION_POLICY,
  pub LidClose: POWER_ACTION_POLICY,
  pub LidOpenWake: SYSTEM_POWER_STATE,
  pub Reserved: DWORD,
  pub Idle: POWER_ACTION_POLICY,
  pub IdleTimeout: DWORD,
  pub IdleSensitivity: BYTE,
  pub DynamicThrottle: BYTE,
  pub Spare2: [BYTE; 2usize],
  pub MinSleep: SYSTEM_POWER_STATE,
  pub MaxSleep: SYSTEM_POWER_STATE,
  pub ReducedLatencySleep: SYSTEM_POWER_STATE,
  pub WinLogonFlags: DWORD,
  pub Spare3: DWORD,
  pub DozeS4Timeout: DWORD,
  pub BroadcastCapacityResolution: DWORD,
  pub DischargePolicy: [SYSTEM_POWER_LEVEL; 4usize],
  pub VideoTimeout: DWORD,
  pub VideoDimDisplay: BOOLEAN,
  pub VideoReserved: [DWORD; 3usize],
  pub SpindownTimeout: DWORD,
  pub OptimizeForPower: BOOLEAN,
  pub FanThrottleTolerance: BYTE,
  pub ForcedThrottle: BYTE,
  pub MinThrottle: BYTE,
  pub OverThrottled: POWER_ACTION_POLICY,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_POLICY() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_POWER_POLICY>(),
    232usize,
    concat!("Size of: ", stringify!(_SYSTEM_POWER_POLICY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_POWER_POLICY>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_POWER_POLICY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Revision as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Revision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).PowerButton as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(PowerButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).SleepButton as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(SleepButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).LidClose as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(LidClose)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).LidOpenWake as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(LidOpenWake)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Reserved as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Idle as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Idle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).IdleTimeout as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(IdleTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).IdleSensitivity as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(IdleSensitivity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DynamicThrottle as *const _ as usize
    },
    65usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DynamicThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Spare2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Spare2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MinSleep as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MinSleep)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MaxSleep as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MaxSleep)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).ReducedLatencySleep as *const _ as usize
    },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(ReducedLatencySleep)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).WinLogonFlags as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(WinLogonFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Spare3 as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(Spare3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DozeS4Timeout as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DozeS4Timeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).BroadcastCapacityResolution as *const _
        as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(BroadcastCapacityResolution)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DischargePolicy as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(DischargePolicy)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoTimeout as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoDimDisplay as *const _ as usize
    },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoDimDisplay)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoReserved as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(VideoReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).SpindownTimeout as *const _ as usize
    },
    212usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(SpindownTimeout)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).OptimizeForPower as *const _ as usize
    },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(OptimizeForPower)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).FanThrottleTolerance as *const _ as usize
    },
    217usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(FanThrottleTolerance)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).ForcedThrottle as *const _ as usize },
    218usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(ForcedThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MinThrottle as *const _ as usize },
    219usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(MinThrottle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).OverThrottled as *const _ as usize },
    220usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_POLICY),
      "::",
      stringify!(OverThrottled)
    )
  );
}
pub type SYSTEM_POWER_POLICY = _SYSTEM_POWER_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_CAPABILITIES {
  pub PowerButtonPresent: BOOLEAN,
  pub SleepButtonPresent: BOOLEAN,
  pub LidPresent: BOOLEAN,
  pub SystemS1: BOOLEAN,
  pub SystemS2: BOOLEAN,
  pub SystemS3: BOOLEAN,
  pub SystemS4: BOOLEAN,
  pub SystemS5: BOOLEAN,
  pub HiberFilePresent: BOOLEAN,
  pub FullWake: BOOLEAN,
  pub VideoDimPresent: BOOLEAN,
  pub ApmPresent: BOOLEAN,
  pub UpsPresent: BOOLEAN,
  pub ThermalControl: BOOLEAN,
  pub ProcessorThrottle: BOOLEAN,
  pub ProcessorMinThrottle: BYTE,
  pub ProcessorMaxThrottle: BYTE,
  pub FastSystemS4: BOOLEAN,
  pub Hiberboot: BOOLEAN,
  pub WakeAlarmPresent: BOOLEAN,
  pub AoAc: BOOLEAN,
  pub DiskSpinDown: BOOLEAN,
  pub HiberFileType: BYTE,
  pub AoAcConnectivitySupported: BOOLEAN,
  pub spare3: [BYTE; 6usize],
  pub SystemBatteriesPresent: BOOLEAN,
  pub BatteriesAreShortTerm: BOOLEAN,
  pub BatteryScale: [BATTERY_REPORTING_SCALE; 3usize],
  pub AcOnLineWake: SYSTEM_POWER_STATE,
  pub SoftLidWake: SYSTEM_POWER_STATE,
  pub RtcWake: SYSTEM_POWER_STATE,
  pub MinDeviceWakeState: SYSTEM_POWER_STATE,
  pub DefaultLowLatencyWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_CAPABILITIES() {
  assert_eq!(
    ::std::mem::size_of::<SYSTEM_POWER_CAPABILITIES>(),
    76usize,
    concat!("Size of: ", stringify!(SYSTEM_POWER_CAPABILITIES))
  );
  assert_eq!(
    ::std::mem::align_of::<SYSTEM_POWER_CAPABILITIES>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_POWER_CAPABILITIES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).PowerButtonPresent as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(PowerButtonPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SleepButtonPresent as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SleepButtonPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).LidPresent as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(LidPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS1 as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS3 as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS4 as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS5 as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemS5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).HiberFilePresent as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(HiberFilePresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).FullWake as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(FullWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).VideoDimPresent as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(VideoDimPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ApmPresent as *const _ as usize
    },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ApmPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).UpsPresent as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(UpsPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ThermalControl as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ThermalControl)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorThrottle as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorMinThrottle as *const _
        as usize
    },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorMinThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorMaxThrottle as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(ProcessorMaxThrottle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).FastSystemS4 as *const _ as usize
    },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(FastSystemS4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).Hiberboot as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(Hiberboot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).WakeAlarmPresent as *const _ as usize
    },
    19usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(WakeAlarmPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AoAc as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AoAc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).DiskSpinDown as *const _ as usize
    },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(DiskSpinDown)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).HiberFileType as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(HiberFileType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AoAcConnectivitySupported as *const _
        as usize
    },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AoAcConnectivitySupported)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).spare3 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(spare3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemBatteriesPresent as *const _
        as usize
    },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SystemBatteriesPresent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).BatteriesAreShortTerm as *const _
        as usize
    },
    31usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(BatteriesAreShortTerm)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).BatteryScale as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(BatteryScale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AcOnLineWake as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(AcOnLineWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SoftLidWake as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(SoftLidWake)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).RtcWake as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(RtcWake)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).MinDeviceWakeState as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(MinDeviceWakeState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).DefaultLowLatencyWake as *const _
        as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_POWER_CAPABILITIES),
      "::",
      stringify!(DefaultLowLatencyWake)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_BATTERY_STATE {
  pub AcOnLine: BOOLEAN,
  pub BatteryPresent: BOOLEAN,
  pub Charging: BOOLEAN,
  pub Discharging: BOOLEAN,
  pub Spare1: [BOOLEAN; 3usize],
  pub Tag: BYTE,
  pub MaxCapacity: DWORD,
  pub RemainingCapacity: DWORD,
  pub Rate: DWORD,
  pub EstimatedTime: DWORD,
  pub DefaultAlert1: DWORD,
  pub DefaultAlert2: DWORD,
}
#[test]
fn bindgen_test_layout_SYSTEM_BATTERY_STATE() {
  assert_eq!(
    ::std::mem::size_of::<SYSTEM_BATTERY_STATE>(),
    32usize,
    concat!("Size of: ", stringify!(SYSTEM_BATTERY_STATE))
  );
  assert_eq!(
    ::std::mem::align_of::<SYSTEM_BATTERY_STATE>(),
    4usize,
    concat!("Alignment of ", stringify!(SYSTEM_BATTERY_STATE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).AcOnLine as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(AcOnLine)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).BatteryPresent as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(BatteryPresent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Charging as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Charging)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Discharging as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Discharging)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Spare1 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Spare1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Tag as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Tag)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).MaxCapacity as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(MaxCapacity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).RemainingCapacity as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(RemainingCapacity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Rate as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(Rate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).EstimatedTime as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(EstimatedTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).DefaultAlert1 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(DefaultAlert1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).DefaultAlert2 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SYSTEM_BATTERY_STATE),
      "::",
      stringify!(DefaultAlert2)
    )
  );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_ENTRY {
  pub Next: *mut _SLIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SLIST_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_SLIST_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SLIST_ENTRY>(),
    16usize,
    concat!("Alignment of ", stringify!(_SLIST_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SLIST_ENTRY>())).Next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_ENTRY),
      "::",
      stringify!(Next)
    )
  );
}
pub type SLIST_ENTRY = _SLIST_ENTRY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
  pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
  pub HeaderX64: _SLIST_HEADER__bindgen_ty_2,
  _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
  pub Alignment: ULONGLONG,
  pub Region: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SLIST_HEADER__bindgen_ty_1>())).Alignment as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER__bindgen_ty_1),
      "::",
      stringify!(Alignment)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SLIST_HEADER__bindgen_ty_1>())).Region as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER__bindgen_ty_1),
      "::",
      stringify!(Region)
    )
  );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize], u64>,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_2>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_2>(),
    8usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_2))
  );
}
impl _SLIST_HEADER__bindgen_ty_2 {
  #[inline]
  pub fn Depth(&self) -> ULONGLONG {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
  }
  #[inline]
  pub fn set_Depth(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn Sequence(&self) -> ULONGLONG {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
  }
  #[inline]
  pub fn set_Sequence(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::std::mem::transmute(val);
      self._bitfield_1.set(16usize, 48u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> ULONGLONG {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::std::mem::transmute(val);
      self._bitfield_1.set(64usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn NextEntry(&self) -> ULONGLONG {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
  }
  #[inline]
  pub fn set_NextEntry(&mut self, val: ULONGLONG) {
    unsafe {
      let val: u64 = ::std::mem::transmute(val);
      self._bitfield_1.set(68usize, 60u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Depth: ULONGLONG,
    Sequence: ULONGLONG,
    Reserved: ULONGLONG,
    NextEntry: ULONGLONG,
  ) -> __BindgenBitfieldUnit<[u8; 16usize], u64> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize], u64> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 16u8, {
      let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
      Depth as u64
    });
    __bindgen_bitfield_unit.set(16usize, 48u8, {
      let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
      Sequence as u64
    });
    __bindgen_bitfield_unit.set(64usize, 4u8, {
      let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit.set(68usize, 60u8, {
      let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
      NextEntry as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_SLIST_HEADER>(),
    16usize,
    concat!("Size of: ", stringify!(_SLIST_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SLIST_HEADER>(),
    16usize,
    concat!("Alignment of ", stringify!(_SLIST_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SLIST_HEADER>())).HeaderX64 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SLIST_HEADER),
      "::",
      stringify!(HeaderX64)
    )
  );
}
pub type SLIST_HEADER = _SLIST_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BARRIER {
  pub Reserved1: DWORD,
  pub Reserved2: DWORD,
  pub Reserved3: [ULONG_PTR; 2usize],
  pub Reserved4: DWORD,
  pub Reserved5: DWORD,
}
#[test]
fn bindgen_test_layout__RTL_BARRIER() {
  assert_eq!(
    ::std::mem::size_of::<_RTL_BARRIER>(),
    32usize,
    concat!("Size of: ", stringify!(_RTL_BARRIER))
  );
  assert_eq!(
    ::std::mem::align_of::<_RTL_BARRIER>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_BARRIER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved2 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved3 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved4 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved5 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_BARRIER),
      "::",
      stringify!(Reserved5)
    )
  );
}
pub type RTL_BARRIER = _RTL_BARRIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
  pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_SRWLOCK() {
  assert_eq!(
    ::std::mem::size_of::<_RTL_SRWLOCK>(),
    8usize,
    concat!("Size of: ", stringify!(_RTL_SRWLOCK))
  );
  assert_eq!(
    ::std::mem::align_of::<_RTL_SRWLOCK>(),
    8usize,
    concat!("Alignment of ", stringify!(_RTL_SRWLOCK))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RTL_SRWLOCK>())).Ptr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RTL_SRWLOCK),
      "::",
      stringify!(Ptr)
    )
  );
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SUPPORTED_OS_INFO {
  pub MajorVersion: WORD,
  pub MinorVersion: WORD,
}
#[test]
fn bindgen_test_layout__SUPPORTED_OS_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SUPPORTED_OS_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SUPPORTED_OS_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SUPPORTED_OS_INFO>(),
    2usize,
    concat!("Alignment of ", stringify!(_SUPPORTED_OS_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SUPPORTED_OS_INFO>())).MajorVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SUPPORTED_OS_INFO),
      "::",
      stringify!(MajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SUPPORTED_OS_INFO>())).MinorVersion as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SUPPORTED_OS_INFO),
      "::",
      stringify!(MinorVersion)
    )
  );
}
pub type SUPPORTED_OS_INFO = _SUPPORTED_OS_INFO;
pub const _CM_SERVICE_NODE_TYPE_DriverType: _CM_SERVICE_NODE_TYPE = 1;
pub const _CM_SERVICE_NODE_TYPE_FileSystemType: _CM_SERVICE_NODE_TYPE = 2;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceOwnProcess: _CM_SERVICE_NODE_TYPE = 16;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceShareProcess: _CM_SERVICE_NODE_TYPE = 32;
pub const _CM_SERVICE_NODE_TYPE_AdapterType: _CM_SERVICE_NODE_TYPE = 4;
pub const _CM_SERVICE_NODE_TYPE_RecognizerType: _CM_SERVICE_NODE_TYPE = 8;
pub type _CM_SERVICE_NODE_TYPE = ::std::os::raw::c_int;
pub use self::_CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE;
pub const _CM_SERVICE_LOAD_TYPE_BootLoad: _CM_SERVICE_LOAD_TYPE = 0;
pub const _CM_SERVICE_LOAD_TYPE_SystemLoad: _CM_SERVICE_LOAD_TYPE = 1;
pub const _CM_SERVICE_LOAD_TYPE_AutoLoad: _CM_SERVICE_LOAD_TYPE = 2;
pub const _CM_SERVICE_LOAD_TYPE_DemandLoad: _CM_SERVICE_LOAD_TYPE = 3;
pub const _CM_SERVICE_LOAD_TYPE_DisableLoad: _CM_SERVICE_LOAD_TYPE = 4;
pub type _CM_SERVICE_LOAD_TYPE = ::std::os::raw::c_int;
pub use self::_CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE;
pub const _CM_ERROR_CONTROL_TYPE_IgnoreError: _CM_ERROR_CONTROL_TYPE = 0;
pub const _CM_ERROR_CONTROL_TYPE_NormalError: _CM_ERROR_CONTROL_TYPE = 1;
pub const _CM_ERROR_CONTROL_TYPE_SevereError: _CM_ERROR_CONTROL_TYPE = 2;
pub const _CM_ERROR_CONTROL_TYPE_CriticalError: _CM_ERROR_CONTROL_TYPE = 3;
pub type _CM_ERROR_CONTROL_TYPE = ::std::os::raw::c_int;
pub use self::_CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE;
pub type SAVEPOINT_ID = ULONG;
pub type LPARAM = LONG_PTR;
pub type LRESULT = LONG_PTR;
pub type SPHANDLE = *mut HANDLE;
pub type HGLOBAL = HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HKEY__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HKEY__() {
  assert_eq!(
    ::std::mem::size_of::<HKEY__>(),
    4usize,
    concat!("Size of: ", stringify!(HKEY__))
  );
  assert_eq!(
    ::std::mem::align_of::<HKEY__>(),
    4usize,
    concat!("Alignment of ", stringify!(HKEY__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HKEY__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HKEY__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HKEY = *mut HKEY__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HINSTANCE__() {
  assert_eq!(
    ::std::mem::size_of::<HINSTANCE__>(),
    4usize,
    concat!("Size of: ", stringify!(HINSTANCE__))
  );
  assert_eq!(
    ::std::mem::align_of::<HINSTANCE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HINSTANCE__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HINSTANCE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HINSTANCE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HINSTANCE = *mut HINSTANCE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
  pub dwLowDateTime: DWORD,
  pub dwHighDateTime: DWORD,
}
#[test]
fn bindgen_test_layout__FILETIME() {
  assert_eq!(
    ::std::mem::size_of::<_FILETIME>(),
    8usize,
    concat!("Size of: ", stringify!(_FILETIME))
  );
  assert_eq!(
    ::std::mem::align_of::<_FILETIME>(),
    4usize,
    concat!("Alignment of ", stringify!(_FILETIME))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FILETIME>())).dwLowDateTime as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILETIME),
      "::",
      stringify!(dwLowDateTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FILETIME>())).dwHighDateTime as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FILETIME),
      "::",
      stringify!(dwHighDateTime)
    )
  );
}
pub type FILETIME = _FILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HWND__() {
  assert_eq!(
    ::std::mem::size_of::<HWND__>(),
    4usize,
    concat!("Size of: ", stringify!(HWND__))
  );
  assert_eq!(
    ::std::mem::align_of::<HWND__>(),
    4usize,
    concat!("Alignment of ", stringify!(HWND__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HWND__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HWND__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HBITMAP__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HBITMAP__() {
  assert_eq!(
    ::std::mem::size_of::<HBITMAP__>(),
    4usize,
    concat!("Size of: ", stringify!(HBITMAP__))
  );
  assert_eq!(
    ::std::mem::align_of::<HBITMAP__>(),
    4usize,
    concat!("Alignment of ", stringify!(HBITMAP__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HBITMAP__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HBITMAP__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HBITMAP = *mut HBITMAP__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HENHMETAFILE__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HENHMETAFILE__() {
  assert_eq!(
    ::std::mem::size_of::<HENHMETAFILE__>(),
    4usize,
    concat!("Size of: ", stringify!(HENHMETAFILE__))
  );
  assert_eq!(
    ::std::mem::align_of::<HENHMETAFILE__>(),
    4usize,
    concat!("Alignment of ", stringify!(HENHMETAFILE__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HENHMETAFILE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HENHMETAFILE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HENHMETAFILE = *mut HENHMETAFILE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HICON__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HICON__() {
  assert_eq!(
    ::std::mem::size_of::<HICON__>(),
    4usize,
    concat!("Size of: ", stringify!(HICON__))
  );
  assert_eq!(
    ::std::mem::align_of::<HICON__>(),
    4usize,
    concat!("Alignment of ", stringify!(HICON__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<HICON__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(HICON__),
      "::",
      stringify!(unused)
    )
  );
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRECT {
  pub left: LONG,
  pub top: LONG,
  pub right: LONG,
  pub bottom: LONG,
}
#[test]
fn bindgen_test_layout_tagRECT() {
  assert_eq!(
    ::std::mem::size_of::<tagRECT>(),
    16usize,
    concat!("Size of: ", stringify!(tagRECT))
  );
  assert_eq!(
    ::std::mem::align_of::<tagRECT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagRECT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRECT>())).left as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(left)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRECT>())).top as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(top)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRECT>())).right as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(right)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRECT>())).bottom as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRECT),
      "::",
      stringify!(bottom)
    )
  );
}
pub type RECT = tagRECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSIZE {
  pub cx: LONG,
  pub cy: LONG,
}
#[test]
fn bindgen_test_layout_tagSIZE() {
  assert_eq!(
    ::std::mem::size_of::<tagSIZE>(),
    8usize,
    concat!("Size of: ", stringify!(tagSIZE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSIZE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSIZE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSIZE>())).cx as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSIZE),
      "::",
      stringify!(cx)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSIZE>())).cy as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSIZE),
      "::",
      stringify!(cy)
    )
  );
}
pub type SIZE = tagSIZE;
pub type SIZEL = SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_ATTRIBUTES {
  pub nLength: DWORD,
  pub lpSecurityDescriptor: LPVOID,
  pub bInheritHandle: BOOL,
}
#[test]
fn bindgen_test_layout__SECURITY_ATTRIBUTES() {
  assert_eq!(
    ::std::mem::size_of::<_SECURITY_ATTRIBUTES>(),
    24usize,
    concat!("Size of: ", stringify!(_SECURITY_ATTRIBUTES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SECURITY_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SECURITY_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_ATTRIBUTES>())).nLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(nLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SECURITY_ATTRIBUTES>())).lpSecurityDescriptor as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(lpSecurityDescriptor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SECURITY_ATTRIBUTES>())).bInheritHandle as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SECURITY_ATTRIBUTES),
      "::",
      stringify!(bInheritHandle)
    )
  );
}
pub type SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES;
pub type LPSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OVERLAPPED {
  pub Internal: ULONG_PTR,
  pub InternalHigh: ULONG_PTR,
  pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1,
  pub hEvent: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OVERLAPPED__bindgen_ty_1 {
  pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1,
  pub Pointer: PVOID,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OVERLAPPED__bindgen_ty_1__bindgen_ty_1 {
  pub Offset: DWORD,
  pub OffsetHigh: DWORD,
}
#[test]
fn bindgen_test_layout__OVERLAPPED__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>())).Offset as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>())).OffsetHigh as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(OffsetHigh)
    )
  );
}
#[test]
fn bindgen_test_layout__OVERLAPPED__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_OVERLAPPED__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_OVERLAPPED__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_OVERLAPPED__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_OVERLAPPED__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OVERLAPPED__bindgen_ty_1>())).Pointer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED__bindgen_ty_1),
      "::",
      stringify!(Pointer)
    )
  );
}
#[test]
fn bindgen_test_layout__OVERLAPPED() {
  assert_eq!(
    ::std::mem::size_of::<_OVERLAPPED>(),
    32usize,
    concat!("Size of: ", stringify!(_OVERLAPPED))
  );
  assert_eq!(
    ::std::mem::align_of::<_OVERLAPPED>(),
    8usize,
    concat!("Alignment of ", stringify!(_OVERLAPPED))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OVERLAPPED>())).Internal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(Internal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OVERLAPPED>())).InternalHigh as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(InternalHigh)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_OVERLAPPED>())).hEvent as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_OVERLAPPED),
      "::",
      stringify!(hEvent)
    )
  );
}
pub type LPOVERLAPPED = *mut _OVERLAPPED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEMTIME {
  pub wYear: WORD,
  pub wMonth: WORD,
  pub wDayOfWeek: WORD,
  pub wDay: WORD,
  pub wHour: WORD,
  pub wMinute: WORD,
  pub wSecond: WORD,
  pub wMilliseconds: WORD,
}
#[test]
fn bindgen_test_layout__SYSTEMTIME() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEMTIME>(),
    16usize,
    concat!("Size of: ", stringify!(_SYSTEMTIME))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEMTIME>(),
    2usize,
    concat!("Alignment of ", stringify!(_SYSTEMTIME))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wYear as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wYear)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wMonth as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMonth)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wDayOfWeek as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wDayOfWeek)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wDay as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wDay)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wHour as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wHour)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wMinute as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMinute)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wSecond as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wSecond)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEMTIME>())).wMilliseconds as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEMTIME),
      "::",
      stringify!(wMilliseconds)
    )
  );
}
pub type SYSTEMTIME = _SYSTEMTIME;
pub const _STREAM_INFO_LEVELS_FindStreamInfoStandard: _STREAM_INFO_LEVELS = 0;
pub const _STREAM_INFO_LEVELS_FindStreamInfoMaxInfoLevel: _STREAM_INFO_LEVELS = 1;
pub type _STREAM_INFO_LEVELS = ::std::os::raw::c_int;
pub use self::_STREAM_INFO_LEVELS as STREAM_INFO_LEVELS;
pub type SRWLOCK = RTL_SRWLOCK;
pub type SYNCHRONIZATION_BARRIER = RTL_BARRIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_INFORMATION {
  pub hProcess: HANDLE,
  pub hThread: HANDLE,
  pub dwProcessId: DWORD,
  pub dwThreadId: DWORD,
}
#[test]
fn bindgen_test_layout__PROCESS_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_PROCESS_INFORMATION>(),
    24usize,
    concat!("Size of: ", stringify!(_PROCESS_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_PROCESS_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_PROCESS_INFORMATION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESS_INFORMATION>())).hProcess as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(hProcess)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESS_INFORMATION>())).hThread as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(hThread)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESS_INFORMATION>())).dwProcessId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(dwProcessId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PROCESS_INFORMATION>())).dwThreadId as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_PROCESS_INFORMATION),
      "::",
      stringify!(dwThreadId)
    )
  );
}
pub type LPPROCESS_INFORMATION = *mut _PROCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOA {
  pub cb: DWORD,
  pub lpReserved: LPSTR,
  pub lpDesktop: LPSTR,
  pub lpTitle: LPSTR,
  pub dwX: DWORD,
  pub dwY: DWORD,
  pub dwXSize: DWORD,
  pub dwYSize: DWORD,
  pub dwXCountChars: DWORD,
  pub dwYCountChars: DWORD,
  pub dwFillAttribute: DWORD,
  pub dwFlags: DWORD,
  pub wShowWindow: WORD,
  pub cbReserved2: WORD,
  pub lpReserved2: LPBYTE,
  pub hStdInput: HANDLE,
  pub hStdOutput: HANDLE,
  pub hStdError: HANDLE,
}
#[test]
fn bindgen_test_layout__STARTUPINFOA() {
  assert_eq!(
    ::std::mem::size_of::<_STARTUPINFOA>(),
    104usize,
    concat!("Size of: ", stringify!(_STARTUPINFOA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STARTUPINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).lpReserved as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).lpDesktop as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpDesktop)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).lpTitle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwX as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwX)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwY as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwY)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwXSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwXSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwYSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwYSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwXCountChars as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwXCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwYCountChars as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwYCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwFillAttribute as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwFillAttribute)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).dwFlags as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).wShowWindow as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(wShowWindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).cbReserved2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(cbReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).lpReserved2 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(lpReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).hStdInput as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdInput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).hStdOutput as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOA>())).hStdError as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOA),
      "::",
      stringify!(hStdError)
    )
  );
}
pub type STARTUPINFOA = _STARTUPINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOW {
  pub cb: DWORD,
  pub lpReserved: LPWSTR,
  pub lpDesktop: LPWSTR,
  pub lpTitle: LPWSTR,
  pub dwX: DWORD,
  pub dwY: DWORD,
  pub dwXSize: DWORD,
  pub dwYSize: DWORD,
  pub dwXCountChars: DWORD,
  pub dwYCountChars: DWORD,
  pub dwFillAttribute: DWORD,
  pub dwFlags: DWORD,
  pub wShowWindow: WORD,
  pub cbReserved2: WORD,
  pub lpReserved2: LPBYTE,
  pub hStdInput: HANDLE,
  pub hStdOutput: HANDLE,
  pub hStdError: HANDLE,
}
#[test]
fn bindgen_test_layout__STARTUPINFOW() {
  assert_eq!(
    ::std::mem::size_of::<_STARTUPINFOW>(),
    104usize,
    concat!("Size of: ", stringify!(_STARTUPINFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_STARTUPINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).cb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(cb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).lpReserved as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).lpDesktop as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpDesktop)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).lpTitle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwX as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwX)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwY as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwY)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwXSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwXSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwYSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwYSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwXCountChars as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwXCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwYCountChars as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwYCountChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwFillAttribute as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwFillAttribute)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).dwFlags as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).wShowWindow as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(wShowWindow)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).cbReserved2 as *const _ as usize },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(cbReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).lpReserved2 as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(lpReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).hStdInput as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdInput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).hStdOutput as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOW>())).hStdError as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOW),
      "::",
      stringify!(hStdError)
    )
  );
}
pub type STARTUPINFOW = _STARTUPINFOW;
pub type LPSTARTUPINFOW = *mut _STARTUPINFOW;
pub type STARTUPINFO = STARTUPINFOW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROC_THREAD_ATTRIBUTE_LIST {
  _unused: [u8; 0],
}
pub type LPPROC_THREAD_ATTRIBUTE_LIST = *mut _PROC_THREAD_ATTRIBUTE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_INFO {
  pub __bindgen_anon_1: _SYSTEM_INFO__bindgen_ty_1,
  pub dwPageSize: DWORD,
  pub lpMinimumApplicationAddress: LPVOID,
  pub lpMaximumApplicationAddress: LPVOID,
  pub dwActiveProcessorMask: DWORD_PTR,
  pub dwNumberOfProcessors: DWORD,
  pub dwProcessorType: DWORD,
  pub dwAllocationGranularity: DWORD,
  pub wProcessorLevel: WORD,
  pub wProcessorRevision: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_INFO__bindgen_ty_1 {
  pub dwOemId: DWORD,
  pub __bindgen_anon_1: _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1 {
  pub wProcessorArchitecture: WORD,
  pub wReserved: WORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>())).wProcessorArchitecture
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wProcessorArchitecture)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>())).wReserved as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_INFO__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_SYSTEM_INFO__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_INFO__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_INFO__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO__bindgen_ty_1>())).dwOemId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO__bindgen_ty_1),
      "::",
      stringify!(dwOemId)
    )
  );
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_SYSTEM_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SYSTEM_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwPageSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwPageSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO>())).lpMinimumApplicationAddress as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(lpMinimumApplicationAddress)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO>())).lpMaximumApplicationAddress as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(lpMaximumApplicationAddress)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwActiveProcessorMask as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwActiveProcessorMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwNumberOfProcessors as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwNumberOfProcessors)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwProcessorType as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwProcessorType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_INFO>())).dwAllocationGranularity as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(dwAllocationGranularity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).wProcessorLevel as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(wProcessorLevel)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_INFO>())).wProcessorRevision as *const _ as usize },
    46usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_INFO),
      "::",
      stringify!(wProcessorRevision)
    )
  );
}
pub type SYSTEM_INFO = _SYSTEM_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOEXA {
  pub StartupInfo: STARTUPINFOA,
  pub lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
}
#[test]
fn bindgen_test_layout__STARTUPINFOEXA() {
  assert_eq!(
    ::std::mem::size_of::<_STARTUPINFOEXA>(),
    112usize,
    concat!("Size of: ", stringify!(_STARTUPINFOEXA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STARTUPINFOEXA>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOEXA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOEXA>())).StartupInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXA),
      "::",
      stringify!(StartupInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOEXA>())).lpAttributeList as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXA),
      "::",
      stringify!(lpAttributeList)
    )
  );
}
pub type STARTUPINFOEXA = _STARTUPINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STARTUPINFOEXW {
  pub StartupInfo: STARTUPINFOW,
  pub lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
}
#[test]
fn bindgen_test_layout__STARTUPINFOEXW() {
  assert_eq!(
    ::std::mem::size_of::<_STARTUPINFOEXW>(),
    112usize,
    concat!("Size of: ", stringify!(_STARTUPINFOEXW))
  );
  assert_eq!(
    ::std::mem::align_of::<_STARTUPINFOEXW>(),
    8usize,
    concat!("Alignment of ", stringify!(_STARTUPINFOEXW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOEXW>())).StartupInfo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXW),
      "::",
      stringify!(StartupInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STARTUPINFOEXW>())).lpAttributeList as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_STARTUPINFOEXW),
      "::",
      stringify!(lpAttributeList)
    )
  );
}
pub type STARTUPINFOEXW = _STARTUPINFOEXW;
pub type STARTUPINFOEX = STARTUPINFOEXW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_STATUS {
  pub ACLineStatus: BYTE,
  pub BatteryFlag: BYTE,
  pub BatteryLifePercent: BYTE,
  pub SystemStatusFlag: BYTE,
  pub BatteryLifeTime: DWORD,
  pub BatteryFullLifeTime: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SYSTEM_POWER_STATUS>(),
    12usize,
    concat!("Size of: ", stringify!(_SYSTEM_POWER_STATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SYSTEM_POWER_STATUS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SYSTEM_POWER_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).ACLineStatus as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(ACLineStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryFlag as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryFlag)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryLifePercent as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryLifePercent)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).SystemStatusFlag as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(SystemStatusFlag)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryLifeTime as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryLifeTime)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SYSTEM_POWER_STATUS>())).BatteryFullLifeTime as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SYSTEM_POWER_STATUS),
      "::",
      stringify!(BatteryFullLifeTime)
    )
  );
}
pub type SYSTEM_POWER_STATUS = _SYSTEM_POWER_STATUS;
pub type SENDASYNCPROC = ::std::option::Option<
  unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: ULONG_PTR, arg4: LRESULT),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHELLHOOKINFO {
  pub hwnd: HWND,
  pub rc: RECT,
}
#[test]
fn bindgen_test_layout_SHELLHOOKINFO() {
  assert_eq!(
    ::std::mem::size_of::<SHELLHOOKINFO>(),
    24usize,
    concat!("Size of: ", stringify!(SHELLHOOKINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<SHELLHOOKINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(SHELLHOOKINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SHELLHOOKINFO>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SHELLHOOKINFO),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SHELLHOOKINFO>())).rc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SHELLHOOKINFO),
      "::",
      stringify!(rc)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLESTRUCT {
  pub styleOld: DWORD,
  pub styleNew: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTYLESTRUCT() {
  assert_eq!(
    ::std::mem::size_of::<tagSTYLESTRUCT>(),
    8usize,
    concat!("Size of: ", stringify!(tagSTYLESTRUCT))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTYLESTRUCT>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLESTRUCT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLESTRUCT>())).styleOld as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLESTRUCT),
      "::",
      stringify!(styleOld)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLESTRUCT>())).styleNew as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLESTRUCT),
      "::",
      stringify!(styleNew)
    )
  );
}
pub type STYLESTRUCT = tagSTYLESTRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSCROLLINFO {
  pub cbSize: UINT,
  pub fMask: UINT,
  pub nMin: ::std::os::raw::c_int,
  pub nMax: ::std::os::raw::c_int,
  pub nPage: UINT,
  pub nPos: ::std::os::raw::c_int,
  pub nTrackPos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tagSCROLLINFO() {
  assert_eq!(
    ::std::mem::size_of::<tagSCROLLINFO>(),
    28usize,
    concat!("Size of: ", stringify!(tagSCROLLINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSCROLLINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSCROLLINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nMin as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nMin)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nMax as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nPage as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nPage)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nPos as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nPos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLINFO>())).nTrackPos as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLINFO),
      "::",
      stringify!(nTrackPos)
    )
  );
}
pub type SCROLLINFO = tagSCROLLINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALKEYSA {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub lpszActivePort: LPSTR,
  pub lpszPort: LPSTR,
  pub iBaudRate: UINT,
  pub iPortState: UINT,
  pub iActive: UINT,
}
#[test]
fn bindgen_test_layout_tagSERIALKEYSA() {
  assert_eq!(
    ::std::mem::size_of::<tagSERIALKEYSA>(),
    40usize,
    concat!("Size of: ", stringify!(tagSERIALKEYSA))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSERIALKEYSA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSERIALKEYSA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).lpszActivePort as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(lpszActivePort)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).lpszPort as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(lpszPort)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).iBaudRate as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iBaudRate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).iPortState as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iPortState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSA>())).iActive as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSA),
      "::",
      stringify!(iActive)
    )
  );
}
pub type SERIALKEYSA = tagSERIALKEYSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALKEYSW {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub lpszActivePort: LPWSTR,
  pub lpszPort: LPWSTR,
  pub iBaudRate: UINT,
  pub iPortState: UINT,
  pub iActive: UINT,
}
#[test]
fn bindgen_test_layout_tagSERIALKEYSW() {
  assert_eq!(
    ::std::mem::size_of::<tagSERIALKEYSW>(),
    40usize,
    concat!("Size of: ", stringify!(tagSERIALKEYSW))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSERIALKEYSW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSERIALKEYSW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).lpszActivePort as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(lpszActivePort)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).lpszPort as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(lpszPort)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).iBaudRate as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iBaudRate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).iPortState as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iPortState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALKEYSW>())).iActive as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALKEYSW),
      "::",
      stringify!(iActive)
    )
  );
}
pub type SERIALKEYSW = tagSERIALKEYSW;
pub type SERIALKEYS = SERIALKEYSW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTICKYKEYS {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTICKYKEYS() {
  assert_eq!(
    ::std::mem::size_of::<tagSTICKYKEYS>(),
    8usize,
    concat!("Size of: ", stringify!(tagSTICKYKEYS))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTICKYKEYS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTICKYKEYS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTICKYKEYS>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTICKYKEYS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTICKYKEYS>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTICKYKEYS),
      "::",
      stringify!(dwFlags)
    )
  );
}
pub type STICKYKEYS = tagSTICKYKEYS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOUNDSENTRYA {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iFSTextEffect: DWORD,
  pub iFSTextEffectMSec: DWORD,
  pub iFSTextEffectColorBits: DWORD,
  pub iFSGrafEffect: DWORD,
  pub iFSGrafEffectMSec: DWORD,
  pub iFSGrafEffectColor: DWORD,
  pub iWindowsEffect: DWORD,
  pub iWindowsEffectMSec: DWORD,
  pub lpszWindowsEffectDLL: LPSTR,
  pub iWindowsEffectOrdinal: DWORD,
}
#[test]
fn bindgen_test_layout_tagSOUNDSENTRYA() {
  assert_eq!(
    ::std::mem::size_of::<tagSOUNDSENTRYA>(),
    56usize,
    concat!("Size of: ", stringify!(tagSOUNDSENTRYA))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOUNDSENTRYA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOUNDSENTRYA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffect as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffectMSec as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSTextEffectColorBits as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSTextEffectColorBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffect as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffectMSec as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffectMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iFSGrafEffectColor as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iFSGrafEffectColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffect as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffectMSec as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).lpszWindowsEffectDLL as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(lpszWindowsEffectDLL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYA>())).iWindowsEffectOrdinal as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYA),
      "::",
      stringify!(iWindowsEffectOrdinal)
    )
  );
}
pub type SOUNDSENTRYA = tagSOUNDSENTRYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOUNDSENTRYW {
  pub cbSize: UINT,
  pub dwFlags: DWORD,
  pub iFSTextEffect: DWORD,
  pub iFSTextEffectMSec: DWORD,
  pub iFSTextEffectColorBits: DWORD,
  pub iFSGrafEffect: DWORD,
  pub iFSGrafEffectMSec: DWORD,
  pub iFSGrafEffectColor: DWORD,
  pub iWindowsEffect: DWORD,
  pub iWindowsEffectMSec: DWORD,
  pub lpszWindowsEffectDLL: LPWSTR,
  pub iWindowsEffectOrdinal: DWORD,
}
#[test]
fn bindgen_test_layout_tagSOUNDSENTRYW() {
  assert_eq!(
    ::std::mem::size_of::<tagSOUNDSENTRYW>(),
    56usize,
    concat!("Size of: ", stringify!(tagSOUNDSENTRYW))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOUNDSENTRYW>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOUNDSENTRYW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffect as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffectMSec as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSTextEffectColorBits as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSTextEffectColorBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffect as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffectMSec as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffectMSec)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iFSGrafEffectColor as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iFSGrafEffectColor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffect as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffectMSec as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffectMSec)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).lpszWindowsEffectDLL as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(lpszWindowsEffectDLL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOUNDSENTRYW>())).iWindowsEffectOrdinal as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOUNDSENTRYW),
      "::",
      stringify!(iWindowsEffectOrdinal)
    )
  );
}
pub type SOUNDSENTRYW = tagSOUNDSENTRYW;
pub type SOUNDSENTRY = SOUNDSENTRYW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSCROLLBARINFO {
  pub cbSize: DWORD,
  pub rcScrollBar: RECT,
  pub dxyLineButton: ::std::os::raw::c_int,
  pub xyThumbTop: ::std::os::raw::c_int,
  pub xyThumbBottom: ::std::os::raw::c_int,
  pub reserved: ::std::os::raw::c_int,
  pub rgstate: [DWORD; 6usize],
}
#[test]
fn bindgen_test_layout_tagSCROLLBARINFO() {
  assert_eq!(
    ::std::mem::size_of::<tagSCROLLBARINFO>(),
    60usize,
    concat!("Size of: ", stringify!(tagSCROLLBARINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSCROLLBARINFO>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSCROLLBARINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).rcScrollBar as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(rcScrollBar)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).dxyLineButton as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(dxyLineButton)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).xyThumbTop as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(xyThumbTop)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).xyThumbBottom as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(xyThumbBottom)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).reserved as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSCROLLBARINFO>())).rgstate as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSCROLLBARINFO),
      "::",
      stringify!(rgstate)
    )
  );
}
pub type SCROLLBARINFO = tagSCROLLBARINFO;
pub const SYSNLS_FUNCTION_COMPARE_STRING: SYSNLS_FUNCTION = 1;
pub type SYSNLS_FUNCTION = ::std::os::raw::c_int;
pub const SYSGEOTYPE_GEO_NATION: SYSGEOTYPE = 1;
pub const SYSGEOTYPE_GEO_LATITUDE: SYSGEOTYPE = 2;
pub const SYSGEOTYPE_GEO_LONGITUDE: SYSGEOTYPE = 3;
pub const SYSGEOTYPE_GEO_ISO2: SYSGEOTYPE = 4;
pub const SYSGEOTYPE_GEO_ISO3: SYSGEOTYPE = 5;
pub const SYSGEOTYPE_GEO_RFC1766: SYSGEOTYPE = 6;
pub const SYSGEOTYPE_GEO_LCID: SYSGEOTYPE = 7;
pub const SYSGEOTYPE_GEO_FRIENDLYNAME: SYSGEOTYPE = 8;
pub const SYSGEOTYPE_GEO_OFFICIALNAME: SYSGEOTYPE = 9;
pub const SYSGEOTYPE_GEO_TIMEZONES: SYSGEOTYPE = 10;
pub const SYSGEOTYPE_GEO_OFFICIALLANGUAGES: SYSGEOTYPE = 11;
pub const SYSGEOTYPE_GEO_ISO_UN_NUMBER: SYSGEOTYPE = 12;
pub const SYSGEOTYPE_GEO_PARENT: SYSGEOTYPE = 13;
pub const SYSGEOTYPE_GEO_DIALINGCODE: SYSGEOTYPE = 14;
pub const SYSGEOTYPE_GEO_CURRENCYCODE: SYSGEOTYPE = 15;
pub const SYSGEOTYPE_GEO_CURRENCYSYMBOL: SYSGEOTYPE = 16;
pub const SYSGEOTYPE_GEO_NAME: SYSGEOTYPE = 17;
pub const SYSGEOTYPE_GEO_ID: SYSGEOTYPE = 18;
pub type SYSGEOTYPE = ::std::os::raw::c_int;
pub const SYSGEOCLASS_GEOCLASS_NATION: SYSGEOCLASS = 16;
pub const SYSGEOCLASS_GEOCLASS_REGION: SYSGEOCLASS = 14;
pub const SYSGEOCLASS_GEOCLASS_ALL: SYSGEOCLASS = 0;
pub type SYSGEOCLASS = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SMALL_RECT {
  pub Left: SHORT,
  pub Top: SHORT,
  pub Right: SHORT,
  pub Bottom: SHORT,
}
#[test]
fn bindgen_test_layout__SMALL_RECT() {
  assert_eq!(
    ::std::mem::size_of::<_SMALL_RECT>(),
    8usize,
    concat!("Size of: ", stringify!(_SMALL_RECT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SMALL_RECT>(),
    2usize,
    concat!("Alignment of ", stringify!(_SMALL_RECT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SMALL_RECT>())).Left as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Left)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SMALL_RECT>())).Top as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Top)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SMALL_RECT>())).Right as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Right)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SMALL_RECT>())).Bottom as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SMALL_RECT),
      "::",
      stringify!(Bottom)
    )
  );
}
pub type SMALL_RECT = _SMALL_RECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SESSION_HEADER {
  pub sess_name: UCHAR,
  pub num_sess: UCHAR,
  pub rcv_dg_outstanding: UCHAR,
  pub rcv_any_outstanding: UCHAR,
}
#[test]
fn bindgen_test_layout__SESSION_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_SESSION_HEADER>(),
    4usize,
    concat!("Size of: ", stringify!(_SESSION_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SESSION_HEADER>(),
    1usize,
    concat!("Alignment of ", stringify!(_SESSION_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_HEADER>())).sess_name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_HEADER),
      "::",
      stringify!(sess_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_HEADER>())).num_sess as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_HEADER),
      "::",
      stringify!(num_sess)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_HEADER>())).rcv_dg_outstanding as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_HEADER),
      "::",
      stringify!(rcv_dg_outstanding)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_HEADER>())).rcv_any_outstanding as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_HEADER),
      "::",
      stringify!(rcv_any_outstanding)
    )
  );
}
pub type SESSION_HEADER = _SESSION_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SESSION_BUFFER {
  pub lsn: UCHAR,
  pub state: UCHAR,
  pub local_name: [UCHAR; 16usize],
  pub remote_name: [UCHAR; 16usize],
  pub rcvs_outstanding: UCHAR,
  pub sends_outstanding: UCHAR,
}
#[test]
fn bindgen_test_layout__SESSION_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<_SESSION_BUFFER>(),
    36usize,
    concat!("Size of: ", stringify!(_SESSION_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SESSION_BUFFER>(),
    1usize,
    concat!("Alignment of ", stringify!(_SESSION_BUFFER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).lsn as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(lsn)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).state as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).local_name as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(local_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).remote_name as *const _ as usize },
    18usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(remote_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).rcvs_outstanding as *const _ as usize },
    34usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(rcvs_outstanding)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SESSION_BUFFER>())).sends_outstanding as *const _ as usize },
    35usize,
    concat!(
      "Offset of field: ",
      stringify!(_SESSION_BUFFER),
      "::",
      stringify!(sends_outstanding)
    )
  );
}
pub type SESSION_BUFFER = _SESSION_BUFFER;
pub type I_RPC_HANDLE = *mut ::std::os::raw::c_void;
pub type RPC_BINDING_HANDLE = I_RPC_HANDLE;
pub type handle_t = RPC_BINDING_HANDLE;
pub type UUID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_W {
  pub User: *mut ::std::os::raw::c_ushort,
  pub UserLength: ::std::os::raw::c_ulong,
  pub Domain: *mut ::std::os::raw::c_ushort,
  pub DomainLength: ::std::os::raw::c_ulong,
  pub Password: *mut ::std::os::raw::c_ushort,
  pub PasswordLength: ::std::os::raw::c_ulong,
  pub Flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__SEC_WINNT_AUTH_IDENTITY_W() {
  assert_eq!(
    ::std::mem::size_of::<_SEC_WINNT_AUTH_IDENTITY_W>(),
    48usize,
    concat!("Size of: ", stringify!(_SEC_WINNT_AUTH_IDENTITY_W))
  );
  assert_eq!(
    ::std::mem::align_of::<_SEC_WINNT_AUTH_IDENTITY_W>(),
    8usize,
    concat!("Alignment of ", stringify!(_SEC_WINNT_AUTH_IDENTITY_W))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(User)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).UserLength as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(UserLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).Domain as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(Domain)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).DomainLength as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(DomainLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).Password as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(Password)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).PasswordLength as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(PasswordLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_W>())).Flags as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_W),
      "::",
      stringify!(Flags)
    )
  );
}
pub type SEC_WINNT_AUTH_IDENTITY_W = _SEC_WINNT_AUTH_IDENTITY_W;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEC_WINNT_AUTH_IDENTITY_A {
  pub User: *mut ::std::os::raw::c_uchar,
  pub UserLength: ::std::os::raw::c_ulong,
  pub Domain: *mut ::std::os::raw::c_uchar,
  pub DomainLength: ::std::os::raw::c_ulong,
  pub Password: *mut ::std::os::raw::c_uchar,
  pub PasswordLength: ::std::os::raw::c_ulong,
  pub Flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__SEC_WINNT_AUTH_IDENTITY_A() {
  assert_eq!(
    ::std::mem::size_of::<_SEC_WINNT_AUTH_IDENTITY_A>(),
    48usize,
    concat!("Size of: ", stringify!(_SEC_WINNT_AUTH_IDENTITY_A))
  );
  assert_eq!(
    ::std::mem::align_of::<_SEC_WINNT_AUTH_IDENTITY_A>(),
    8usize,
    concat!("Alignment of ", stringify!(_SEC_WINNT_AUTH_IDENTITY_A))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).User as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(User)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).UserLength as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(UserLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).Domain as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(Domain)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).DomainLength as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(DomainLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).Password as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(Password)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).PasswordLength as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(PasswordLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SEC_WINNT_AUTH_IDENTITY_A>())).Flags as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SEC_WINNT_AUTH_IDENTITY_A),
      "::",
      stringify!(Flags)
    )
  );
}
pub type SEC_WINNT_AUTH_IDENTITY_A = _SEC_WINNT_AUTH_IDENTITY_A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_VERSION {
  pub MajorVersion: ::std::os::raw::c_ushort,
  pub MinorVersion: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__RPC_VERSION() {
  assert_eq!(
    ::std::mem::size_of::<_RPC_VERSION>(),
    4usize,
    concat!("Size of: ", stringify!(_RPC_VERSION))
  );
  assert_eq!(
    ::std::mem::align_of::<_RPC_VERSION>(),
    2usize,
    concat!("Alignment of ", stringify!(_RPC_VERSION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_VERSION>())).MajorVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_VERSION),
      "::",
      stringify!(MajorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_VERSION>())).MinorVersion as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_VERSION),
      "::",
      stringify!(MinorVersion)
    )
  );
}
pub type RPC_VERSION = _RPC_VERSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_SYNTAX_IDENTIFIER {
  pub SyntaxGUID: GUID,
  pub SyntaxVersion: RPC_VERSION,
}
#[test]
fn bindgen_test_layout__RPC_SYNTAX_IDENTIFIER() {
  assert_eq!(
    ::std::mem::size_of::<_RPC_SYNTAX_IDENTIFIER>(),
    20usize,
    concat!("Size of: ", stringify!(_RPC_SYNTAX_IDENTIFIER))
  );
  assert_eq!(
    ::std::mem::align_of::<_RPC_SYNTAX_IDENTIFIER>(),
    4usize,
    concat!("Alignment of ", stringify!(_RPC_SYNTAX_IDENTIFIER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_SYNTAX_IDENTIFIER>())).SyntaxGUID as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_SYNTAX_IDENTIFIER),
      "::",
      stringify!(SyntaxGUID)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_RPC_SYNTAX_IDENTIFIER>())).SyntaxVersion as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_SYNTAX_IDENTIFIER),
      "::",
      stringify!(SyntaxVersion)
    )
  );
}
pub type PRPC_SYNTAX_IDENTIFIER = *mut _RPC_SYNTAX_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_MESSAGE {
  pub Handle: RPC_BINDING_HANDLE,
  pub DataRepresentation: ::std::os::raw::c_ulong,
  pub Buffer: *mut ::std::os::raw::c_void,
  pub BufferLength: ::std::os::raw::c_uint,
  pub ProcNum: ::std::os::raw::c_uint,
  pub TransferSyntax: PRPC_SYNTAX_IDENTIFIER,
  pub RpcInterfaceInformation: *mut ::std::os::raw::c_void,
  pub ReservedForRuntime: *mut ::std::os::raw::c_void,
  pub ManagerEpv: *mut ::std::os::raw::c_void,
  pub ImportContext: *mut ::std::os::raw::c_void,
  pub RpcFlags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__RPC_MESSAGE() {
  assert_eq!(
    ::std::mem::size_of::<_RPC_MESSAGE>(),
    80usize,
    concat!("Size of: ", stringify!(_RPC_MESSAGE))
  );
  assert_eq!(
    ::std::mem::align_of::<_RPC_MESSAGE>(),
    8usize,
    concat!("Alignment of ", stringify!(_RPC_MESSAGE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).Handle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(Handle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).DataRepresentation as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(DataRepresentation)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).Buffer as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(Buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).BufferLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(BufferLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).ProcNum as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(ProcNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).TransferSyntax as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(TransferSyntax)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_RPC_MESSAGE>())).RpcInterfaceInformation as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(RpcInterfaceInformation)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).ReservedForRuntime as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(ReservedForRuntime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).ManagerEpv as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(ManagerEpv)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).ImportContext as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(ImportContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_RPC_MESSAGE>())).RpcFlags as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_RPC_MESSAGE),
      "::",
      stringify!(RpcFlags)
    )
  );
}
pub type PRPC_MESSAGE = *mut _RPC_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _AppBarData {
  pub cbSize: DWORD,
  pub hWnd: HWND,
  pub uCallbackMessage: UINT,
  pub uEdge: UINT,
  pub rc: RECT,
  pub lParam: LPARAM,
}
#[test]
fn bindgen_test_layout__AppBarData() {
  assert_eq!(
    ::std::mem::size_of::<_AppBarData>(),
    48usize,
    concat!("Size of: ", stringify!(_AppBarData))
  );
  assert_eq!(
    ::std::mem::align_of::<_AppBarData>(),
    8usize,
    concat!("Alignment of ", stringify!(_AppBarData))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).hWnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(hWnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).uCallbackMessage as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(uCallbackMessage)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).uEdge as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(uEdge)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).rc as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(rc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_AppBarData>())).lParam as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_AppBarData),
      "::",
      stringify!(lParam)
    )
  );
}
pub type PAPPBARDATA = *mut _AppBarData;
extern "C" {
  pub fn SHAppBarMessage(dwMessage: DWORD, pData: PAPPBARDATA) -> UINT_PTR;
}
pub type FILEOP_FLAGS = WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHFILEOPSTRUCTA {
  pub hwnd: HWND,
  pub wFunc: UINT,
  pub pFrom: PCZZSTR,
  pub pTo: PCZZSTR,
  pub fFlags: FILEOP_FLAGS,
  pub fAnyOperationsAborted: BOOL,
  pub hNameMappings: LPVOID,
  pub lpszProgressTitle: PCSTR,
}
#[test]
fn bindgen_test_layout__SHFILEOPSTRUCTA() {
  assert_eq!(
    ::std::mem::size_of::<_SHFILEOPSTRUCTA>(),
    56usize,
    concat!("Size of: ", stringify!(_SHFILEOPSTRUCTA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHFILEOPSTRUCTA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHFILEOPSTRUCTA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).wFunc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(wFunc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).pFrom as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(pFrom)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).pTo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(pTo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).fFlags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(fFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).fAnyOperationsAborted as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(fAnyOperationsAborted)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).hNameMappings as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(hNameMappings)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTA>())).lpszProgressTitle as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTA),
      "::",
      stringify!(lpszProgressTitle)
    )
  );
}
pub type SHFILEOPSTRUCTA = _SHFILEOPSTRUCTA;
pub type LPSHFILEOPSTRUCTA = *mut _SHFILEOPSTRUCTA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHFILEOPSTRUCTW {
  pub hwnd: HWND,
  pub wFunc: UINT,
  pub pFrom: PCZZWSTR,
  pub pTo: PCZZWSTR,
  pub fFlags: FILEOP_FLAGS,
  pub fAnyOperationsAborted: BOOL,
  pub hNameMappings: LPVOID,
  pub lpszProgressTitle: PCWSTR,
}
#[test]
fn bindgen_test_layout__SHFILEOPSTRUCTW() {
  assert_eq!(
    ::std::mem::size_of::<_SHFILEOPSTRUCTW>(),
    56usize,
    concat!("Size of: ", stringify!(_SHFILEOPSTRUCTW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHFILEOPSTRUCTW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHFILEOPSTRUCTW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).hwnd as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).wFunc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(wFunc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).pFrom as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(pFrom)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).pTo as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(pTo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).fFlags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(fFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).fAnyOperationsAborted as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(fAnyOperationsAborted)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).hNameMappings as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(hNameMappings)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEOPSTRUCTW>())).lpszProgressTitle as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEOPSTRUCTW),
      "::",
      stringify!(lpszProgressTitle)
    )
  );
}
pub type SHFILEOPSTRUCTW = _SHFILEOPSTRUCTW;
pub type LPSHFILEOPSTRUCTW = *mut _SHFILEOPSTRUCTW;
pub type SHFILEOPSTRUCT = SHFILEOPSTRUCTW;
extern "C" {
  pub fn SHFileOperationA(lpFileOp: LPSHFILEOPSTRUCTA) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SHFileOperationW(lpFileOp: LPSHFILEOPSTRUCTW) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SHFreeNameMappings(hNameMappings: HANDLE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHNAMEMAPPINGA {
  pub pszOldPath: LPSTR,
  pub pszNewPath: LPSTR,
  pub cchOldPath: ::std::os::raw::c_int,
  pub cchNewPath: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__SHNAMEMAPPINGA() {
  assert_eq!(
    ::std::mem::size_of::<_SHNAMEMAPPINGA>(),
    24usize,
    concat!("Size of: ", stringify!(_SHNAMEMAPPINGA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHNAMEMAPPINGA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHNAMEMAPPINGA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGA>())).pszOldPath as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGA),
      "::",
      stringify!(pszOldPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGA>())).pszNewPath as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGA),
      "::",
      stringify!(pszNewPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGA>())).cchOldPath as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGA),
      "::",
      stringify!(cchOldPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGA>())).cchNewPath as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGA),
      "::",
      stringify!(cchNewPath)
    )
  );
}
pub type SHNAMEMAPPINGA = _SHNAMEMAPPINGA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHNAMEMAPPINGW {
  pub pszOldPath: LPWSTR,
  pub pszNewPath: LPWSTR,
  pub cchOldPath: ::std::os::raw::c_int,
  pub cchNewPath: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__SHNAMEMAPPINGW() {
  assert_eq!(
    ::std::mem::size_of::<_SHNAMEMAPPINGW>(),
    24usize,
    concat!("Size of: ", stringify!(_SHNAMEMAPPINGW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHNAMEMAPPINGW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHNAMEMAPPINGW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGW>())).pszOldPath as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGW),
      "::",
      stringify!(pszOldPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGW>())).pszNewPath as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGW),
      "::",
      stringify!(pszNewPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGW>())).cchOldPath as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGW),
      "::",
      stringify!(cchOldPath)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHNAMEMAPPINGW>())).cchNewPath as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHNAMEMAPPINGW),
      "::",
      stringify!(cchNewPath)
    )
  );
}
pub type SHNAMEMAPPINGW = _SHNAMEMAPPINGW;
pub type SHNAMEMAPPING = SHNAMEMAPPINGW;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHELLEXECUTEINFOA {
  pub cbSize: DWORD,
  pub fMask: ULONG,
  pub hwnd: HWND,
  pub lpVerb: LPCSTR,
  pub lpFile: LPCSTR,
  pub lpParameters: LPCSTR,
  pub lpDirectory: LPCSTR,
  pub nShow: ::std::os::raw::c_int,
  pub hInstApp: HINSTANCE,
  pub lpIDList: *mut ::std::os::raw::c_void,
  pub lpClass: LPCSTR,
  pub hkeyClass: HKEY,
  pub dwHotKey: DWORD,
  pub __bindgen_anon_1: _SHELLEXECUTEINFOA__bindgen_ty_1,
  pub hProcess: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SHELLEXECUTEINFOA__bindgen_ty_1 {
  pub hIcon: HANDLE,
  pub hMonitor: HANDLE,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__SHELLEXECUTEINFOA__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SHELLEXECUTEINFOA__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_SHELLEXECUTEINFOA__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHELLEXECUTEINFOA__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SHELLEXECUTEINFOA__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHELLEXECUTEINFOA__bindgen_ty_1>())).hIcon as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA__bindgen_ty_1),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHELLEXECUTEINFOA__bindgen_ty_1>())).hMonitor as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA__bindgen_ty_1),
      "::",
      stringify!(hMonitor)
    )
  );
}
#[test]
fn bindgen_test_layout__SHELLEXECUTEINFOA() {
  assert_eq!(
    ::std::mem::size_of::<_SHELLEXECUTEINFOA>(),
    112usize,
    concat!("Size of: ", stringify!(_SHELLEXECUTEINFOA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHELLEXECUTEINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHELLEXECUTEINFOA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).hwnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpVerb as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpVerb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpParameters as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpParameters)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpDirectory as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).nShow as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(nShow)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).hInstApp as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(hInstApp)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpIDList as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpIDList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).lpClass as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(lpClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).hkeyClass as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(hkeyClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).dwHotKey as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(dwHotKey)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOA>())).hProcess as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOA),
      "::",
      stringify!(hProcess)
    )
  );
}
pub type SHELLEXECUTEINFOA = _SHELLEXECUTEINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHELLEXECUTEINFOW {
  pub cbSize: DWORD,
  pub fMask: ULONG,
  pub hwnd: HWND,
  pub lpVerb: LPCWSTR,
  pub lpFile: LPCWSTR,
  pub lpParameters: LPCWSTR,
  pub lpDirectory: LPCWSTR,
  pub nShow: ::std::os::raw::c_int,
  pub hInstApp: HINSTANCE,
  pub lpIDList: *mut ::std::os::raw::c_void,
  pub lpClass: LPCWSTR,
  pub hkeyClass: HKEY,
  pub dwHotKey: DWORD,
  pub __bindgen_anon_1: _SHELLEXECUTEINFOW__bindgen_ty_1,
  pub hProcess: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SHELLEXECUTEINFOW__bindgen_ty_1 {
  pub hIcon: HANDLE,
  pub hMonitor: HANDLE,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__SHELLEXECUTEINFOW__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SHELLEXECUTEINFOW__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_SHELLEXECUTEINFOW__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHELLEXECUTEINFOW__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SHELLEXECUTEINFOW__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHELLEXECUTEINFOW__bindgen_ty_1>())).hIcon as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW__bindgen_ty_1),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHELLEXECUTEINFOW__bindgen_ty_1>())).hMonitor as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW__bindgen_ty_1),
      "::",
      stringify!(hMonitor)
    )
  );
}
#[test]
fn bindgen_test_layout__SHELLEXECUTEINFOW() {
  assert_eq!(
    ::std::mem::size_of::<_SHELLEXECUTEINFOW>(),
    112usize,
    concat!("Size of: ", stringify!(_SHELLEXECUTEINFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHELLEXECUTEINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHELLEXECUTEINFOW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).hwnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpVerb as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpVerb)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpParameters as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpParameters)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpDirectory as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).nShow as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(nShow)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).hInstApp as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(hInstApp)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpIDList as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpIDList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).lpClass as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(lpClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).hkeyClass as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(hkeyClass)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).dwHotKey as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(dwHotKey)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHELLEXECUTEINFOW>())).hProcess as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHELLEXECUTEINFOW),
      "::",
      stringify!(hProcess)
    )
  );
}
pub type SHELLEXECUTEINFOW = _SHELLEXECUTEINFOW;
pub type SHELLEXECUTEINFO = SHELLEXECUTEINFOW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHCREATEPROCESSINFOW {
  pub cbSize: DWORD,
  pub fMask: ULONG,
  pub hwnd: HWND,
  pub pszFile: LPCWSTR,
  pub pszParameters: LPCWSTR,
  pub pszCurrentDirectory: LPCWSTR,
  pub hUserToken: HANDLE,
  pub lpProcessAttributes: LPSECURITY_ATTRIBUTES,
  pub lpThreadAttributes: LPSECURITY_ATTRIBUTES,
  pub bInheritHandles: BOOL,
  pub dwCreationFlags: DWORD,
  pub lpStartupInfo: LPSTARTUPINFOW,
  pub lpProcessInformation: LPPROCESS_INFORMATION,
}
#[test]
fn bindgen_test_layout__SHCREATEPROCESSINFOW() {
  assert_eq!(
    ::std::mem::size_of::<_SHCREATEPROCESSINFOW>(),
    88usize,
    concat!("Size of: ", stringify!(_SHCREATEPROCESSINFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHCREATEPROCESSINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHCREATEPROCESSINFOW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).fMask as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(fMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).hwnd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(hwnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).pszFile as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(pszFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).pszParameters as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(pszParameters)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).pszCurrentDirectory as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(pszCurrentDirectory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).hUserToken as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(hUserToken)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).lpProcessAttributes as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(lpProcessAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).lpThreadAttributes as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(lpThreadAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).bInheritHandles as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(bInheritHandles)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).dwCreationFlags as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(dwCreationFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).lpStartupInfo as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(lpStartupInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHCREATEPROCESSINFOW>())).lpProcessInformation as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHCREATEPROCESSINFOW),
      "::",
      stringify!(lpProcessInformation)
    )
  );
}
pub type SHCREATEPROCESSINFOW = _SHCREATEPROCESSINFOW;
pub type PSHCREATEPROCESSINFOW = *mut _SHCREATEPROCESSINFOW;
extern "C" {
  pub fn SHCreateProcessAsUserW(pscpi: PSHCREATEPROCESSINFOW) -> BOOL;
}
extern "C" {
  pub fn SHEvaluateSystemCommandTemplate(
    pszCmdTemplate: PCWSTR,
    ppszApplication: *mut PWSTR,
    ppszCommandLine: *mut PWSTR,
    ppszParameters: *mut PWSTR,
  ) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHQUERYRBINFO {
  pub cbSize: DWORD,
  pub i64Size: ::std::os::raw::c_longlong,
  pub i64NumItems: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__SHQUERYRBINFO() {
  assert_eq!(
    ::std::mem::size_of::<_SHQUERYRBINFO>(),
    24usize,
    concat!("Size of: ", stringify!(_SHQUERYRBINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHQUERYRBINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHQUERYRBINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHQUERYRBINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHQUERYRBINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHQUERYRBINFO>())).i64Size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHQUERYRBINFO),
      "::",
      stringify!(i64Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHQUERYRBINFO>())).i64NumItems as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHQUERYRBINFO),
      "::",
      stringify!(i64NumItems)
    )
  );
}
pub type SHQUERYRBINFO = _SHQUERYRBINFO;
pub type LPSHQUERYRBINFO = *mut _SHQUERYRBINFO;
extern "C" {
  pub fn SHQueryRecycleBinA(pszRootPath: LPCSTR, pSHQueryRBInfo: LPSHQUERYRBINFO) -> HRESULT;
}
extern "C" {
  pub fn SHQueryRecycleBinW(pszRootPath: LPCWSTR, pSHQueryRBInfo: LPSHQUERYRBINFO) -> HRESULT;
}
extern "C" {
  pub fn SHEmptyRecycleBinA(hwnd: HWND, pszRootPath: LPCSTR, dwFlags: DWORD) -> HRESULT;
}
extern "C" {
  pub fn SHEmptyRecycleBinW(hwnd: HWND, pszRootPath: LPCWSTR, dwFlags: DWORD) -> HRESULT;
}
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_NOT_PRESENT: QUERY_USER_NOTIFICATION_STATE = 1;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_BUSY: QUERY_USER_NOTIFICATION_STATE = 2;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_RUNNING_D3D_FULL_SCREEN:
  QUERY_USER_NOTIFICATION_STATE = 3;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_PRESENTATION_MODE: QUERY_USER_NOTIFICATION_STATE = 4;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_ACCEPTS_NOTIFICATIONS: QUERY_USER_NOTIFICATION_STATE =
  5;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_QUIET_TIME: QUERY_USER_NOTIFICATION_STATE = 6;
pub const QUERY_USER_NOTIFICATION_STATE_QUNS_APP: QUERY_USER_NOTIFICATION_STATE = 7;
pub type QUERY_USER_NOTIFICATION_STATE = ::std::os::raw::c_int;
extern "C" {
  pub fn SHQueryUserNotificationState(pquns: *mut QUERY_USER_NOTIFICATION_STATE) -> HRESULT;
}
extern "C" {
  pub fn SHGetPropertyStoreForWindow(
    hwnd: HWND,
    riid: *const IID,
    ppv: *mut *mut ::std::os::raw::c_void,
  ) -> HRESULT;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHFILEINFOA {
  pub hIcon: HICON,
  pub iIcon: ::std::os::raw::c_int,
  pub dwAttributes: DWORD,
  pub szDisplayName: [CHAR; 260usize],
  pub szTypeName: [CHAR; 80usize],
}
#[test]
fn bindgen_test_layout__SHFILEINFOA() {
  assert_eq!(
    ::std::mem::size_of::<_SHFILEINFOA>(),
    360usize,
    concat!("Size of: ", stringify!(_SHFILEINFOA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHFILEINFOA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHFILEINFOA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).hIcon as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).iIcon as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(iIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).dwAttributes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(dwAttributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).szDisplayName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(szDisplayName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOA>())).szTypeName as *const _ as usize },
    276usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOA),
      "::",
      stringify!(szTypeName)
    )
  );
}
pub type SHFILEINFOA = _SHFILEINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHFILEINFOW {
  pub hIcon: HICON,
  pub iIcon: ::std::os::raw::c_int,
  pub dwAttributes: DWORD,
  pub szDisplayName: [WCHAR; 260usize],
  pub szTypeName: [WCHAR; 80usize],
}
#[test]
fn bindgen_test_layout__SHFILEINFOW() {
  assert_eq!(
    ::std::mem::size_of::<_SHFILEINFOW>(),
    696usize,
    concat!("Size of: ", stringify!(_SHFILEINFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHFILEINFOW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHFILEINFOW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).hIcon as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).iIcon as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(iIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).dwAttributes as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(dwAttributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).szDisplayName as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(szDisplayName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHFILEINFOW>())).szTypeName as *const _ as usize },
    536usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHFILEINFOW),
      "::",
      stringify!(szTypeName)
    )
  );
}
pub type SHFILEINFOW = _SHFILEINFOW;
pub type SHFILEINFO = SHFILEINFOW;
extern "C" {
  pub fn SHGetFileInfoA(
    pszPath: LPCSTR,
    dwFileAttributes: DWORD,
    psfi: *mut SHFILEINFOA,
    cbFileInfo: UINT,
    uFlags: UINT,
  ) -> DWORD_PTR;
}
extern "C" {
  pub fn SHGetFileInfoW(
    pszPath: LPCWSTR,
    dwFileAttributes: DWORD,
    psfi: *mut SHFILEINFOW,
    cbFileInfo: UINT,
    uFlags: UINT,
  ) -> DWORD_PTR;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SHSTOCKICONINFO {
  pub cbSize: DWORD,
  pub hIcon: HICON,
  pub iSysImageIndex: ::std::os::raw::c_int,
  pub iIcon: ::std::os::raw::c_int,
  pub szPath: [WCHAR; 260usize],
}
#[test]
fn bindgen_test_layout__SHSTOCKICONINFO() {
  assert_eq!(
    ::std::mem::size_of::<_SHSTOCKICONINFO>(),
    544usize,
    concat!("Size of: ", stringify!(_SHSTOCKICONINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHSTOCKICONINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHSTOCKICONINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).hIcon as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).iSysImageIndex as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(iSysImageIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).iIcon as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(iIcon)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHSTOCKICONINFO>())).szPath as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHSTOCKICONINFO),
      "::",
      stringify!(szPath)
    )
  );
}
pub type SHSTOCKICONINFO = _SHSTOCKICONINFO;
pub const SHSTOCKICONID_SIID_DOCNOASSOC: SHSTOCKICONID = 0;
pub const SHSTOCKICONID_SIID_DOCASSOC: SHSTOCKICONID = 1;
pub const SHSTOCKICONID_SIID_APPLICATION: SHSTOCKICONID = 2;
pub const SHSTOCKICONID_SIID_FOLDER: SHSTOCKICONID = 3;
pub const SHSTOCKICONID_SIID_FOLDEROPEN: SHSTOCKICONID = 4;
pub const SHSTOCKICONID_SIID_DRIVE525: SHSTOCKICONID = 5;
pub const SHSTOCKICONID_SIID_DRIVE35: SHSTOCKICONID = 6;
pub const SHSTOCKICONID_SIID_DRIVEREMOVE: SHSTOCKICONID = 7;
pub const SHSTOCKICONID_SIID_DRIVEFIXED: SHSTOCKICONID = 8;
pub const SHSTOCKICONID_SIID_DRIVENET: SHSTOCKICONID = 9;
pub const SHSTOCKICONID_SIID_DRIVENETDISABLED: SHSTOCKICONID = 10;
pub const SHSTOCKICONID_SIID_DRIVECD: SHSTOCKICONID = 11;
pub const SHSTOCKICONID_SIID_DRIVERAM: SHSTOCKICONID = 12;
pub const SHSTOCKICONID_SIID_WORLD: SHSTOCKICONID = 13;
pub const SHSTOCKICONID_SIID_SERVER: SHSTOCKICONID = 15;
pub const SHSTOCKICONID_SIID_PRINTER: SHSTOCKICONID = 16;
pub const SHSTOCKICONID_SIID_MYNETWORK: SHSTOCKICONID = 17;
pub const SHSTOCKICONID_SIID_FIND: SHSTOCKICONID = 22;
pub const SHSTOCKICONID_SIID_HELP: SHSTOCKICONID = 23;
pub const SHSTOCKICONID_SIID_SHARE: SHSTOCKICONID = 28;
pub const SHSTOCKICONID_SIID_LINK: SHSTOCKICONID = 29;
pub const SHSTOCKICONID_SIID_SLOWFILE: SHSTOCKICONID = 30;
pub const SHSTOCKICONID_SIID_RECYCLER: SHSTOCKICONID = 31;
pub const SHSTOCKICONID_SIID_RECYCLERFULL: SHSTOCKICONID = 32;
pub const SHSTOCKICONID_SIID_MEDIACDAUDIO: SHSTOCKICONID = 40;
pub const SHSTOCKICONID_SIID_LOCK: SHSTOCKICONID = 47;
pub const SHSTOCKICONID_SIID_AUTOLIST: SHSTOCKICONID = 49;
pub const SHSTOCKICONID_SIID_PRINTERNET: SHSTOCKICONID = 50;
pub const SHSTOCKICONID_SIID_SERVERSHARE: SHSTOCKICONID = 51;
pub const SHSTOCKICONID_SIID_PRINTERFAX: SHSTOCKICONID = 52;
pub const SHSTOCKICONID_SIID_PRINTERFAXNET: SHSTOCKICONID = 53;
pub const SHSTOCKICONID_SIID_PRINTERFILE: SHSTOCKICONID = 54;
pub const SHSTOCKICONID_SIID_STACK: SHSTOCKICONID = 55;
pub const SHSTOCKICONID_SIID_MEDIASVCD: SHSTOCKICONID = 56;
pub const SHSTOCKICONID_SIID_STUFFEDFOLDER: SHSTOCKICONID = 57;
pub const SHSTOCKICONID_SIID_DRIVEUNKNOWN: SHSTOCKICONID = 58;
pub const SHSTOCKICONID_SIID_DRIVEDVD: SHSTOCKICONID = 59;
pub const SHSTOCKICONID_SIID_MEDIADVD: SHSTOCKICONID = 60;
pub const SHSTOCKICONID_SIID_MEDIADVDRAM: SHSTOCKICONID = 61;
pub const SHSTOCKICONID_SIID_MEDIADVDRW: SHSTOCKICONID = 62;
pub const SHSTOCKICONID_SIID_MEDIADVDR: SHSTOCKICONID = 63;
pub const SHSTOCKICONID_SIID_MEDIADVDROM: SHSTOCKICONID = 64;
pub const SHSTOCKICONID_SIID_MEDIACDAUDIOPLUS: SHSTOCKICONID = 65;
pub const SHSTOCKICONID_SIID_MEDIACDRW: SHSTOCKICONID = 66;
pub const SHSTOCKICONID_SIID_MEDIACDR: SHSTOCKICONID = 67;
pub const SHSTOCKICONID_SIID_MEDIACDBURN: SHSTOCKICONID = 68;
pub const SHSTOCKICONID_SIID_MEDIABLANKCD: SHSTOCKICONID = 69;
pub const SHSTOCKICONID_SIID_MEDIACDROM: SHSTOCKICONID = 70;
pub const SHSTOCKICONID_SIID_AUDIOFILES: SHSTOCKICONID = 71;
pub const SHSTOCKICONID_SIID_IMAGEFILES: SHSTOCKICONID = 72;
pub const SHSTOCKICONID_SIID_VIDEOFILES: SHSTOCKICONID = 73;
pub const SHSTOCKICONID_SIID_MIXEDFILES: SHSTOCKICONID = 74;
pub const SHSTOCKICONID_SIID_FOLDERBACK: SHSTOCKICONID = 75;
pub const SHSTOCKICONID_SIID_FOLDERFRONT: SHSTOCKICONID = 76;
pub const SHSTOCKICONID_SIID_SHIELD: SHSTOCKICONID = 77;
pub const SHSTOCKICONID_SIID_WARNING: SHSTOCKICONID = 78;
pub const SHSTOCKICONID_SIID_INFO: SHSTOCKICONID = 79;
pub const SHSTOCKICONID_SIID_ERROR: SHSTOCKICONID = 80;
pub const SHSTOCKICONID_SIID_KEY: SHSTOCKICONID = 81;
pub const SHSTOCKICONID_SIID_SOFTWARE: SHSTOCKICONID = 82;
pub const SHSTOCKICONID_SIID_RENAME: SHSTOCKICONID = 83;
pub const SHSTOCKICONID_SIID_DELETE: SHSTOCKICONID = 84;
pub const SHSTOCKICONID_SIID_MEDIAAUDIODVD: SHSTOCKICONID = 85;
pub const SHSTOCKICONID_SIID_MEDIAMOVIEDVD: SHSTOCKICONID = 86;
pub const SHSTOCKICONID_SIID_MEDIAENHANCEDCD: SHSTOCKICONID = 87;
pub const SHSTOCKICONID_SIID_MEDIAENHANCEDDVD: SHSTOCKICONID = 88;
pub const SHSTOCKICONID_SIID_MEDIAHDDVD: SHSTOCKICONID = 89;
pub const SHSTOCKICONID_SIID_MEDIABLURAY: SHSTOCKICONID = 90;
pub const SHSTOCKICONID_SIID_MEDIAVCD: SHSTOCKICONID = 91;
pub const SHSTOCKICONID_SIID_MEDIADVDPLUSR: SHSTOCKICONID = 92;
pub const SHSTOCKICONID_SIID_MEDIADVDPLUSRW: SHSTOCKICONID = 93;
pub const SHSTOCKICONID_SIID_DESKTOPPC: SHSTOCKICONID = 94;
pub const SHSTOCKICONID_SIID_MOBILEPC: SHSTOCKICONID = 95;
pub const SHSTOCKICONID_SIID_USERS: SHSTOCKICONID = 96;
pub const SHSTOCKICONID_SIID_MEDIASMARTMEDIA: SHSTOCKICONID = 97;
pub const SHSTOCKICONID_SIID_MEDIACOMPACTFLASH: SHSTOCKICONID = 98;
pub const SHSTOCKICONID_SIID_DEVICECELLPHONE: SHSTOCKICONID = 99;
pub const SHSTOCKICONID_SIID_DEVICECAMERA: SHSTOCKICONID = 100;
pub const SHSTOCKICONID_SIID_DEVICEVIDEOCAMERA: SHSTOCKICONID = 101;
pub const SHSTOCKICONID_SIID_DEVICEAUDIOPLAYER: SHSTOCKICONID = 102;
pub const SHSTOCKICONID_SIID_NETWORKCONNECT: SHSTOCKICONID = 103;
pub const SHSTOCKICONID_SIID_INTERNET: SHSTOCKICONID = 104;
pub const SHSTOCKICONID_SIID_ZIPFILE: SHSTOCKICONID = 105;
pub const SHSTOCKICONID_SIID_SETTINGS: SHSTOCKICONID = 106;
pub const SHSTOCKICONID_SIID_DRIVEHDDVD: SHSTOCKICONID = 132;
pub const SHSTOCKICONID_SIID_DRIVEBD: SHSTOCKICONID = 133;
pub const SHSTOCKICONID_SIID_MEDIAHDDVDROM: SHSTOCKICONID = 134;
pub const SHSTOCKICONID_SIID_MEDIAHDDVDR: SHSTOCKICONID = 135;
pub const SHSTOCKICONID_SIID_MEDIAHDDVDRAM: SHSTOCKICONID = 136;
pub const SHSTOCKICONID_SIID_MEDIABDROM: SHSTOCKICONID = 137;
pub const SHSTOCKICONID_SIID_MEDIABDR: SHSTOCKICONID = 138;
pub const SHSTOCKICONID_SIID_MEDIABDRE: SHSTOCKICONID = 139;
pub const SHSTOCKICONID_SIID_CLUSTEREDDRIVE: SHSTOCKICONID = 140;
pub const SHSTOCKICONID_SIID_MAX_ICONS: SHSTOCKICONID = 181;
pub type SHSTOCKICONID = ::std::os::raw::c_int;
extern "C" {
  pub fn SHGetStockIconInfo(
    siid: SHSTOCKICONID,
    uFlags: UINT,
    psii: *mut SHSTOCKICONINFO,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHGetDiskFreeSpaceExA(
    pszDirectoryName: LPCSTR,
    pulFreeBytesAvailableToCaller: *mut ULARGE_INTEGER,
    pulTotalNumberOfBytes: *mut ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: *mut ULARGE_INTEGER,
  ) -> BOOL;
}
extern "C" {
  pub fn SHGetDiskFreeSpaceExW(
    pszDirectoryName: LPCWSTR,
    pulFreeBytesAvailableToCaller: *mut ULARGE_INTEGER,
    pulTotalNumberOfBytes: *mut ULARGE_INTEGER,
    pulTotalNumberOfFreeBytes: *mut ULARGE_INTEGER,
  ) -> BOOL;
}
extern "C" {
  pub fn SHGetNewLinkInfoA(
    pszLinkTo: LPCSTR,
    pszDir: LPCSTR,
    pszName: LPSTR,
    pfMustCopy: *mut BOOL,
    uFlags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn SHGetNewLinkInfoW(
    pszLinkTo: LPCWSTR,
    pszDir: LPCWSTR,
    pszName: LPWSTR,
    pfMustCopy: *mut BOOL,
    uFlags: UINT,
  ) -> BOOL;
}
extern "C" {
  pub fn SHInvokePrinterCommandA(
    hwnd: HWND,
    uAction: UINT,
    lpBuf1: LPCSTR,
    lpBuf2: LPCSTR,
    fModal: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SHInvokePrinterCommandW(
    hwnd: HWND,
    uAction: UINT,
    lpBuf1: LPCWSTR,
    lpBuf2: LPCWSTR,
    fModal: BOOL,
  ) -> BOOL;
}
extern "C" {
  pub fn SHLoadNonloadedIconOverlayIdentifiers() -> HRESULT;
}
extern "C" {
  pub fn SHIsFileAvailableOffline(pwszPath: PCWSTR, pdwStatus: *mut DWORD) -> HRESULT;
}
extern "C" {
  pub fn SHSetLocalizedName(
    pszPath: PCWSTR,
    pszResModule: PCWSTR,
    idsRes: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHRemoveLocalizedName(pszPath: PCWSTR) -> HRESULT;
}
extern "C" {
  pub fn SHGetLocalizedName(
    pszPath: PCWSTR,
    pszResModule: PWSTR,
    cch: UINT,
    pidsRes: *mut ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHEnumerateUnreadMailAccountsA(
    hKeyUser: HKEY,
    dwIndex: DWORD,
    pszMailAddress: LPSTR,
    cchMailAddress: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHEnumerateUnreadMailAccountsW(
    hKeyUser: HKEY,
    dwIndex: DWORD,
    pszMailAddress: LPWSTR,
    cchMailAddress: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHGetUnreadMailCountA(
    hKeyUser: HKEY,
    pszMailAddress: LPCSTR,
    pdwCount: *mut DWORD,
    pFileTime: *mut FILETIME,
    pszShellExecuteCommand: LPSTR,
    cchShellExecuteCommand: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHGetUnreadMailCountW(
    hKeyUser: HKEY,
    pszMailAddress: LPCWSTR,
    pdwCount: *mut DWORD,
    pFileTime: *mut FILETIME,
    pszShellExecuteCommand: LPWSTR,
    cchShellExecuteCommand: ::std::os::raw::c_int,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHSetUnreadMailCountA(
    pszMailAddress: LPCSTR,
    dwCount: DWORD,
    pszShellExecuteCommand: LPCSTR,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHSetUnreadMailCountW(
    pszMailAddress: LPCWSTR,
    dwCount: DWORD,
    pszShellExecuteCommand: LPCWSTR,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHTestTokenMembership(hToken: HANDLE, ulRID: ULONG) -> BOOL;
}
extern "C" {
  pub fn SHGetImageList(
    iImageList: ::std::os::raw::c_int,
    riid: *const IID,
    ppvObj: *mut *mut ::std::os::raw::c_void,
  ) -> HRESULT;
}
extern "C" {
  pub fn SHGetDriveMedia(pszDrive: PCWSTR, pdwMediaContent: *mut DWORD) -> HRESULT;
}
pub type u_short = ::std::os::raw::c_ushort;
pub type SOCKET = UINT_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
  pub s_name: *mut ::std::os::raw::c_char,
  pub s_aliases: *mut *mut ::std::os::raw::c_char,
  pub s_proto: *mut ::std::os::raw::c_char,
  pub s_port: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_servent() {
  assert_eq!(
    ::std::mem::size_of::<servent>(),
    32usize,
    concat!("Size of: ", stringify!(servent))
  );
  assert_eq!(
    ::std::mem::align_of::<servent>(),
    8usize,
    concat!("Alignment of ", stringify!(servent))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<servent>())).s_name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(servent),
      "::",
      stringify!(s_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<servent>())).s_aliases as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(servent),
      "::",
      stringify!(s_aliases)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<servent>())).s_proto as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(servent),
      "::",
      stringify!(s_proto)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<servent>())).s_port as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(servent),
      "::",
      stringify!(s_port)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
  pub S_un: in_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in_addr__bindgen_ty_1 {
  pub S_un_b: in_addr__bindgen_ty_1__bindgen_ty_1,
  pub S_un_w: in_addr__bindgen_ty_1__bindgen_ty_2,
  pub S_addr: ULONG,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_1 {
  pub s_b1: UCHAR,
  pub s_b2: UCHAR,
  pub s_b3: UCHAR,
  pub s_b4: UCHAR,
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<in_addr__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(in_addr__bindgen_ty_1__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<in_addr__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(s_b1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b2 as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(s_b2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b3 as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(s_b3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_1>())).s_b4 as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(s_b4)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_2 {
  pub s_w1: USHORT,
  pub s_w2: USHORT,
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<in_addr__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!("Size of: ", stringify!(in_addr__bindgen_ty_1__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<in_addr__bindgen_ty_1__bindgen_ty_2>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_2>())).s_w1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(s_w1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<in_addr__bindgen_ty_1__bindgen_ty_2>())).s_w2 as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(s_w2)
    )
  );
}
#[test]
fn bindgen_test_layout_in_addr__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<in_addr__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(in_addr__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<in_addr__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(in_addr__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_un_b as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1),
      "::",
      stringify!(S_un_b)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_un_w as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1),
      "::",
      stringify!(S_un_w)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<in_addr__bindgen_ty_1>())).S_addr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr__bindgen_ty_1),
      "::",
      stringify!(S_addr)
    )
  );
}
#[test]
fn bindgen_test_layout_in_addr() {
  assert_eq!(
    ::std::mem::size_of::<in_addr>(),
    4usize,
    concat!("Size of: ", stringify!(in_addr))
  );
  assert_eq!(
    ::std::mem::align_of::<in_addr>(),
    4usize,
    concat!("Alignment of ", stringify!(in_addr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<in_addr>())).S_un as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(in_addr),
      "::",
      stringify!(S_un)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in {
  pub sin_family: ::std::os::raw::c_short,
  pub sin_port: u_short,
  pub sin_addr: in_addr,
  pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
  assert_eq!(
    ::std::mem::size_of::<sockaddr_in>(),
    16usize,
    concat!("Size of: ", stringify!(sockaddr_in))
  );
  assert_eq!(
    ::std::mem::align_of::<sockaddr_in>(),
    4usize,
    concat!("Alignment of ", stringify!(sockaddr_in))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_in),
      "::",
      stringify!(sin_family)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_in),
      "::",
      stringify!(sin_port)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_in),
      "::",
      stringify!(sin_addr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr_in),
      "::",
      stringify!(sin_zero)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
  pub sa_family: u_short,
  pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
  assert_eq!(
    ::std::mem::size_of::<sockaddr>(),
    16usize,
    concat!("Size of: ", stringify!(sockaddr))
  );
  assert_eq!(
    ::std::mem::align_of::<sockaddr>(),
    2usize,
    concat!("Alignment of ", stringify!(sockaddr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr),
      "::",
      stringify!(sa_family)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(sockaddr),
      "::",
      stringify!(sa_data)
    )
  );
}
pub type SOCKADDR = sockaddr;
pub type SOCKADDR_IN = sockaddr_in;
pub type SERVENT = servent;
pub type ALG_ID = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCHANNEL_ALG {
  pub dwUse: DWORD,
  pub Algid: ALG_ID,
  pub cBits: DWORD,
  pub dwFlags: DWORD,
  pub dwReserved: DWORD,
}
#[test]
fn bindgen_test_layout__SCHANNEL_ALG() {
  assert_eq!(
    ::std::mem::size_of::<_SCHANNEL_ALG>(),
    20usize,
    concat!("Size of: ", stringify!(_SCHANNEL_ALG))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCHANNEL_ALG>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCHANNEL_ALG))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).dwUse as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(dwUse)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).Algid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(Algid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).cBits as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(cBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).dwFlags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCHANNEL_ALG>())).dwReserved as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCHANNEL_ALG),
      "::",
      stringify!(dwReserved)
    )
  );
}
pub type SCHANNEL_ALG = _SCHANNEL_ALG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_ECCKEY_BLOB {
  pub dwCurveType: ULONG,
  pub cbKey: ULONG,
}
#[test]
fn bindgen_test_layout__SSL_ECCKEY_BLOB() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_ECCKEY_BLOB>(),
    8usize,
    concat!("Size of: ", stringify!(_SSL_ECCKEY_BLOB))
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_ECCKEY_BLOB>(),
    4usize,
    concat!("Alignment of ", stringify!(_SSL_ECCKEY_BLOB))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SSL_ECCKEY_BLOB>())).dwCurveType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_ECCKEY_BLOB),
      "::",
      stringify!(dwCurveType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SSL_ECCKEY_BLOB>())).cbKey as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_ECCKEY_BLOB),
      "::",
      stringify!(cbKey)
    )
  );
}
pub type SSL_ECCKEY_BLOB = _SSL_ECCKEY_BLOB;
pub type SECURITY_STATUS = LONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HTTPSPolicyCallbackData {
  pub __bindgen_anon_1: _HTTPSPolicyCallbackData__bindgen_ty_1,
  pub dwAuthType: DWORD,
  pub fdwChecks: DWORD,
  pub pwszServerName: *mut WCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _HTTPSPolicyCallbackData__bindgen_ty_1 {
  pub cbStruct: DWORD,
  pub cbSize: DWORD,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__HTTPSPolicyCallbackData__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_HTTPSPolicyCallbackData__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_HTTPSPolicyCallbackData__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_HTTPSPolicyCallbackData__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_HTTPSPolicyCallbackData__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_HTTPSPolicyCallbackData__bindgen_ty_1>())).cbStruct as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData__bindgen_ty_1),
      "::",
      stringify!(cbStruct)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_HTTPSPolicyCallbackData__bindgen_ty_1>())).cbSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData__bindgen_ty_1),
      "::",
      stringify!(cbSize)
    )
  );
}
#[test]
fn bindgen_test_layout__HTTPSPolicyCallbackData() {
  assert_eq!(
    ::std::mem::size_of::<_HTTPSPolicyCallbackData>(),
    24usize,
    concat!("Size of: ", stringify!(_HTTPSPolicyCallbackData))
  );
  assert_eq!(
    ::std::mem::align_of::<_HTTPSPolicyCallbackData>(),
    8usize,
    concat!("Alignment of ", stringify!(_HTTPSPolicyCallbackData))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_HTTPSPolicyCallbackData>())).dwAuthType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData),
      "::",
      stringify!(dwAuthType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_HTTPSPolicyCallbackData>())).fdwChecks as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData),
      "::",
      stringify!(fdwChecks)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_HTTPSPolicyCallbackData>())).pwszServerName as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_HTTPSPolicyCallbackData),
      "::",
      stringify!(pwszServerName)
    )
  );
}
pub type SSL_EXTRA_CERT_CHAIN_POLICY_PARA = _HTTPSPolicyCallbackData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS {
  pub cbSize: DWORD,
  pub dwErrorLevel: DWORD,
  pub dwErrorCategory: DWORD,
  pub dwReserved: DWORD,
  pub wszErrorText: [WCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>(),
    528usize,
    concat!(
      "Size of: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).cbSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).dwErrorLevel as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(dwErrorLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).dwErrorCategory
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(dwErrorCategory)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).dwReserved as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS>())).wszErrorText as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(wszErrorText)
    )
  );
}
pub type SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA {
  pub cbSize: DWORD,
  pub dwReserved: DWORD,
  pub pwszServerName: LPWSTR,
  pub rgpszHpkpValue: [LPSTR; 2usize],
}
#[test]
fn bindgen_test_layout__SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>())).cbSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>())).dwReserved
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>())).pwszServerName
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(pwszServerName)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA>())).rgpszHpkpValue
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(rgpszHpkpValue)
    )
  );
}
pub type SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA =
  _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA {
  pub cbSize: DWORD,
  pub dwReserved: DWORD,
  pub pwszServerName: PCWSTR,
}
#[test]
fn bindgen_test_layout__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>())).cbSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>())).dwReserved as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA>())).pwszServerName
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA),
      "::",
      stringify!(pwszServerName)
    )
  );
}
pub type SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS {
  pub cbSize: DWORD,
  pub lError: LONG,
  pub wszErrorText: [WCHAR; 512usize],
}
#[test]
fn bindgen_test_layout__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>(),
    1032usize,
    concat!(
      "Size of: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>())).cbSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>())).lError as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(lError)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS>())).wszErrorText
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS),
      "::",
      stringify!(wszErrorText)
    )
  );
}
pub type SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub type byte = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
  pub pad: [*mut ::std::os::raw::c_void; 2usize],
  pub userContext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(_bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).pad as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_bindgen_ty_1),
      "::",
      stringify!(pad)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_bindgen_ty_1>())).userContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_bindgen_ty_1),
      "::",
      stringify!(userContext)
    )
  );
}
pub type NDR_SCONTEXT = *mut _bindgen_ty_1;
pub type NDR_RUNDOWN =
  ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>;
pub type NDR_NOTIFY_ROUTINE = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCONTEXT_QUEUE {
  pub NumberOfObjects: ::std::os::raw::c_ulong,
  pub ArrayOfObjects: *mut NDR_SCONTEXT,
}
#[test]
fn bindgen_test_layout__SCONTEXT_QUEUE() {
  assert_eq!(
    ::std::mem::size_of::<_SCONTEXT_QUEUE>(),
    16usize,
    concat!("Size of: ", stringify!(_SCONTEXT_QUEUE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCONTEXT_QUEUE>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCONTEXT_QUEUE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCONTEXT_QUEUE>())).NumberOfObjects as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCONTEXT_QUEUE),
      "::",
      stringify!(NumberOfObjects)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCONTEXT_QUEUE>())).ArrayOfObjects as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCONTEXT_QUEUE),
      "::",
      stringify!(ArrayOfObjects)
    )
  );
}
pub type SCONTEXT_QUEUE = _SCONTEXT_QUEUE;
pub type error_status_t = ::std::os::raw::c_ulong;
pub type EXPR_EVAL = ::std::option::Option<unsafe extern "C" fn(arg1: *mut _MIDL_STUB_MESSAGE)>;
pub type PFORMAT_STRING = *const ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARRAY_INFO {
  pub Dimension: ::std::os::raw::c_long,
  pub BufferConformanceMark: *mut ::std::os::raw::c_ulong,
  pub BufferVarianceMark: *mut ::std::os::raw::c_ulong,
  pub MaxCountArray: *mut ::std::os::raw::c_ulong,
  pub OffsetArray: *mut ::std::os::raw::c_ulong,
  pub ActualCountArray: *mut ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ARRAY_INFO() {
  assert_eq!(
    ::std::mem::size_of::<ARRAY_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(ARRAY_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<ARRAY_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(ARRAY_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).Dimension as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(Dimension)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).BufferConformanceMark as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(BufferConformanceMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).BufferVarianceMark as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(BufferVarianceMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).MaxCountArray as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(MaxCountArray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).OffsetArray as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(OffsetArray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ARRAY_INFO>())).ActualCountArray as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(ARRAY_INFO),
      "::",
      stringify!(ActualCountArray)
    )
  );
}
pub type PARRAY_INFO = *mut ARRAY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_ASYNC_MESSAGE {
  _unused: [u8; 0],
}
pub type PNDR_ASYNC_MESSAGE = *mut _NDR_ASYNC_MESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CORRELATION_INFO {
  _unused: [u8; 0],
}
pub type PNDR_CORRELATION_INFO = *mut _NDR_CORRELATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NDR_ALLOC_ALL_NODES_CONTEXT {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NDR_POINTER_QUEUE_STATE {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_PROC_CONTEXT {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MIDL_STUB_MESSAGE {
  pub RpcMsg: PRPC_MESSAGE,
  pub Buffer: *mut ::std::os::raw::c_uchar,
  pub BufferStart: *mut ::std::os::raw::c_uchar,
  pub BufferEnd: *mut ::std::os::raw::c_uchar,
  pub BufferMark: *mut ::std::os::raw::c_uchar,
  pub BufferLength: ::std::os::raw::c_ulong,
  pub MemorySize: ::std::os::raw::c_ulong,
  pub Memory: *mut ::std::os::raw::c_uchar,
  pub IsClient: ::std::os::raw::c_uchar,
  pub Pad: ::std::os::raw::c_uchar,
  pub uFlags2: ::std::os::raw::c_ushort,
  pub ReuseBuffer: ::std::os::raw::c_int,
  pub pAllocAllNodesContext: *mut NDR_ALLOC_ALL_NODES_CONTEXT,
  pub pPointerQueueState: *mut NDR_POINTER_QUEUE_STATE,
  pub IgnoreEmbeddedPointers: ::std::os::raw::c_int,
  pub PointerBufferMark: *mut ::std::os::raw::c_uchar,
  pub CorrDespIncrement: ::std::os::raw::c_uchar,
  pub uFlags: ::std::os::raw::c_uchar,
  pub UniquePtrCount: ::std::os::raw::c_ushort,
  pub MaxCount: ULONG_PTR,
  pub Offset: ::std::os::raw::c_ulong,
  pub ActualCount: ::std::os::raw::c_ulong,
  pub pfnAllocate:
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>,
  pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
  pub StackTop: *mut ::std::os::raw::c_uchar,
  pub pPresentedType: *mut ::std::os::raw::c_uchar,
  pub pTransmitType: *mut ::std::os::raw::c_uchar,
  pub SavedHandle: handle_t,
  pub StubDesc: *const _MIDL_STUB_DESC,
  pub FullPtrXlatTables: *mut _FULL_PTR_XLAT_TABLES,
  pub FullPtrRefId: ::std::os::raw::c_ulong,
  pub PointerLength: ::std::os::raw::c_ulong,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
  pub dwDestContext: ::std::os::raw::c_ulong,
  pub pvDestContext: *mut ::std::os::raw::c_void,
  pub SavedContextHandles: *mut NDR_SCONTEXT,
  pub ParamNumber: ::std::os::raw::c_long,
  pub pRpcChannelBuffer: *mut IRpcChannelBuffer,
  pub pArrayInfo: PARRAY_INFO,
  pub SizePtrCountArray: *mut ::std::os::raw::c_ulong,
  pub SizePtrOffsetArray: *mut ::std::os::raw::c_ulong,
  pub SizePtrLengthArray: *mut ::std::os::raw::c_ulong,
  pub pArgQueue: *mut ::std::os::raw::c_void,
  pub dwStubPhase: ::std::os::raw::c_ulong,
  pub LowStackMark: *mut ::std::os::raw::c_void,
  pub pAsyncMsg: PNDR_ASYNC_MESSAGE,
  pub pCorrInfo: PNDR_CORRELATION_INFO,
  pub pCorrMemory: *mut ::std::os::raw::c_uchar,
  pub pMemoryList: *mut ::std::os::raw::c_void,
  pub pCSInfo: INT_PTR,
  pub ConformanceMark: *mut ::std::os::raw::c_uchar,
  pub VarianceMark: *mut ::std::os::raw::c_uchar,
  pub Unused: INT_PTR,
  pub pContext: *mut _NDR_PROC_CONTEXT,
  pub ContextHandleHash: *mut ::std::os::raw::c_void,
  pub pUserMarshalList: *mut ::std::os::raw::c_void,
  pub Reserved51_3: INT_PTR,
  pub Reserved51_4: INT_PTR,
  pub Reserved51_5: INT_PTR,
}
#[test]
fn bindgen_test_layout__MIDL_STUB_MESSAGE() {
  assert_eq!(
    ::std::mem::size_of::<_MIDL_STUB_MESSAGE>(),
    400usize,
    concat!("Size of: ", stringify!(_MIDL_STUB_MESSAGE))
  );
  assert_eq!(
    ::std::mem::align_of::<_MIDL_STUB_MESSAGE>(),
    8usize,
    concat!("Alignment of ", stringify!(_MIDL_STUB_MESSAGE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).RpcMsg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(RpcMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Buffer as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).BufferStart as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(BufferStart)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).BufferEnd as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(BufferEnd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).BufferMark as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(BufferMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).BufferLength as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(BufferLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).MemorySize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(MemorySize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Memory as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Memory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).IsClient as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(IsClient)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Pad as *const _ as usize },
    57usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Pad)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).uFlags2 as *const _ as usize },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(uFlags2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ReuseBuffer as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ReuseBuffer)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pAllocAllNodesContext as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pAllocAllNodesContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pPointerQueueState as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pPointerQueueState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).IgnoreEmbeddedPointers as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(IgnoreEmbeddedPointers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).PointerBufferMark as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(PointerBufferMark)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).CorrDespIncrement as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(CorrDespIncrement)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).uFlags as *const _ as usize },
    97usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(uFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).UniquePtrCount as *const _ as usize },
    98usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(UniquePtrCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).MaxCount as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(MaxCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Offset as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ActualCount as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ActualCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pfnAllocate as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pfnAllocate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pfnFree as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pfnFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).StackTop as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(StackTop)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pPresentedType as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pPresentedType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pTransmitType as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pTransmitType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SavedHandle as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SavedHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).StubDesc as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(StubDesc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).FullPtrXlatTables as *const _ as usize
    },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(FullPtrXlatTables)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).FullPtrRefId as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(FullPtrRefId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).PointerLength as *const _ as usize },
    188usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(PointerLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).dwDestContext as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(dwDestContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pvDestContext as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pvDestContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SavedContextHandles as *const _ as usize
    },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SavedContextHandles)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ParamNumber as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ParamNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pRpcChannelBuffer as *const _ as usize
    },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pRpcChannelBuffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pArrayInfo as *const _ as usize },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pArrayInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SizePtrCountArray as *const _ as usize
    },
    240usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SizePtrCountArray)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SizePtrOffsetArray as *const _ as usize
    },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SizePtrOffsetArray)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).SizePtrLengthArray as *const _ as usize
    },
    256usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(SizePtrLengthArray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pArgQueue as *const _ as usize },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pArgQueue)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).dwStubPhase as *const _ as usize },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(dwStubPhase)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).LowStackMark as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(LowStackMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pAsyncMsg as *const _ as usize },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pAsyncMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pCorrInfo as *const _ as usize },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pCorrInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pCorrMemory as *const _ as usize },
    304usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pCorrMemory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pMemoryList as *const _ as usize },
    312usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pMemoryList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pCSInfo as *const _ as usize },
    320usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pCSInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ConformanceMark as *const _ as usize },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ConformanceMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).VarianceMark as *const _ as usize },
    336usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(VarianceMark)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Unused as *const _ as usize },
    344usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Unused)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pContext as *const _ as usize },
    352usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).ContextHandleHash as *const _ as usize
    },
    360usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(ContextHandleHash)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).pUserMarshalList as *const _ as usize },
    368usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(pUserMarshalList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Reserved51_3 as *const _ as usize },
    376usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Reserved51_3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Reserved51_4 as *const _ as usize },
    384usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Reserved51_4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_MESSAGE>())).Reserved51_5 as *const _ as usize },
    392usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_MESSAGE),
      "::",
      stringify!(Reserved51_5)
    )
  );
}
impl _MIDL_STUB_MESSAGE {
  #[inline]
  pub fn fInDontFree(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fInDontFree(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fDontCallFreeInst(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fDontCallFreeInst(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fUnused1(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fUnused1(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasReturn(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fHasReturn(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(3usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasExtensions(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fHasExtensions(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(4usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasNewCorrDesc(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fHasNewCorrDesc(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(5usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fIsIn(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fIsIn(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(6usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fIsOut(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fIsOut(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(7usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fIsOicf(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fIsOicf(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(8usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fBufferValid(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fBufferValid(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(9usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fHasMemoryValidateCallback(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fHasMemoryValidateCallback(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(10usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fInFree(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fInFree(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(11usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fNeedMCCP(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_fNeedMCCP(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(12usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn fUnused2(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
  }
  #[inline]
  pub fn set_fUnused2(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(13usize, 3u8, val as u64)
    }
  }
  #[inline]
  pub fn fUnused3(&self) -> ::std::os::raw::c_int {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
  }
  #[inline]
  pub fn set_fUnused3(&mut self, val: ::std::os::raw::c_int) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(16usize, 16u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    fInDontFree: ::std::os::raw::c_int,
    fDontCallFreeInst: ::std::os::raw::c_int,
    fUnused1: ::std::os::raw::c_int,
    fHasReturn: ::std::os::raw::c_int,
    fHasExtensions: ::std::os::raw::c_int,
    fHasNewCorrDesc: ::std::os::raw::c_int,
    fIsIn: ::std::os::raw::c_int,
    fIsOut: ::std::os::raw::c_int,
    fIsOicf: ::std::os::raw::c_int,
    fBufferValid: ::std::os::raw::c_int,
    fHasMemoryValidateCallback: ::std::os::raw::c_int,
    fInFree: ::std::os::raw::c_int,
    fNeedMCCP: ::std::os::raw::c_int,
    fUnused2: ::std::os::raw::c_int,
    fUnused3: ::std::os::raw::c_int,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let fInDontFree: u32 = unsafe { ::std::mem::transmute(fInDontFree) };
      fInDontFree as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let fDontCallFreeInst: u32 = unsafe { ::std::mem::transmute(fDontCallFreeInst) };
      fDontCallFreeInst as u64
    });
    __bindgen_bitfield_unit.set(2usize, 1u8, {
      let fUnused1: u32 = unsafe { ::std::mem::transmute(fUnused1) };
      fUnused1 as u64
    });
    __bindgen_bitfield_unit.set(3usize, 1u8, {
      let fHasReturn: u32 = unsafe { ::std::mem::transmute(fHasReturn) };
      fHasReturn as u64
    });
    __bindgen_bitfield_unit.set(4usize, 1u8, {
      let fHasExtensions: u32 = unsafe { ::std::mem::transmute(fHasExtensions) };
      fHasExtensions as u64
    });
    __bindgen_bitfield_unit.set(5usize, 1u8, {
      let fHasNewCorrDesc: u32 = unsafe { ::std::mem::transmute(fHasNewCorrDesc) };
      fHasNewCorrDesc as u64
    });
    __bindgen_bitfield_unit.set(6usize, 1u8, {
      let fIsIn: u32 = unsafe { ::std::mem::transmute(fIsIn) };
      fIsIn as u64
    });
    __bindgen_bitfield_unit.set(7usize, 1u8, {
      let fIsOut: u32 = unsafe { ::std::mem::transmute(fIsOut) };
      fIsOut as u64
    });
    __bindgen_bitfield_unit.set(8usize, 1u8, {
      let fIsOicf: u32 = unsafe { ::std::mem::transmute(fIsOicf) };
      fIsOicf as u64
    });
    __bindgen_bitfield_unit.set(9usize, 1u8, {
      let fBufferValid: u32 = unsafe { ::std::mem::transmute(fBufferValid) };
      fBufferValid as u64
    });
    __bindgen_bitfield_unit.set(10usize, 1u8, {
      let fHasMemoryValidateCallback: u32 =
        unsafe { ::std::mem::transmute(fHasMemoryValidateCallback) };
      fHasMemoryValidateCallback as u64
    });
    __bindgen_bitfield_unit.set(11usize, 1u8, {
      let fInFree: u32 = unsafe { ::std::mem::transmute(fInFree) };
      fInFree as u64
    });
    __bindgen_bitfield_unit.set(12usize, 1u8, {
      let fNeedMCCP: u32 = unsafe { ::std::mem::transmute(fNeedMCCP) };
      fNeedMCCP as u64
    });
    __bindgen_bitfield_unit.set(13usize, 3u8, {
      let fUnused2: u32 = unsafe { ::std::mem::transmute(fUnused2) };
      fUnused2 as u64
    });
    __bindgen_bitfield_unit.set(16usize, 16u8, {
      let fUnused3: u32 = unsafe { ::std::mem::transmute(fUnused3) };
      fUnused3 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type PMIDL_STUB_MESSAGE = *mut _MIDL_STUB_MESSAGE;
pub type GENERIC_BINDING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type GENERIC_UNBIND_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_uchar),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_BINDING_ROUTINE_PAIR {
  pub pfnBind: GENERIC_BINDING_ROUTINE,
  pub pfnUnbind: GENERIC_UNBIND_ROUTINE,
}
#[test]
fn bindgen_test_layout__GENERIC_BINDING_ROUTINE_PAIR() {
  assert_eq!(
    ::std::mem::size_of::<_GENERIC_BINDING_ROUTINE_PAIR>(),
    16usize,
    concat!("Size of: ", stringify!(_GENERIC_BINDING_ROUTINE_PAIR))
  );
  assert_eq!(
    ::std::mem::align_of::<_GENERIC_BINDING_ROUTINE_PAIR>(),
    8usize,
    concat!("Alignment of ", stringify!(_GENERIC_BINDING_ROUTINE_PAIR))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_GENERIC_BINDING_ROUTINE_PAIR>())).pfnBind as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_BINDING_ROUTINE_PAIR),
      "::",
      stringify!(pfnBind)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_GENERIC_BINDING_ROUTINE_PAIR>())).pfnUnbind as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_GENERIC_BINDING_ROUTINE_PAIR),
      "::",
      stringify!(pfnUnbind)
    )
  );
}
pub type GENERIC_BINDING_ROUTINE_PAIR = _GENERIC_BINDING_ROUTINE_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __GENERIC_BINDING_INFO {
  pub pObj: *mut ::std::os::raw::c_void,
  pub Size: ::std::os::raw::c_uint,
  pub pfnBind: GENERIC_BINDING_ROUTINE,
  pub pfnUnbind: GENERIC_UNBIND_ROUTINE,
}
#[test]
fn bindgen_test_layout___GENERIC_BINDING_INFO() {
  assert_eq!(
    ::std::mem::size_of::<__GENERIC_BINDING_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(__GENERIC_BINDING_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<__GENERIC_BINDING_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(__GENERIC_BINDING_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__GENERIC_BINDING_INFO>())).pObj as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__GENERIC_BINDING_INFO),
      "::",
      stringify!(pObj)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__GENERIC_BINDING_INFO>())).Size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__GENERIC_BINDING_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__GENERIC_BINDING_INFO>())).pfnBind as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__GENERIC_BINDING_INFO),
      "::",
      stringify!(pfnBind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__GENERIC_BINDING_INFO>())).pfnUnbind as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__GENERIC_BINDING_INFO),
      "::",
      stringify!(pfnUnbind)
    )
  );
}
pub type PGENERIC_BINDING_INFO = *mut __GENERIC_BINDING_INFO;
pub type XMIT_HELPER_ROUTINE =
  ::std::option::Option<unsafe extern "C" fn(arg1: PMIDL_STUB_MESSAGE)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XMIT_ROUTINE_QUINTUPLE {
  pub pfnTranslateToXmit: XMIT_HELPER_ROUTINE,
  pub pfnTranslateFromXmit: XMIT_HELPER_ROUTINE,
  pub pfnFreeXmit: XMIT_HELPER_ROUTINE,
  pub pfnFreeInst: XMIT_HELPER_ROUTINE,
}
#[test]
fn bindgen_test_layout__XMIT_ROUTINE_QUINTUPLE() {
  assert_eq!(
    ::std::mem::size_of::<_XMIT_ROUTINE_QUINTUPLE>(),
    32usize,
    concat!("Size of: ", stringify!(_XMIT_ROUTINE_QUINTUPLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_XMIT_ROUTINE_QUINTUPLE>(),
    8usize,
    concat!("Alignment of ", stringify!(_XMIT_ROUTINE_QUINTUPLE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_XMIT_ROUTINE_QUINTUPLE>())).pfnTranslateToXmit as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_XMIT_ROUTINE_QUINTUPLE),
      "::",
      stringify!(pfnTranslateToXmit)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_XMIT_ROUTINE_QUINTUPLE>())).pfnTranslateFromXmit as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_XMIT_ROUTINE_QUINTUPLE),
      "::",
      stringify!(pfnTranslateFromXmit)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_XMIT_ROUTINE_QUINTUPLE>())).pfnFreeXmit as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_XMIT_ROUTINE_QUINTUPLE),
      "::",
      stringify!(pfnFreeXmit)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_XMIT_ROUTINE_QUINTUPLE>())).pfnFreeInst as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_XMIT_ROUTINE_QUINTUPLE),
      "::",
      stringify!(pfnFreeInst)
    )
  );
}
pub type XMIT_ROUTINE_QUINTUPLE = _XMIT_ROUTINE_QUINTUPLE;
pub type USER_MARSHAL_SIZING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_ulong,
>;
pub type USER_MARSHAL_MARSHALLING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_uchar,
>;
pub type USER_MARSHAL_UNMARSHALLING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_uchar,
>;
pub type USER_MARSHAL_FREEING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _USER_MARSHAL_ROUTINE_QUADRUPLE {
  pub pfnBufferSize: USER_MARSHAL_SIZING_ROUTINE,
  pub pfnMarshall: USER_MARSHAL_MARSHALLING_ROUTINE,
  pub pfnUnmarshall: USER_MARSHAL_UNMARSHALLING_ROUTINE,
  pub pfnFree: USER_MARSHAL_FREEING_ROUTINE,
}
#[test]
fn bindgen_test_layout__USER_MARSHAL_ROUTINE_QUADRUPLE() {
  assert_eq!(
    ::std::mem::size_of::<_USER_MARSHAL_ROUTINE_QUADRUPLE>(),
    32usize,
    concat!("Size of: ", stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_USER_MARSHAL_ROUTINE_QUADRUPLE>(),
    8usize,
    concat!("Alignment of ", stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_USER_MARSHAL_ROUTINE_QUADRUPLE>())).pfnBufferSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE),
      "::",
      stringify!(pfnBufferSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_USER_MARSHAL_ROUTINE_QUADRUPLE>())).pfnMarshall as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE),
      "::",
      stringify!(pfnMarshall)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_USER_MARSHAL_ROUTINE_QUADRUPLE>())).pfnUnmarshall as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE),
      "::",
      stringify!(pfnUnmarshall)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_USER_MARSHAL_ROUTINE_QUADRUPLE>())).pfnFree as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_USER_MARSHAL_ROUTINE_QUADRUPLE),
      "::",
      stringify!(pfnFree)
    )
  );
}
pub type USER_MARSHAL_ROUTINE_QUADRUPLE = _USER_MARSHAL_ROUTINE_QUADRUPLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MALLOC_FREE_STRUCT {
  pub pfnAllocate:
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>,
  pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout__MALLOC_FREE_STRUCT() {
  assert_eq!(
    ::std::mem::size_of::<_MALLOC_FREE_STRUCT>(),
    16usize,
    concat!("Size of: ", stringify!(_MALLOC_FREE_STRUCT))
  );
  assert_eq!(
    ::std::mem::align_of::<_MALLOC_FREE_STRUCT>(),
    8usize,
    concat!("Alignment of ", stringify!(_MALLOC_FREE_STRUCT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MALLOC_FREE_STRUCT>())).pfnAllocate as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MALLOC_FREE_STRUCT),
      "::",
      stringify!(pfnAllocate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MALLOC_FREE_STRUCT>())).pfnFree as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MALLOC_FREE_STRUCT),
      "::",
      stringify!(pfnFree)
    )
  );
}
pub type MALLOC_FREE_STRUCT = _MALLOC_FREE_STRUCT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMM_FAULT_OFFSETS {
  pub CommOffset: ::std::os::raw::c_short,
  pub FaultOffset: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout__COMM_FAULT_OFFSETS() {
  assert_eq!(
    ::std::mem::size_of::<_COMM_FAULT_OFFSETS>(),
    4usize,
    concat!("Size of: ", stringify!(_COMM_FAULT_OFFSETS))
  );
  assert_eq!(
    ::std::mem::align_of::<_COMM_FAULT_OFFSETS>(),
    2usize,
    concat!("Alignment of ", stringify!(_COMM_FAULT_OFFSETS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_COMM_FAULT_OFFSETS>())).CommOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMM_FAULT_OFFSETS),
      "::",
      stringify!(CommOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_COMM_FAULT_OFFSETS>())).FaultOffset as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_COMM_FAULT_OFFSETS),
      "::",
      stringify!(FaultOffset)
    )
  );
}
pub type COMM_FAULT_OFFSETS = _COMM_FAULT_OFFSETS;
pub const _IDL_CS_CONVERT_IDL_CS_NO_CONVERT: _IDL_CS_CONVERT = 0;
pub const _IDL_CS_CONVERT_IDL_CS_IN_PLACE_CONVERT: _IDL_CS_CONVERT = 1;
pub const _IDL_CS_CONVERT_IDL_CS_NEW_BUFFER_CONVERT: _IDL_CS_CONVERT = 2;
pub type _IDL_CS_CONVERT = ::std::os::raw::c_int;
pub use self::_IDL_CS_CONVERT as IDL_CS_CONVERT;
pub type CS_TYPE_NET_SIZE_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    ulNetworkCodeSet: ::std::os::raw::c_ulong,
    ulLocalBufferSize: ::std::os::raw::c_ulong,
    conversionType: *mut IDL_CS_CONVERT,
    pulNetworkBufferSize: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
pub type CS_TYPE_LOCAL_SIZE_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    ulNetworkCodeSet: ::std::os::raw::c_ulong,
    ulNetworkBufferSize: ::std::os::raw::c_ulong,
    conversionType: *mut IDL_CS_CONVERT,
    pulLocalBufferSize: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
pub type CS_TYPE_TO_NETCS_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    ulNetworkCodeSet: ::std::os::raw::c_ulong,
    pLocalData: *mut ::std::os::raw::c_void,
    ulLocalDataLength: ::std::os::raw::c_ulong,
    pNetworkData: *mut byte,
    pulNetworkDataLength: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
pub type CS_TYPE_FROM_NETCS_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    ulNetworkCodeSet: ::std::os::raw::c_ulong,
    pNetworkData: *mut byte,
    ulNetworkDataLength: ::std::os::raw::c_ulong,
    ulLocalBufferSize: ::std::os::raw::c_ulong,
    pLocalData: *mut ::std::os::raw::c_void,
    pulLocalDataLength: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
pub type CS_TAG_GETTING_ROUTINE = ::std::option::Option<
  unsafe extern "C" fn(
    hBinding: RPC_BINDING_HANDLE,
    fServerSide: ::std::os::raw::c_int,
    pulSendingTag: *mut ::std::os::raw::c_ulong,
    pulDesiredReceivingTag: *mut ::std::os::raw::c_ulong,
    pulReceivingTag: *mut ::std::os::raw::c_ulong,
    pStatus: *mut error_status_t,
  ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CS_SIZE_CONVERT_ROUTINES {
  pub pfnNetSize: CS_TYPE_NET_SIZE_ROUTINE,
  pub pfnToNetCs: CS_TYPE_TO_NETCS_ROUTINE,
  pub pfnLocalSize: CS_TYPE_LOCAL_SIZE_ROUTINE,
  pub pfnFromNetCs: CS_TYPE_FROM_NETCS_ROUTINE,
}
#[test]
fn bindgen_test_layout__NDR_CS_SIZE_CONVERT_ROUTINES() {
  assert_eq!(
    ::std::mem::size_of::<_NDR_CS_SIZE_CONVERT_ROUTINES>(),
    32usize,
    concat!("Size of: ", stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES))
  );
  assert_eq!(
    ::std::mem::align_of::<_NDR_CS_SIZE_CONVERT_ROUTINES>(),
    8usize,
    concat!("Alignment of ", stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_SIZE_CONVERT_ROUTINES>())).pfnNetSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES),
      "::",
      stringify!(pfnNetSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_SIZE_CONVERT_ROUTINES>())).pfnToNetCs as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES),
      "::",
      stringify!(pfnToNetCs)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_SIZE_CONVERT_ROUTINES>())).pfnLocalSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES),
      "::",
      stringify!(pfnLocalSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_SIZE_CONVERT_ROUTINES>())).pfnFromNetCs as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_SIZE_CONVERT_ROUTINES),
      "::",
      stringify!(pfnFromNetCs)
    )
  );
}
pub type NDR_CS_SIZE_CONVERT_ROUTINES = _NDR_CS_SIZE_CONVERT_ROUTINES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_CS_ROUTINES {
  pub pSizeConvertRoutines: *mut NDR_CS_SIZE_CONVERT_ROUTINES,
  pub pTagGettingRoutines: *mut CS_TAG_GETTING_ROUTINE,
}
#[test]
fn bindgen_test_layout__NDR_CS_ROUTINES() {
  assert_eq!(
    ::std::mem::size_of::<_NDR_CS_ROUTINES>(),
    16usize,
    concat!("Size of: ", stringify!(_NDR_CS_ROUTINES))
  );
  assert_eq!(
    ::std::mem::align_of::<_NDR_CS_ROUTINES>(),
    8usize,
    concat!("Alignment of ", stringify!(_NDR_CS_ROUTINES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_ROUTINES>())).pSizeConvertRoutines as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_ROUTINES),
      "::",
      stringify!(pSizeConvertRoutines)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_NDR_CS_ROUTINES>())).pTagGettingRoutines as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_CS_ROUTINES),
      "::",
      stringify!(pTagGettingRoutines)
    )
  );
}
pub type NDR_CS_ROUTINES = _NDR_CS_ROUTINES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NDR_EXPR_DESC {
  pub pOffset: *const ::std::os::raw::c_ushort,
  pub pFormatExpr: PFORMAT_STRING,
}
#[test]
fn bindgen_test_layout__NDR_EXPR_DESC() {
  assert_eq!(
    ::std::mem::size_of::<_NDR_EXPR_DESC>(),
    16usize,
    concat!("Size of: ", stringify!(_NDR_EXPR_DESC))
  );
  assert_eq!(
    ::std::mem::align_of::<_NDR_EXPR_DESC>(),
    8usize,
    concat!("Alignment of ", stringify!(_NDR_EXPR_DESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NDR_EXPR_DESC>())).pOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_EXPR_DESC),
      "::",
      stringify!(pOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_NDR_EXPR_DESC>())).pFormatExpr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_NDR_EXPR_DESC),
      "::",
      stringify!(pFormatExpr)
    )
  );
}
pub type NDR_EXPR_DESC = _NDR_EXPR_DESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MIDL_STUB_DESC {
  pub RpcInterfaceInformation: *mut ::std::os::raw::c_void,
  pub pfnAllocate:
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>,
  pub pfnFree: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
  pub IMPLICIT_HANDLE_INFO: _MIDL_STUB_DESC__bindgen_ty_1,
  pub apfnNdrRundownRoutines: *const NDR_RUNDOWN,
  pub aGenericBindingRoutinePairs: *const GENERIC_BINDING_ROUTINE_PAIR,
  pub apfnExprEval: *const EXPR_EVAL,
  pub aXmitQuintuple: *const XMIT_ROUTINE_QUINTUPLE,
  pub pFormatTypes: *const ::std::os::raw::c_uchar,
  pub fCheckBounds: ::std::os::raw::c_int,
  pub Version: ::std::os::raw::c_ulong,
  pub pMallocFreeStruct: *mut MALLOC_FREE_STRUCT,
  pub MIDLVersion: ::std::os::raw::c_long,
  pub CommFaultOffsets: *const COMM_FAULT_OFFSETS,
  pub aUserMarshalQuadruple: *const USER_MARSHAL_ROUTINE_QUADRUPLE,
  pub NotifyRoutineTable: *const NDR_NOTIFY_ROUTINE,
  pub mFlags: ULONG_PTR,
  pub CsRoutineTables: *const NDR_CS_ROUTINES,
  pub ProxyServerInfo: *mut ::std::os::raw::c_void,
  pub pExprInfo: *const NDR_EXPR_DESC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MIDL_STUB_DESC__bindgen_ty_1 {
  pub pAutoHandle: *mut handle_t,
  pub pPrimitiveHandle: *mut handle_t,
  pub pGenericBindingInfo: PGENERIC_BINDING_INFO,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__MIDL_STUB_DESC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_MIDL_STUB_DESC__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_MIDL_STUB_DESC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_MIDL_STUB_DESC__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_MIDL_STUB_DESC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC__bindgen_ty_1>())).pAutoHandle as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC__bindgen_ty_1),
      "::",
      stringify!(pAutoHandle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC__bindgen_ty_1>())).pPrimitiveHandle as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC__bindgen_ty_1),
      "::",
      stringify!(pPrimitiveHandle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC__bindgen_ty_1>())).pGenericBindingInfo as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC__bindgen_ty_1),
      "::",
      stringify!(pGenericBindingInfo)
    )
  );
}
#[test]
fn bindgen_test_layout__MIDL_STUB_DESC() {
  assert_eq!(
    ::std::mem::size_of::<_MIDL_STUB_DESC>(),
    152usize,
    concat!("Size of: ", stringify!(_MIDL_STUB_DESC))
  );
  assert_eq!(
    ::std::mem::align_of::<_MIDL_STUB_DESC>(),
    8usize,
    concat!("Alignment of ", stringify!(_MIDL_STUB_DESC))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).RpcInterfaceInformation as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(RpcInterfaceInformation)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pfnAllocate as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pfnAllocate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pfnFree as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pfnFree)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).IMPLICIT_HANDLE_INFO as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(IMPLICIT_HANDLE_INFO)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).apfnNdrRundownRoutines as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(apfnNdrRundownRoutines)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).aGenericBindingRoutinePairs as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(aGenericBindingRoutinePairs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).apfnExprEval as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(apfnExprEval)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).aXmitQuintuple as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(aXmitQuintuple)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pFormatTypes as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pFormatTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).fCheckBounds as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(fCheckBounds)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).Version as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pMallocFreeStruct as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pMallocFreeStruct)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).MIDLVersion as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(MIDLVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).CommFaultOffsets as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(CommFaultOffsets)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).aUserMarshalQuadruple as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(aUserMarshalQuadruple)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).NotifyRoutineTable as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(NotifyRoutineTable)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).mFlags as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(mFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).CsRoutineTables as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(CsRoutineTables)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).ProxyServerInfo as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(ProxyServerInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_MIDL_STUB_DESC>())).pExprInfo as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_MIDL_STUB_DESC),
      "::",
      stringify!(pExprInfo)
    )
  );
}
pub type STUB_THUNK = ::std::option::Option<unsafe extern "C" fn(arg1: PMIDL_STUB_MESSAGE)>;
pub type SERVER_ROUTINE = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_long>;
pub const XLAT_SIDE_XLAT_SERVER: XLAT_SIDE = 1;
pub const XLAT_SIDE_XLAT_CLIENT: XLAT_SIDE = 2;
pub type XLAT_SIDE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FULL_PTR_XLAT_TABLES {
  pub RefIdToPointer: *mut ::std::os::raw::c_void,
  pub PointerToRefId: *mut ::std::os::raw::c_void,
  pub NextRefId: ::std::os::raw::c_ulong,
  pub XlatSide: XLAT_SIDE,
}
#[test]
fn bindgen_test_layout__FULL_PTR_XLAT_TABLES() {
  assert_eq!(
    ::std::mem::size_of::<_FULL_PTR_XLAT_TABLES>(),
    24usize,
    concat!("Size of: ", stringify!(_FULL_PTR_XLAT_TABLES))
  );
  assert_eq!(
    ::std::mem::align_of::<_FULL_PTR_XLAT_TABLES>(),
    8usize,
    concat!("Alignment of ", stringify!(_FULL_PTR_XLAT_TABLES))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_FULL_PTR_XLAT_TABLES>())).RefIdToPointer as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FULL_PTR_XLAT_TABLES),
      "::",
      stringify!(RefIdToPointer)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_FULL_PTR_XLAT_TABLES>())).PointerToRefId as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FULL_PTR_XLAT_TABLES),
      "::",
      stringify!(PointerToRefId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FULL_PTR_XLAT_TABLES>())).NextRefId as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_FULL_PTR_XLAT_TABLES),
      "::",
      stringify!(NextRefId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FULL_PTR_XLAT_TABLES>())).XlatSide as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_FULL_PTR_XLAT_TABLES),
      "::",
      stringify!(XlatSide)
    )
  );
}
pub const STUB_PHASE_STUB_UNMARSHAL: STUB_PHASE = 0;
pub const STUB_PHASE_STUB_CALL_SERVER: STUB_PHASE = 1;
pub const STUB_PHASE_STUB_MARSHAL: STUB_PHASE = 2;
pub const STUB_PHASE_STUB_CALL_SERVER_NO_HRESULT: STUB_PHASE = 3;
pub type STUB_PHASE = ::std::os::raw::c_int;
pub type OLECHAR = WCHAR;
pub type LPOLESTR = *mut OLECHAR;
pub type LPCOLESTR = *const OLECHAR;
pub type DOUBLE = f64;
pub type SCODE = LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLAGGED_WORD_BLOB {
  pub fFlags: ULONG,
  pub clSize: ULONG,
  pub asData: [::std::os::raw::c_ushort; 1usize],
}
#[test]
fn bindgen_test_layout__FLAGGED_WORD_BLOB() {
  assert_eq!(
    ::std::mem::size_of::<_FLAGGED_WORD_BLOB>(),
    12usize,
    concat!("Size of: ", stringify!(_FLAGGED_WORD_BLOB))
  );
  assert_eq!(
    ::std::mem::align_of::<_FLAGGED_WORD_BLOB>(),
    4usize,
    concat!("Alignment of ", stringify!(_FLAGGED_WORD_BLOB))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FLAGGED_WORD_BLOB>())).fFlags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_FLAGGED_WORD_BLOB),
      "::",
      stringify!(fFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FLAGGED_WORD_BLOB>())).clSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_FLAGGED_WORD_BLOB),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_FLAGGED_WORD_BLOB>())).asData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_FLAGGED_WORD_BLOB),
      "::",
      stringify!(asData)
    )
  );
}
pub type FLAGGED_WORD_BLOB = _FLAGGED_WORD_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BYTE_SIZEDARR {
  pub clSize: ULONG,
  pub pData: *mut byte,
}
#[test]
fn bindgen_test_layout__BYTE_SIZEDARR() {
  assert_eq!(
    ::std::mem::size_of::<_BYTE_SIZEDARR>(),
    16usize,
    concat!("Size of: ", stringify!(_BYTE_SIZEDARR))
  );
  assert_eq!(
    ::std::mem::align_of::<_BYTE_SIZEDARR>(),
    8usize,
    concat!("Alignment of ", stringify!(_BYTE_SIZEDARR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_BYTE_SIZEDARR>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_BYTE_SIZEDARR),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_BYTE_SIZEDARR>())).pData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_BYTE_SIZEDARR),
      "::",
      stringify!(pData)
    )
  );
}
pub type BYTE_SIZEDARR = _BYTE_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHORT_SIZEDARR {
  pub clSize: ULONG,
  pub pData: *mut ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__SHORT_SIZEDARR() {
  assert_eq!(
    ::std::mem::size_of::<_SHORT_SIZEDARR>(),
    16usize,
    concat!("Size of: ", stringify!(_SHORT_SIZEDARR))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHORT_SIZEDARR>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHORT_SIZEDARR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHORT_SIZEDARR>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHORT_SIZEDARR),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHORT_SIZEDARR>())).pData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHORT_SIZEDARR),
      "::",
      stringify!(pData)
    )
  );
}
pub type WORD_SIZEDARR = _SHORT_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONG_SIZEDARR {
  pub clSize: ULONG,
  pub pData: *mut ULONG,
}
#[test]
fn bindgen_test_layout__LONG_SIZEDARR() {
  assert_eq!(
    ::std::mem::size_of::<_LONG_SIZEDARR>(),
    16usize,
    concat!("Size of: ", stringify!(_LONG_SIZEDARR))
  );
  assert_eq!(
    ::std::mem::align_of::<_LONG_SIZEDARR>(),
    8usize,
    concat!("Alignment of ", stringify!(_LONG_SIZEDARR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LONG_SIZEDARR>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LONG_SIZEDARR),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_LONG_SIZEDARR>())).pData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_LONG_SIZEDARR),
      "::",
      stringify!(pData)
    )
  );
}
pub type DWORD_SIZEDARR = _LONG_SIZEDARR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HYPER_SIZEDARR {
  pub clSize: ULONG,
  pub pData: *mut ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__HYPER_SIZEDARR() {
  assert_eq!(
    ::std::mem::size_of::<_HYPER_SIZEDARR>(),
    16usize,
    concat!("Size of: ", stringify!(_HYPER_SIZEDARR))
  );
  assert_eq!(
    ::std::mem::align_of::<_HYPER_SIZEDARR>(),
    8usize,
    concat!("Alignment of ", stringify!(_HYPER_SIZEDARR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_HYPER_SIZEDARR>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_HYPER_SIZEDARR),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_HYPER_SIZEDARR>())).pData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_HYPER_SIZEDARR),
      "::",
      stringify!(pData)
    )
  );
}
pub type HYPER_SIZEDARR = _HYPER_SIZEDARR;
pub const tagSTGC_STGC_DEFAULT: tagSTGC = 0;
pub const tagSTGC_STGC_OVERWRITE: tagSTGC = 1;
pub const tagSTGC_STGC_ONLYIFCURRENT: tagSTGC = 2;
pub const tagSTGC_STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE: tagSTGC = 4;
pub const tagSTGC_STGC_CONSOLIDATE: tagSTGC = 8;
pub type tagSTGC = ::std::os::raw::c_int;
pub use self::tagSTGC as STGC;
pub const tagSTGMOVE_STGMOVE_MOVE: tagSTGMOVE = 0;
pub const tagSTGMOVE_STGMOVE_COPY: tagSTGMOVE = 1;
pub const tagSTGMOVE_STGMOVE_SHALLOWCOPY: tagSTGMOVE = 2;
pub type tagSTGMOVE = ::std::os::raw::c_int;
pub use self::tagSTGMOVE as STGMOVE;
pub const tagSTATFLAG_STATFLAG_DEFAULT: tagSTATFLAG = 0;
pub const tagSTATFLAG_STATFLAG_NONAME: tagSTATFLAG = 1;
pub const tagSTATFLAG_STATFLAG_NOOPEN: tagSTATFLAG = 2;
pub type tagSTATFLAG = ::std::os::raw::c_int;
pub use self::tagSTATFLAG as STATFLAG;
pub type CLIPFORMAT = WORD;
pub type HMETAFILEPICT = *mut ::std::os::raw::c_void;
pub type DATE = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagCY {
  pub __bindgen_anon_1: tagCY__bindgen_ty_1,
  pub int64: LONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCY__bindgen_ty_1 {
  pub Lo: ULONG,
  pub Hi: LONG,
}
#[test]
fn bindgen_test_layout_tagCY__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagCY__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagCY__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagCY__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(tagCY__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagCY__bindgen_ty_1>())).Lo as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCY__bindgen_ty_1),
      "::",
      stringify!(Lo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagCY__bindgen_ty_1>())).Hi as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCY__bindgen_ty_1),
      "::",
      stringify!(Hi)
    )
  );
}
#[test]
fn bindgen_test_layout_tagCY() {
  assert_eq!(
    ::std::mem::size_of::<tagCY>(),
    8usize,
    concat!("Size of: ", stringify!(tagCY))
  );
  assert_eq!(
    ::std::mem::align_of::<tagCY>(),
    8usize,
    concat!("Alignment of ", stringify!(tagCY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagCY>())).int64 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagCY),
      "::",
      stringify!(int64)
    )
  );
}
pub type CY = tagCY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagDEC {
  pub wReserved: USHORT,
  pub __bindgen_anon_1: tagDEC__bindgen_ty_1,
  pub Hi32: ULONG,
  pub __bindgen_anon_2: tagDEC__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_1 {
  pub __bindgen_anon_1: tagDEC__bindgen_ty_1__bindgen_ty_1,
  pub signscale: USHORT,
  _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_1__bindgen_ty_1 {
  pub scale: BYTE,
  pub sign: BYTE,
}
#[test]
fn bindgen_test_layout_tagDEC__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!("Size of: ", stringify!(tagDEC__bindgen_ty_1__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(tagDEC__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDEC__bindgen_ty_1__bindgen_ty_1>())).scale as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(scale)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDEC__bindgen_ty_1__bindgen_ty_1>())).sign as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(sign)
    )
  );
}
#[test]
fn bindgen_test_layout_tagDEC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC__bindgen_ty_1>(),
    2usize,
    concat!("Size of: ", stringify!(tagDEC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC__bindgen_ty_1>(),
    2usize,
    concat!("Alignment of ", stringify!(tagDEC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDEC__bindgen_ty_1>())).signscale as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_1),
      "::",
      stringify!(signscale)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_2 {
  pub __bindgen_anon_1: tagDEC__bindgen_ty_2__bindgen_ty_1,
  pub Lo64: ULONGLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_2__bindgen_ty_1 {
  pub Lo32: ULONG,
  pub Mid32: ULONG,
}
#[test]
fn bindgen_test_layout_tagDEC__bindgen_ty_2__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC__bindgen_ty_2__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagDEC__bindgen_ty_2__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC__bindgen_ty_2__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(tagDEC__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDEC__bindgen_ty_2__bindgen_ty_1>())).Lo32 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Lo32)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDEC__bindgen_ty_2__bindgen_ty_1>())).Mid32 as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(Mid32)
    )
  );
}
#[test]
fn bindgen_test_layout_tagDEC__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(tagDEC__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC__bindgen_ty_2>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDEC__bindgen_ty_2))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDEC__bindgen_ty_2>())).Lo64 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC__bindgen_ty_2),
      "::",
      stringify!(Lo64)
    )
  );
}
#[test]
fn bindgen_test_layout_tagDEC() {
  assert_eq!(
    ::std::mem::size_of::<tagDEC>(),
    16usize,
    concat!("Size of: ", stringify!(tagDEC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDEC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDEC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDEC>())).wReserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC),
      "::",
      stringify!(wReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDEC>())).Hi32 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDEC),
      "::",
      stringify!(Hi32)
    )
  );
}
pub type DECIMAL = tagDEC;
pub type wireBSTR = *mut FLAGGED_WORD_BLOB;
pub type BSTR = *mut OLECHAR;
pub type VARIANT_BOOL = ::std::os::raw::c_short;
pub type VARTYPE = ::std::os::raw::c_ushort;
pub type PROPID = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HOTPLUG_INFO {
  pub Size: DWORD,
  pub MediaRemovable: BOOLEAN,
  pub MediaHotplug: BOOLEAN,
  pub DeviceHotplug: BOOLEAN,
  pub WriteCacheEnableOverride: BOOLEAN,
}
#[test]
fn bindgen_test_layout__STORAGE_HOTPLUG_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HOTPLUG_INFO>(),
    8usize,
    concat!("Size of: ", stringify!(_STORAGE_HOTPLUG_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HOTPLUG_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HOTPLUG_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).MediaRemovable as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(MediaRemovable)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).MediaHotplug as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(MediaHotplug)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).DeviceHotplug as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(DeviceHotplug)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HOTPLUG_INFO>())).WriteCacheEnableOverride as *const _
        as usize
    },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HOTPLUG_INFO),
      "::",
      stringify!(WriteCacheEnableOverride)
    )
  );
}
pub type STORAGE_HOTPLUG_INFO = _STORAGE_HOTPLUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBER {
  pub DeviceType: DWORD,
  pub DeviceNumber: DWORD,
  pub PartitionNumber: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_NUMBER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_NUMBER>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_NUMBER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_NUMBER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_NUMBER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER>())).DeviceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER),
      "::",
      stringify!(DeviceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER>())).DeviceNumber as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER),
      "::",
      stringify!(DeviceNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER>())).PartitionNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER),
      "::",
      stringify!(PartitionNumber)
    )
  );
}
pub type STORAGE_DEVICE_NUMBER = _STORAGE_DEVICE_NUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBERS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfDevices: DWORD,
  pub Devices: [STORAGE_DEVICE_NUMBER; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_NUMBERS() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_NUMBERS>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_NUMBERS))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_NUMBERS>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_NUMBERS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBERS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBERS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBERS>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBERS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBERS>())).NumberOfDevices as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBERS),
      "::",
      stringify!(NumberOfDevices)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBERS>())).Devices as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBERS),
      "::",
      stringify!(Devices)
    )
  );
}
pub type STORAGE_DEVICE_NUMBERS = _STORAGE_DEVICE_NUMBERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMBER_EX {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub DeviceType: DWORD,
  pub DeviceNumber: DWORD,
  pub DeviceGuid: GUID,
  pub PartitionNumber: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_NUMBER_EX() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_NUMBER_EX>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_NUMBER_EX))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_NUMBER_EX>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_NUMBER_EX))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).DeviceType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(DeviceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).DeviceNumber as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(DeviceNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).DeviceGuid as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(DeviceGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMBER_EX>())).PartitionNumber as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMBER_EX),
      "::",
      stringify!(PartitionNumber)
    )
  );
}
pub type STORAGE_DEVICE_NUMBER_EX = _STORAGE_DEVICE_NUMBER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_BUS_RESET_REQUEST {
  pub PathId: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_BUS_RESET_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_BUS_RESET_REQUEST>(),
    1usize,
    concat!("Size of: ", stringify!(_STORAGE_BUS_RESET_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_BUS_RESET_REQUEST>(),
    1usize,
    concat!("Alignment of ", stringify!(_STORAGE_BUS_RESET_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_BUS_RESET_REQUEST>())).PathId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_BUS_RESET_REQUEST),
      "::",
      stringify!(PathId)
    )
  );
}
pub type STORAGE_BUS_RESET_REQUEST = _STORAGE_BUS_RESET_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STORAGE_BREAK_RESERVATION_REQUEST {
  pub Length: DWORD,
  pub _unused: BYTE,
  pub PathId: BYTE,
  pub TargetId: BYTE,
  pub Lun: BYTE,
}
#[test]
fn bindgen_test_layout_STORAGE_BREAK_RESERVATION_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<STORAGE_BREAK_RESERVATION_REQUEST>(),
    8usize,
    concat!("Size of: ", stringify!(STORAGE_BREAK_RESERVATION_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<STORAGE_BREAK_RESERVATION_REQUEST>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>())).Length as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>()))._unused as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(_unused)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>())).PathId as *const _ as usize
    },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(PathId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>())).TargetId as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(TargetId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STORAGE_BREAK_RESERVATION_REQUEST>())).Lun as *const _ as usize
    },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(STORAGE_BREAK_RESERVATION_REQUEST),
      "::",
      stringify!(Lun)
    )
  );
}
pub const _STORAGE_MEDIA_TYPE_DDS_4mm: _STORAGE_MEDIA_TYPE = 32;
pub const _STORAGE_MEDIA_TYPE_MiniQic: _STORAGE_MEDIA_TYPE = 33;
pub const _STORAGE_MEDIA_TYPE_Travan: _STORAGE_MEDIA_TYPE = 34;
pub const _STORAGE_MEDIA_TYPE_QIC: _STORAGE_MEDIA_TYPE = 35;
pub const _STORAGE_MEDIA_TYPE_MP_8mm: _STORAGE_MEDIA_TYPE = 36;
pub const _STORAGE_MEDIA_TYPE_AME_8mm: _STORAGE_MEDIA_TYPE = 37;
pub const _STORAGE_MEDIA_TYPE_AIT1_8mm: _STORAGE_MEDIA_TYPE = 38;
pub const _STORAGE_MEDIA_TYPE_DLT: _STORAGE_MEDIA_TYPE = 39;
pub const _STORAGE_MEDIA_TYPE_NCTP: _STORAGE_MEDIA_TYPE = 40;
pub const _STORAGE_MEDIA_TYPE_IBM_3480: _STORAGE_MEDIA_TYPE = 41;
pub const _STORAGE_MEDIA_TYPE_IBM_3490E: _STORAGE_MEDIA_TYPE = 42;
pub const _STORAGE_MEDIA_TYPE_IBM_Magstar_3590: _STORAGE_MEDIA_TYPE = 43;
pub const _STORAGE_MEDIA_TYPE_IBM_Magstar_MP: _STORAGE_MEDIA_TYPE = 44;
pub const _STORAGE_MEDIA_TYPE_STK_DATA_D3: _STORAGE_MEDIA_TYPE = 45;
pub const _STORAGE_MEDIA_TYPE_SONY_DTF: _STORAGE_MEDIA_TYPE = 46;
pub const _STORAGE_MEDIA_TYPE_DV_6mm: _STORAGE_MEDIA_TYPE = 47;
pub const _STORAGE_MEDIA_TYPE_DMI: _STORAGE_MEDIA_TYPE = 48;
pub const _STORAGE_MEDIA_TYPE_SONY_D2: _STORAGE_MEDIA_TYPE = 49;
pub const _STORAGE_MEDIA_TYPE_CLEANER_CARTRIDGE: _STORAGE_MEDIA_TYPE = 50;
pub const _STORAGE_MEDIA_TYPE_CD_ROM: _STORAGE_MEDIA_TYPE = 51;
pub const _STORAGE_MEDIA_TYPE_CD_R: _STORAGE_MEDIA_TYPE = 52;
pub const _STORAGE_MEDIA_TYPE_CD_RW: _STORAGE_MEDIA_TYPE = 53;
pub const _STORAGE_MEDIA_TYPE_DVD_ROM: _STORAGE_MEDIA_TYPE = 54;
pub const _STORAGE_MEDIA_TYPE_DVD_R: _STORAGE_MEDIA_TYPE = 55;
pub const _STORAGE_MEDIA_TYPE_DVD_RW: _STORAGE_MEDIA_TYPE = 56;
pub const _STORAGE_MEDIA_TYPE_MO_3_RW: _STORAGE_MEDIA_TYPE = 57;
pub const _STORAGE_MEDIA_TYPE_MO_5_WO: _STORAGE_MEDIA_TYPE = 58;
pub const _STORAGE_MEDIA_TYPE_MO_5_RW: _STORAGE_MEDIA_TYPE = 59;
pub const _STORAGE_MEDIA_TYPE_MO_5_LIMDOW: _STORAGE_MEDIA_TYPE = 60;
pub const _STORAGE_MEDIA_TYPE_PC_5_WO: _STORAGE_MEDIA_TYPE = 61;
pub const _STORAGE_MEDIA_TYPE_PC_5_RW: _STORAGE_MEDIA_TYPE = 62;
pub const _STORAGE_MEDIA_TYPE_PD_5_RW: _STORAGE_MEDIA_TYPE = 63;
pub const _STORAGE_MEDIA_TYPE_ABL_5_WO: _STORAGE_MEDIA_TYPE = 64;
pub const _STORAGE_MEDIA_TYPE_PINNACLE_APEX_5_RW: _STORAGE_MEDIA_TYPE = 65;
pub const _STORAGE_MEDIA_TYPE_SONY_12_WO: _STORAGE_MEDIA_TYPE = 66;
pub const _STORAGE_MEDIA_TYPE_PHILIPS_12_WO: _STORAGE_MEDIA_TYPE = 67;
pub const _STORAGE_MEDIA_TYPE_HITACHI_12_WO: _STORAGE_MEDIA_TYPE = 68;
pub const _STORAGE_MEDIA_TYPE_CYGNET_12_WO: _STORAGE_MEDIA_TYPE = 69;
pub const _STORAGE_MEDIA_TYPE_KODAK_14_WO: _STORAGE_MEDIA_TYPE = 70;
pub const _STORAGE_MEDIA_TYPE_MO_NFR_525: _STORAGE_MEDIA_TYPE = 71;
pub const _STORAGE_MEDIA_TYPE_NIKON_12_RW: _STORAGE_MEDIA_TYPE = 72;
pub const _STORAGE_MEDIA_TYPE_IOMEGA_ZIP: _STORAGE_MEDIA_TYPE = 73;
pub const _STORAGE_MEDIA_TYPE_IOMEGA_JAZ: _STORAGE_MEDIA_TYPE = 74;
pub const _STORAGE_MEDIA_TYPE_SYQUEST_EZ135: _STORAGE_MEDIA_TYPE = 75;
pub const _STORAGE_MEDIA_TYPE_SYQUEST_EZFLYER: _STORAGE_MEDIA_TYPE = 76;
pub const _STORAGE_MEDIA_TYPE_SYQUEST_SYJET: _STORAGE_MEDIA_TYPE = 77;
pub const _STORAGE_MEDIA_TYPE_AVATAR_F2: _STORAGE_MEDIA_TYPE = 78;
pub const _STORAGE_MEDIA_TYPE_MP2_8mm: _STORAGE_MEDIA_TYPE = 79;
pub const _STORAGE_MEDIA_TYPE_DST_S: _STORAGE_MEDIA_TYPE = 80;
pub const _STORAGE_MEDIA_TYPE_DST_M: _STORAGE_MEDIA_TYPE = 81;
pub const _STORAGE_MEDIA_TYPE_DST_L: _STORAGE_MEDIA_TYPE = 82;
pub const _STORAGE_MEDIA_TYPE_VXATape_1: _STORAGE_MEDIA_TYPE = 83;
pub const _STORAGE_MEDIA_TYPE_VXATape_2: _STORAGE_MEDIA_TYPE = 84;
pub const _STORAGE_MEDIA_TYPE_STK_9840: _STORAGE_MEDIA_TYPE = 85;
pub const _STORAGE_MEDIA_TYPE_LTO_Ultrium: _STORAGE_MEDIA_TYPE = 86;
pub const _STORAGE_MEDIA_TYPE_LTO_Accelis: _STORAGE_MEDIA_TYPE = 87;
pub const _STORAGE_MEDIA_TYPE_DVD_RAM: _STORAGE_MEDIA_TYPE = 88;
pub const _STORAGE_MEDIA_TYPE_AIT_8mm: _STORAGE_MEDIA_TYPE = 89;
pub const _STORAGE_MEDIA_TYPE_ADR_1: _STORAGE_MEDIA_TYPE = 90;
pub const _STORAGE_MEDIA_TYPE_ADR_2: _STORAGE_MEDIA_TYPE = 91;
pub const _STORAGE_MEDIA_TYPE_STK_9940: _STORAGE_MEDIA_TYPE = 92;
pub const _STORAGE_MEDIA_TYPE_SAIT: _STORAGE_MEDIA_TYPE = 93;
pub const _STORAGE_MEDIA_TYPE_VXATape: _STORAGE_MEDIA_TYPE = 94;
pub type _STORAGE_MEDIA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_MEDIA_TYPE as STORAGE_MEDIA_TYPE;
pub const _STORAGE_BUS_TYPE_BusTypeUnknown: _STORAGE_BUS_TYPE = 0;
pub const _STORAGE_BUS_TYPE_BusTypeScsi: _STORAGE_BUS_TYPE = 1;
pub const _STORAGE_BUS_TYPE_BusTypeAtapi: _STORAGE_BUS_TYPE = 2;
pub const _STORAGE_BUS_TYPE_BusTypeAta: _STORAGE_BUS_TYPE = 3;
pub const _STORAGE_BUS_TYPE_BusType1394: _STORAGE_BUS_TYPE = 4;
pub const _STORAGE_BUS_TYPE_BusTypeSsa: _STORAGE_BUS_TYPE = 5;
pub const _STORAGE_BUS_TYPE_BusTypeFibre: _STORAGE_BUS_TYPE = 6;
pub const _STORAGE_BUS_TYPE_BusTypeUsb: _STORAGE_BUS_TYPE = 7;
pub const _STORAGE_BUS_TYPE_BusTypeRAID: _STORAGE_BUS_TYPE = 8;
pub const _STORAGE_BUS_TYPE_BusTypeiScsi: _STORAGE_BUS_TYPE = 9;
pub const _STORAGE_BUS_TYPE_BusTypeSas: _STORAGE_BUS_TYPE = 10;
pub const _STORAGE_BUS_TYPE_BusTypeSata: _STORAGE_BUS_TYPE = 11;
pub const _STORAGE_BUS_TYPE_BusTypeSd: _STORAGE_BUS_TYPE = 12;
pub const _STORAGE_BUS_TYPE_BusTypeMmc: _STORAGE_BUS_TYPE = 13;
pub const _STORAGE_BUS_TYPE_BusTypeVirtual: _STORAGE_BUS_TYPE = 14;
pub const _STORAGE_BUS_TYPE_BusTypeFileBackedVirtual: _STORAGE_BUS_TYPE = 15;
pub const _STORAGE_BUS_TYPE_BusTypeSpaces: _STORAGE_BUS_TYPE = 16;
pub const _STORAGE_BUS_TYPE_BusTypeNvme: _STORAGE_BUS_TYPE = 17;
pub const _STORAGE_BUS_TYPE_BusTypeSCM: _STORAGE_BUS_TYPE = 18;
pub const _STORAGE_BUS_TYPE_BusTypeUfs: _STORAGE_BUS_TYPE = 19;
pub const _STORAGE_BUS_TYPE_BusTypeMax: _STORAGE_BUS_TYPE = 20;
pub const _STORAGE_BUS_TYPE_BusTypeMaxReserved: _STORAGE_BUS_TYPE = 127;
pub type _STORAGE_BUS_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_BUS_TYPE as STORAGE_BUS_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_PREDICT_FAILURE {
  pub PredictFailure: DWORD,
  pub VendorSpecific: [BYTE; 512usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PREDICT_FAILURE() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PREDICT_FAILURE>(),
    516usize,
    concat!("Size of: ", stringify!(_STORAGE_PREDICT_FAILURE))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PREDICT_FAILURE>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PREDICT_FAILURE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PREDICT_FAILURE>())).PredictFailure as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PREDICT_FAILURE),
      "::",
      stringify!(PredictFailure)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PREDICT_FAILURE>())).VendorSpecific as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PREDICT_FAILURE),
      "::",
      stringify!(VendorSpecific)
    )
  );
}
pub type STORAGE_PREDICT_FAILURE = _STORAGE_PREDICT_FAILURE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_FAILURE_PREDICTION_CONFIG {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Set: BOOLEAN,
  pub Enabled: BOOLEAN,
  pub Reserved: WORD,
}
#[test]
fn bindgen_test_layout__STORAGE_FAILURE_PREDICTION_CONFIG() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_FAILURE_PREDICTION_CONFIG>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_FAILURE_PREDICTION_CONFIG>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Set as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Set)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Enabled as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Enabled)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_FAILURE_PREDICTION_CONFIG>())).Reserved as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_FAILURE_PREDICTION_CONFIG),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_FAILURE_PREDICTION_CONFIG = _STORAGE_FAILURE_PREDICTION_CONFIG;
pub const _STORAGE_QUERY_TYPE_PropertyStandardQuery: _STORAGE_QUERY_TYPE = 0;
pub const _STORAGE_QUERY_TYPE_PropertyExistsQuery: _STORAGE_QUERY_TYPE = 1;
pub const _STORAGE_QUERY_TYPE_PropertyMaskQuery: _STORAGE_QUERY_TYPE = 2;
pub const _STORAGE_QUERY_TYPE_PropertyQueryMaxDefined: _STORAGE_QUERY_TYPE = 3;
pub type _STORAGE_QUERY_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_QUERY_TYPE as STORAGE_QUERY_TYPE;
pub const _STORAGE_SET_TYPE_PropertyStandardSet: _STORAGE_SET_TYPE = 0;
pub const _STORAGE_SET_TYPE_PropertyExistsSet: _STORAGE_SET_TYPE = 1;
pub const _STORAGE_SET_TYPE_PropertySetMaxDefined: _STORAGE_SET_TYPE = 2;
pub type _STORAGE_SET_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_SET_TYPE as STORAGE_SET_TYPE;
pub const _STORAGE_PROPERTY_ID_StorageDeviceProperty: _STORAGE_PROPERTY_ID = 0;
pub const _STORAGE_PROPERTY_ID_StorageAdapterProperty: _STORAGE_PROPERTY_ID = 1;
pub const _STORAGE_PROPERTY_ID_StorageDeviceIdProperty: _STORAGE_PROPERTY_ID = 2;
pub const _STORAGE_PROPERTY_ID_StorageDeviceUniqueIdProperty: _STORAGE_PROPERTY_ID = 3;
pub const _STORAGE_PROPERTY_ID_StorageDeviceWriteCacheProperty: _STORAGE_PROPERTY_ID = 4;
pub const _STORAGE_PROPERTY_ID_StorageMiniportProperty: _STORAGE_PROPERTY_ID = 5;
pub const _STORAGE_PROPERTY_ID_StorageAccessAlignmentProperty: _STORAGE_PROPERTY_ID = 6;
pub const _STORAGE_PROPERTY_ID_StorageDeviceSeekPenaltyProperty: _STORAGE_PROPERTY_ID = 7;
pub const _STORAGE_PROPERTY_ID_StorageDeviceTrimProperty: _STORAGE_PROPERTY_ID = 8;
pub const _STORAGE_PROPERTY_ID_StorageDeviceWriteAggregationProperty: _STORAGE_PROPERTY_ID = 9;
pub const _STORAGE_PROPERTY_ID_StorageDeviceDeviceTelemetryProperty: _STORAGE_PROPERTY_ID = 10;
pub const _STORAGE_PROPERTY_ID_StorageDeviceLBProvisioningProperty: _STORAGE_PROPERTY_ID = 11;
pub const _STORAGE_PROPERTY_ID_StorageDevicePowerProperty: _STORAGE_PROPERTY_ID = 12;
pub const _STORAGE_PROPERTY_ID_StorageDeviceCopyOffloadProperty: _STORAGE_PROPERTY_ID = 13;
pub const _STORAGE_PROPERTY_ID_StorageDeviceResiliencyProperty: _STORAGE_PROPERTY_ID = 14;
pub const _STORAGE_PROPERTY_ID_StorageDeviceMediumProductType: _STORAGE_PROPERTY_ID = 15;
pub const _STORAGE_PROPERTY_ID_StorageAdapterRpmbProperty: _STORAGE_PROPERTY_ID = 16;
pub const _STORAGE_PROPERTY_ID_StorageAdapterCryptoProperty: _STORAGE_PROPERTY_ID = 17;
pub const _STORAGE_PROPERTY_ID_StorageDeviceIoCapabilityProperty: _STORAGE_PROPERTY_ID = 48;
pub const _STORAGE_PROPERTY_ID_StorageAdapterProtocolSpecificProperty: _STORAGE_PROPERTY_ID = 49;
pub const _STORAGE_PROPERTY_ID_StorageDeviceProtocolSpecificProperty: _STORAGE_PROPERTY_ID = 50;
pub const _STORAGE_PROPERTY_ID_StorageAdapterTemperatureProperty: _STORAGE_PROPERTY_ID = 51;
pub const _STORAGE_PROPERTY_ID_StorageDeviceTemperatureProperty: _STORAGE_PROPERTY_ID = 52;
pub const _STORAGE_PROPERTY_ID_StorageAdapterPhysicalTopologyProperty: _STORAGE_PROPERTY_ID = 53;
pub const _STORAGE_PROPERTY_ID_StorageDevicePhysicalTopologyProperty: _STORAGE_PROPERTY_ID = 54;
pub const _STORAGE_PROPERTY_ID_StorageDeviceAttributesProperty: _STORAGE_PROPERTY_ID = 55;
pub const _STORAGE_PROPERTY_ID_StorageDeviceManagementStatus: _STORAGE_PROPERTY_ID = 56;
pub const _STORAGE_PROPERTY_ID_StorageAdapterSerialNumberProperty: _STORAGE_PROPERTY_ID = 57;
pub const _STORAGE_PROPERTY_ID_StorageDeviceLocationProperty: _STORAGE_PROPERTY_ID = 58;
pub const _STORAGE_PROPERTY_ID_StorageDeviceNumaProperty: _STORAGE_PROPERTY_ID = 59;
pub const _STORAGE_PROPERTY_ID_StorageDeviceZonedDeviceProperty: _STORAGE_PROPERTY_ID = 60;
pub const _STORAGE_PROPERTY_ID_StorageDeviceUnsafeShutdownCount: _STORAGE_PROPERTY_ID = 61;
pub const _STORAGE_PROPERTY_ID_StorageDeviceEnduranceProperty: _STORAGE_PROPERTY_ID = 62;
pub type _STORAGE_PROPERTY_ID = ::std::os::raw::c_int;
pub use self::_STORAGE_PROPERTY_ID as STORAGE_PROPERTY_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROPERTY_QUERY {
  pub PropertyId: STORAGE_PROPERTY_ID,
  pub QueryType: STORAGE_QUERY_TYPE,
  pub AdditionalParameters: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PROPERTY_QUERY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROPERTY_QUERY>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_PROPERTY_QUERY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROPERTY_QUERY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PROPERTY_QUERY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROPERTY_QUERY>())).PropertyId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_QUERY),
      "::",
      stringify!(PropertyId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROPERTY_QUERY>())).QueryType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_QUERY),
      "::",
      stringify!(QueryType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROPERTY_QUERY>())).AdditionalParameters as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_QUERY),
      "::",
      stringify!(AdditionalParameters)
    )
  );
}
pub type STORAGE_PROPERTY_QUERY = _STORAGE_PROPERTY_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROPERTY_SET {
  pub PropertyId: STORAGE_PROPERTY_ID,
  pub SetType: STORAGE_SET_TYPE,
  pub AdditionalParameters: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PROPERTY_SET() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROPERTY_SET>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_PROPERTY_SET))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROPERTY_SET>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PROPERTY_SET))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROPERTY_SET>())).PropertyId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_SET),
      "::",
      stringify!(PropertyId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROPERTY_SET>())).SetType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_SET),
      "::",
      stringify!(SetType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROPERTY_SET>())).AdditionalParameters as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROPERTY_SET),
      "::",
      stringify!(AdditionalParameters)
    )
  );
}
pub type STORAGE_PROPERTY_SET = _STORAGE_PROPERTY_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DESCRIPTOR_HEADER {
  pub Version: DWORD,
  pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DESCRIPTOR_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DESCRIPTOR_HEADER>(),
    8usize,
    concat!("Size of: ", stringify!(_STORAGE_DESCRIPTOR_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DESCRIPTOR_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DESCRIPTOR_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DESCRIPTOR_HEADER>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DESCRIPTOR_HEADER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DESCRIPTOR_HEADER>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DESCRIPTOR_HEADER),
      "::",
      stringify!(Size)
    )
  );
}
pub type STORAGE_DESCRIPTOR_HEADER = _STORAGE_DESCRIPTOR_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceType: BYTE,
  pub DeviceTypeModifier: BYTE,
  pub RemovableMedia: BOOLEAN,
  pub CommandQueueing: BOOLEAN,
  pub VendorIdOffset: DWORD,
  pub ProductIdOffset: DWORD,
  pub ProductRevisionOffset: DWORD,
  pub SerialNumberOffset: DWORD,
  pub BusType: STORAGE_BUS_TYPE,
  pub RawPropertiesLength: DWORD,
  pub RawDeviceProperties: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_DESCRIPTOR>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).DeviceType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(DeviceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).DeviceTypeModifier as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(DeviceTypeModifier)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).RemovableMedia as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(RemovableMedia)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).CommandQueueing as *const _ as usize
    },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(CommandQueueing)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).VendorIdOffset as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(VendorIdOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).ProductIdOffset as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ProductIdOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).ProductRevisionOffset as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ProductRevisionOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).SerialNumberOffset as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(SerialNumberOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).BusType as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(BusType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).RawPropertiesLength as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(RawPropertiesLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_DESCRIPTOR>())).RawDeviceProperties as *const _
        as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_DESCRIPTOR),
      "::",
      stringify!(RawDeviceProperties)
    )
  );
}
pub type STORAGE_DEVICE_DESCRIPTOR = _STORAGE_DEVICE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ADAPTER_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub MaximumTransferLength: DWORD,
  pub MaximumPhysicalPages: DWORD,
  pub AlignmentMask: DWORD,
  pub AdapterUsesPio: BOOLEAN,
  pub AdapterScansDown: BOOLEAN,
  pub CommandQueueing: BOOLEAN,
  pub AcceleratedTransfer: BOOLEAN,
  pub BusType: BYTE,
  pub BusMajorVersion: WORD,
  pub BusMinorVersion: WORD,
  pub SrbType: BYTE,
  pub AddressType: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_ADAPTER_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ADAPTER_DESCRIPTOR>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_ADAPTER_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ADAPTER_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_ADAPTER_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).MaximumTransferLength as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(MaximumTransferLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).MaximumPhysicalPages as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(MaximumPhysicalPages)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AlignmentMask as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AlignmentMask)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AdapterUsesPio as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AdapterUsesPio)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AdapterScansDown as *const _ as usize
    },
    21usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AdapterScansDown)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).CommandQueueing as *const _ as usize
    },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(CommandQueueing)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AcceleratedTransfer as *const _
        as usize
    },
    23usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AcceleratedTransfer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).BusType as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(BusType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).BusMajorVersion as *const _ as usize
    },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(BusMajorVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).BusMinorVersion as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(BusMinorVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).SrbType as *const _ as usize },
    30usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(SrbType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_DESCRIPTOR>())).AddressType as *const _ as usize
    },
    31usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_DESCRIPTOR),
      "::",
      stringify!(AddressType)
    )
  );
}
pub type STORAGE_ADAPTER_DESCRIPTOR = _STORAGE_ADAPTER_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub BytesPerCacheLine: DWORD,
  pub BytesOffsetForCacheAlignment: DWORD,
  pub BytesPerLogicalSector: DWORD,
  pub BytesPerPhysicalSector: DWORD,
  pub BytesOffsetForSectorAlignment: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>(),
    28usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesPerCacheLine as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesPerCacheLine)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesOffsetForCacheAlignment
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesOffsetForCacheAlignment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesPerLogicalSector
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesPerLogicalSector)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesPerPhysicalSector
        as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesPerPhysicalSector)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR>())).BytesOffsetForSectorAlignment
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR),
      "::",
      stringify!(BytesOffsetForSectorAlignment)
    )
  );
}
pub type STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub MediumProductType: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>())).Version as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR>())).MediumProductType
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR),
      "::",
      stringify!(MediumProductType)
    )
  );
}
pub type STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetReserved: _STORAGE_PORT_CODE_SET = 0;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetStorport: _STORAGE_PORT_CODE_SET = 1;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetSCSIport: _STORAGE_PORT_CODE_SET = 2;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetSpaceport: _STORAGE_PORT_CODE_SET = 3;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetATAport: _STORAGE_PORT_CODE_SET = 4;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetUSBport: _STORAGE_PORT_CODE_SET = 5;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetSBP2port: _STORAGE_PORT_CODE_SET = 6;
pub const _STORAGE_PORT_CODE_SET_StoragePortCodeSetSDport: _STORAGE_PORT_CODE_SET = 7;
pub type _STORAGE_PORT_CODE_SET = ::std::os::raw::c_int;
pub use self::_STORAGE_PORT_CODE_SET as STORAGE_PORT_CODE_SET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_MINIPORT_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Portdriver: STORAGE_PORT_CODE_SET,
  pub LUNResetSupported: BOOLEAN,
  pub TargetResetSupported: BOOLEAN,
  pub IoTimeoutValue: WORD,
  pub ExtraIoInfoSupported: BOOLEAN,
  pub Reserved0: [BYTE; 3usize],
  pub Reserved1: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_MINIPORT_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_MINIPORT_DESCRIPTOR>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_MINIPORT_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_MINIPORT_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_MINIPORT_DESCRIPTOR))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Portdriver as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Portdriver)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).LUNResetSupported as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(LUNResetSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).TargetResetSupported as *const _
        as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(TargetResetSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).IoTimeoutValue as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(IoTimeoutValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).ExtraIoInfoSupported as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(ExtraIoInfoSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Reserved0 as *const _ as usize
    },
    17usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MINIPORT_DESCRIPTOR>())).Reserved1 as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MINIPORT_DESCRIPTOR),
      "::",
      stringify!(Reserved1)
    )
  );
}
pub type STORAGE_MINIPORT_DESCRIPTOR = _STORAGE_MINIPORT_DESCRIPTOR;
pub const _STORAGE_IDENTIFIER_CODE_SET_StorageIdCodeSetReserved: _STORAGE_IDENTIFIER_CODE_SET = 0;
pub const _STORAGE_IDENTIFIER_CODE_SET_StorageIdCodeSetBinary: _STORAGE_IDENTIFIER_CODE_SET = 1;
pub const _STORAGE_IDENTIFIER_CODE_SET_StorageIdCodeSetAscii: _STORAGE_IDENTIFIER_CODE_SET = 2;
pub const _STORAGE_IDENTIFIER_CODE_SET_StorageIdCodeSetUtf8: _STORAGE_IDENTIFIER_CODE_SET = 3;
pub type _STORAGE_IDENTIFIER_CODE_SET = ::std::os::raw::c_int;
pub use self::_STORAGE_IDENTIFIER_CODE_SET as STORAGE_IDENTIFIER_CODE_SET;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeVendorSpecific: _STORAGE_IDENTIFIER_TYPE = 0;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeVendorId: _STORAGE_IDENTIFIER_TYPE = 1;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeEUI64: _STORAGE_IDENTIFIER_TYPE = 2;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeFCPHName: _STORAGE_IDENTIFIER_TYPE = 3;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypePortRelative: _STORAGE_IDENTIFIER_TYPE = 4;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeTargetPortGroup: _STORAGE_IDENTIFIER_TYPE = 5;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeLogicalUnitGroup: _STORAGE_IDENTIFIER_TYPE = 6;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeMD5LogicalUnitIdentifier: _STORAGE_IDENTIFIER_TYPE =
  7;
pub const _STORAGE_IDENTIFIER_TYPE_StorageIdTypeScsiNameString: _STORAGE_IDENTIFIER_TYPE = 8;
pub type _STORAGE_IDENTIFIER_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_IDENTIFIER_TYPE as STORAGE_IDENTIFIER_TYPE;
pub const _STORAGE_ID_NAA_FORMAT_StorageIdNAAFormatIEEEExtended: _STORAGE_ID_NAA_FORMAT = 2;
pub const _STORAGE_ID_NAA_FORMAT_StorageIdNAAFormatIEEERegistered: _STORAGE_ID_NAA_FORMAT = 3;
pub const _STORAGE_ID_NAA_FORMAT_StorageIdNAAFormatIEEEERegisteredExtended: _STORAGE_ID_NAA_FORMAT =
  5;
pub type _STORAGE_ID_NAA_FORMAT = ::std::os::raw::c_int;
pub use self::_STORAGE_ID_NAA_FORMAT as STORAGE_ID_NAA_FORMAT;
pub const _STORAGE_ASSOCIATION_TYPE_StorageIdAssocDevice: _STORAGE_ASSOCIATION_TYPE = 0;
pub const _STORAGE_ASSOCIATION_TYPE_StorageIdAssocPort: _STORAGE_ASSOCIATION_TYPE = 1;
pub const _STORAGE_ASSOCIATION_TYPE_StorageIdAssocTarget: _STORAGE_ASSOCIATION_TYPE = 2;
pub type _STORAGE_ASSOCIATION_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_ASSOCIATION_TYPE as STORAGE_ASSOCIATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDENTIFIER {
  pub CodeSet: STORAGE_IDENTIFIER_CODE_SET,
  pub Type: STORAGE_IDENTIFIER_TYPE,
  pub IdentifierSize: WORD,
  pub NextOffset: WORD,
  pub Association: STORAGE_ASSOCIATION_TYPE,
  pub Identifier: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_IDENTIFIER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_IDENTIFIER>(),
    20usize,
    concat!("Size of: ", stringify!(_STORAGE_IDENTIFIER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_IDENTIFIER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_IDENTIFIER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).CodeSet as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(CodeSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).Type as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).IdentifierSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(IdentifierSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).NextOffset as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(NextOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).Association as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(Association)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDENTIFIER>())).Identifier as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDENTIFIER),
      "::",
      stringify!(Identifier)
    )
  );
}
pub type STORAGE_IDENTIFIER = _STORAGE_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_ID_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfIdentifiers: DWORD,
  pub Identifiers: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_ID_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_ID_DESCRIPTOR>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_ID_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ID_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_ID_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ID_DESCRIPTOR>())).NumberOfIdentifiers as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR),
      "::",
      stringify!(NumberOfIdentifiers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ID_DESCRIPTOR>())).Identifiers as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ID_DESCRIPTOR),
      "::",
      stringify!(Identifiers)
    )
  );
}
pub type STORAGE_DEVICE_ID_DESCRIPTOR = _STORAGE_DEVICE_ID_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_LB_PROVISIONING_MAP_RESOURCES {
  pub Size: DWORD,
  pub Version: DWORD,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub Reserved1: [BYTE; 3usize],
  pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub Reserved3: [BYTE; 3usize],
  pub AvailableMappingResources: DWORDLONG,
  pub UsedMappingResources: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_LB_PROVISIONING_MAP_RESOURCES() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).Size as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).Version as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).Reserved1 as *const _
        as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).Reserved3 as *const _
        as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(Reserved3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).AvailableMappingResources
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(AvailableMappingResources)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_LB_PROVISIONING_MAP_RESOURCES>())).UsedMappingResources
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_LB_PROVISIONING_MAP_RESOURCES),
      "::",
      stringify!(UsedMappingResources)
    )
  );
}
impl _STORAGE_LB_PROVISIONING_MAP_RESOURCES {
  #[inline]
  pub fn AvailableMappingResourcesValid(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_AvailableMappingResourcesValid(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn UsedMappingResourcesValid(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_UsedMappingResourcesValid(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 6u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    AvailableMappingResourcesValid: BYTE,
    UsedMappingResourcesValid: BYTE,
    Reserved0: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let AvailableMappingResourcesValid: u8 =
        unsafe { ::std::mem::transmute(AvailableMappingResourcesValid) };
      AvailableMappingResourcesValid as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let UsedMappingResourcesValid: u8 =
        unsafe { ::std::mem::transmute(UsedMappingResourcesValid) };
      UsedMappingResourcesValid as u64
    });
    __bindgen_bitfield_unit.set(2usize, 6u8, {
      let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
  #[inline]
  pub fn AvailableMappingResourcesScope(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
  }
  #[inline]
  pub fn set_AvailableMappingResourcesScope(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_2.set(0usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn UsedMappingResourcesScope(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
  }
  #[inline]
  pub fn set_UsedMappingResourcesScope(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_2.set(2usize, 2u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved2(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 4u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved2(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_2.set(4usize, 4u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_2(
    AvailableMappingResourcesScope: BYTE,
    UsedMappingResourcesScope: BYTE,
    Reserved2: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 2u8, {
      let AvailableMappingResourcesScope: u8 =
        unsafe { ::std::mem::transmute(AvailableMappingResourcesScope) };
      AvailableMappingResourcesScope as u64
    });
    __bindgen_bitfield_unit.set(2usize, 2u8, {
      let UsedMappingResourcesScope: u8 =
        unsafe { ::std::mem::transmute(UsedMappingResourcesScope) };
      UsedMappingResourcesScope as u64
    });
    __bindgen_bitfield_unit.set(4usize, 4u8, {
      let Reserved2: u8 = unsafe { ::std::mem::transmute(Reserved2) };
      Reserved2 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type STORAGE_LB_PROVISIONING_MAP_RESOURCES = _STORAGE_LB_PROVISIONING_MAP_RESOURCES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NameOffset: DWORD,
  pub NumberOfLogicalCopies: DWORD,
  pub NumberOfPhysicalCopies: DWORD,
  pub PhysicalDiskRedundancy: DWORD,
  pub NumberOfColumns: DWORD,
  pub Interleave: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_RESILIENCY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).NameOffset as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(NameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).NumberOfLogicalCopies
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(NumberOfLogicalCopies)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).NumberOfPhysicalCopies
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(NumberOfPhysicalCopies)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).PhysicalDiskRedundancy
        as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(PhysicalDiskRedundancy)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).NumberOfColumns as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(NumberOfColumns)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR>())).Interleave as *const _
        as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_RESILIENCY_DESCRIPTOR),
      "::",
      stringify!(Interleave)
    )
  );
}
pub type STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR;
pub const _STORAGE_RPMB_FRAME_TYPE_StorageRpmbFrameTypeUnknown: _STORAGE_RPMB_FRAME_TYPE = 0;
pub const _STORAGE_RPMB_FRAME_TYPE_StorageRpmbFrameTypeStandard: _STORAGE_RPMB_FRAME_TYPE = 1;
pub const _STORAGE_RPMB_FRAME_TYPE_StorageRpmbFrameTypeMax: _STORAGE_RPMB_FRAME_TYPE = 2;
pub type _STORAGE_RPMB_FRAME_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_RPMB_FRAME_TYPE as STORAGE_RPMB_FRAME_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_RPMB_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub SizeInBytes: DWORD,
  pub MaxReliableWriteSizeInBytes: DWORD,
  pub FrameFormat: STORAGE_RPMB_FRAME_TYPE,
}
#[test]
fn bindgen_test_layout__STORAGE_RPMB_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_RPMB_DESCRIPTOR>(),
    20usize,
    concat!("Size of: ", stringify!(_STORAGE_RPMB_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_RPMB_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_RPMB_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).SizeInBytes as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(SizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).MaxReliableWriteSizeInBytes as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(MaxReliableWriteSizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DESCRIPTOR>())).FrameFormat as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DESCRIPTOR),
      "::",
      stringify!(FrameFormat)
    )
  );
}
pub type STORAGE_RPMB_DESCRIPTOR = _STORAGE_RPMB_DESCRIPTOR;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmUnknown: _STORAGE_CRYPTO_ALGORITHM_ID =
  0;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmXTSAES: _STORAGE_CRYPTO_ALGORITHM_ID =
  1;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmBitlockerAESCBC:
  _STORAGE_CRYPTO_ALGORITHM_ID = 2;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmAESECB: _STORAGE_CRYPTO_ALGORITHM_ID =
  3;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmESSIVAESCBC:
  _STORAGE_CRYPTO_ALGORITHM_ID = 4;
pub const _STORAGE_CRYPTO_ALGORITHM_ID_StorageCryptoAlgorithmMax: _STORAGE_CRYPTO_ALGORITHM_ID = 5;
pub type _STORAGE_CRYPTO_ALGORITHM_ID = ::std::os::raw::c_int;
pub use self::_STORAGE_CRYPTO_ALGORITHM_ID as STORAGE_CRYPTO_ALGORITHM_ID;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySizeUnknown: _STORAGE_CRYPTO_KEY_SIZE = 0;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySize128Bits: _STORAGE_CRYPTO_KEY_SIZE = 1;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySize192Bits: _STORAGE_CRYPTO_KEY_SIZE = 2;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySize256Bits: _STORAGE_CRYPTO_KEY_SIZE = 3;
pub const _STORAGE_CRYPTO_KEY_SIZE_StorageCryptoKeySize512Bits: _STORAGE_CRYPTO_KEY_SIZE = 4;
pub type _STORAGE_CRYPTO_KEY_SIZE = ::std::os::raw::c_int;
pub use self::_STORAGE_CRYPTO_KEY_SIZE as STORAGE_CRYPTO_KEY_SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_CRYPTO_CAPABILITY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub CryptoCapabilityIndex: DWORD,
  pub AlgorithmId: STORAGE_CRYPTO_ALGORITHM_ID,
  pub KeySize: STORAGE_CRYPTO_KEY_SIZE,
  pub DataUnitSizeBitmask: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_CRYPTO_CAPABILITY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_CRYPTO_CAPABILITY>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_CRYPTO_CAPABILITY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_CRYPTO_CAPABILITY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_CRYPTO_CAPABILITY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).CryptoCapabilityIndex as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(CryptoCapabilityIndex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).AlgorithmId as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(AlgorithmId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).KeySize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(KeySize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_CAPABILITY>())).DataUnitSizeBitmask as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_CAPABILITY),
      "::",
      stringify!(DataUnitSizeBitmask)
    )
  );
}
pub type STORAGE_CRYPTO_CAPABILITY = _STORAGE_CRYPTO_CAPABILITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_CRYPTO_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumKeysSupported: DWORD,
  pub NumCryptoCapabilities: DWORD,
  pub CryptoCapabilities: [STORAGE_CRYPTO_CAPABILITY; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_CRYPTO_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_CRYPTO_DESCRIPTOR>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_CRYPTO_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_CRYPTO_DESCRIPTOR>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_CRYPTO_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).NumKeysSupported as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(NumKeysSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).NumCryptoCapabilities as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(NumCryptoCapabilities)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_CRYPTO_DESCRIPTOR>())).CryptoCapabilities as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_CRYPTO_DESCRIPTOR),
      "::",
      stringify!(CryptoCapabilities)
    )
  );
}
pub type STORAGE_CRYPTO_DESCRIPTOR = _STORAGE_CRYPTO_DESCRIPTOR;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeUnspecified: _STORAGE_TIER_MEDIA_TYPE = 0;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeDisk: _STORAGE_TIER_MEDIA_TYPE = 1;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeSsd: _STORAGE_TIER_MEDIA_TYPE = 2;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeScm: _STORAGE_TIER_MEDIA_TYPE = 4;
pub const _STORAGE_TIER_MEDIA_TYPE_StorageTierMediaTypeMax: _STORAGE_TIER_MEDIA_TYPE = 5;
pub type _STORAGE_TIER_MEDIA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_TIER_MEDIA_TYPE as STORAGE_TIER_MEDIA_TYPE;
pub const _STORAGE_TIER_CLASS_StorageTierClassUnspecified: _STORAGE_TIER_CLASS = 0;
pub const _STORAGE_TIER_CLASS_StorageTierClassCapacity: _STORAGE_TIER_CLASS = 1;
pub const _STORAGE_TIER_CLASS_StorageTierClassPerformance: _STORAGE_TIER_CLASS = 2;
pub const _STORAGE_TIER_CLASS_StorageTierClassMax: _STORAGE_TIER_CLASS = 3;
pub type _STORAGE_TIER_CLASS = ::std::os::raw::c_int;
pub use self::_STORAGE_TIER_CLASS as STORAGE_TIER_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_TIER {
  pub Id: GUID,
  pub Name: [WCHAR; 256usize],
  pub Description: [WCHAR; 256usize],
  pub Flags: DWORDLONG,
  pub ProvisionedCapacity: DWORDLONG,
  pub MediaType: STORAGE_TIER_MEDIA_TYPE,
  pub Class: STORAGE_TIER_CLASS,
}
#[test]
fn bindgen_test_layout__STORAGE_TIER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TIER>(),
    1064usize,
    concat!("Size of: ", stringify!(_STORAGE_TIER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TIER>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_TIER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Id as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Description as *const _ as usize },
    528usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Description)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Flags as *const _ as usize },
    1040usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).ProvisionedCapacity as *const _ as usize },
    1048usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(ProvisionedCapacity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).MediaType as *const _ as usize },
    1056usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(MediaType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER>())).Class as *const _ as usize },
    1060usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER),
      "::",
      stringify!(Class)
    )
  );
}
pub type STORAGE_TIER = _STORAGE_TIER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_DEVICE_TIERING_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub TotalNumberOfTiers: DWORD,
  pub NumberOfTiersReturned: DWORD,
  pub Tiers: [STORAGE_TIER; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_TIERING_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>(),
    1088usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).TotalNumberOfTiers as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(TotalNumberOfTiers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).NumberOfTiersReturned
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(NumberOfTiersReturned)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_TIERING_DESCRIPTOR>())).Tiers as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_TIERING_DESCRIPTOR),
      "::",
      stringify!(Tiers)
    )
  );
}
pub type STORAGE_DEVICE_TIERING_DESCRIPTOR = _STORAGE_DEVICE_TIERING_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfFaultDomains: DWORD,
  pub FaultDomainIds: [GUID; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>(),
    28usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>())).Version as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>())).NumberOfFaultDomains
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR),
      "::",
      stringify!(NumberOfFaultDomains)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR>())).FaultDomainIds as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR),
      "::",
      stringify!(FaultDomainIds)
    )
  );
}
pub type STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeUnknown: _STORAGE_PROTOCOL_TYPE = 0;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeScsi: _STORAGE_PROTOCOL_TYPE = 1;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeAta: _STORAGE_PROTOCOL_TYPE = 2;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeNvme: _STORAGE_PROTOCOL_TYPE = 3;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeSd: _STORAGE_PROTOCOL_TYPE = 4;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeUfs: _STORAGE_PROTOCOL_TYPE = 5;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeProprietary: _STORAGE_PROTOCOL_TYPE = 126;
pub const _STORAGE_PROTOCOL_TYPE_ProtocolTypeMaxReserved: _STORAGE_PROTOCOL_TYPE = 127;
pub type _STORAGE_PROTOCOL_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_PROTOCOL_TYPE as STORAGE_PROTOCOL_TYPE;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE_NVMeDataTypeUnknown: _STORAGE_PROTOCOL_NVME_DATA_TYPE =
  0;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE_NVMeDataTypeIdentify: _STORAGE_PROTOCOL_NVME_DATA_TYPE =
  1;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE_NVMeDataTypeLogPage: _STORAGE_PROTOCOL_NVME_DATA_TYPE =
  2;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE_NVMeDataTypeFeature: _STORAGE_PROTOCOL_NVME_DATA_TYPE =
  3;
pub type _STORAGE_PROTOCOL_NVME_DATA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_PROTOCOL_NVME_DATA_TYPE as STORAGE_PROTOCOL_NVME_DATA_TYPE;
pub const _STORAGE_PROTOCOL_ATA_DATA_TYPE_AtaDataTypeUnknown: _STORAGE_PROTOCOL_ATA_DATA_TYPE = 0;
pub const _STORAGE_PROTOCOL_ATA_DATA_TYPE_AtaDataTypeIdentify: _STORAGE_PROTOCOL_ATA_DATA_TYPE = 1;
pub const _STORAGE_PROTOCOL_ATA_DATA_TYPE_AtaDataTypeLogPage: _STORAGE_PROTOCOL_ATA_DATA_TYPE = 2;
pub type _STORAGE_PROTOCOL_ATA_DATA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_PROTOCOL_ATA_DATA_TYPE as STORAGE_PROTOCOL_ATA_DATA_TYPE;
pub const _STORAGE_PROTOCOL_UFS_DATA_TYPE_UfsDataTypeUnknown: _STORAGE_PROTOCOL_UFS_DATA_TYPE = 0;
pub const _STORAGE_PROTOCOL_UFS_DATA_TYPE_UfsDataTypeQueryDescriptor:
  _STORAGE_PROTOCOL_UFS_DATA_TYPE = 1;
pub const _STORAGE_PROTOCOL_UFS_DATA_TYPE_UfsDataTypeMax: _STORAGE_PROTOCOL_UFS_DATA_TYPE = 2;
pub type _STORAGE_PROTOCOL_UFS_DATA_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_PROTOCOL_UFS_DATA_TYPE as STORAGE_PROTOCOL_UFS_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_SPECIFIC_DATA {
  pub ProtocolType: STORAGE_PROTOCOL_TYPE,
  pub DataType: DWORD,
  pub ProtocolDataRequestValue: DWORD,
  pub ProtocolDataRequestSubValue: DWORD,
  pub ProtocolDataOffset: DWORD,
  pub ProtocolDataLength: DWORD,
  pub FixedProtocolReturnData: DWORD,
  pub ProtocolDataRequestSubValue2: DWORD,
  pub ProtocolDataRequestSubValue3: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_SPECIFIC_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_SPECIFIC_DATA>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_SPECIFIC_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).DataType as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(DataType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataRequestValue
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataRequestValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataRequestSubValue
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataRequestSubValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataOffset as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataLength as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).FixedProtocolReturnData
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(FixedProtocolReturnData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataRequestSubValue2
        as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataRequestSubValue2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).ProtocolDataRequestSubValue3
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(ProtocolDataRequestSubValue3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA>())).Reserved as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_PROTOCOL_SPECIFIC_DATA = _STORAGE_PROTOCOL_SPECIFIC_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_SPECIFIC_DATA_EXT {
  pub ProtocolType: STORAGE_PROTOCOL_TYPE,
  pub DataType: DWORD,
  pub ProtocolDataValue: DWORD,
  pub ProtocolDataSubValue: DWORD,
  pub ProtocolDataOffset: DWORD,
  pub ProtocolDataLength: DWORD,
  pub FixedProtocolReturnData: DWORD,
  pub ProtocolDataSubValue2: DWORD,
  pub ProtocolDataSubValue3: DWORD,
  pub ProtocolDataSubValue4: DWORD,
  pub ProtocolDataSubValue5: DWORD,
  pub Reserved: [DWORD; 5usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_SPECIFIC_DATA_EXT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>(),
    64usize,
    concat!("Size of: ", stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolType as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).DataType as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(DataType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataValue as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataOffset as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataLength as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).FixedProtocolReturnData
        as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(FixedProtocolReturnData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue2
        as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue3
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue3)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue4
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).ProtocolDataSubValue5
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(ProtocolDataSubValue5)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT>())).Reserved as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_SPECIFIC_DATA_EXT),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = _STORAGE_PROTOCOL_SPECIFIC_DATA_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_DATA_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA,
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_DATA_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>(),
    48usize,
    concat!("Size of: ", stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR>())).ProtocolSpecificData as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR),
      "::",
      stringify!(ProtocolSpecificData)
    )
  );
}
pub type STORAGE_PROTOCOL_DATA_DESCRIPTOR = _STORAGE_PROTOCOL_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT,
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>(),
    72usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT>())).ProtocolSpecificData
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT),
      "::",
      stringify!(ProtocolSpecificData)
    )
  );
}
pub type STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = _STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_INFO {
  pub Index: WORD,
  pub Temperature: SHORT,
  pub OverThreshold: SHORT,
  pub UnderThreshold: SHORT,
  pub OverThresholdChangable: BOOLEAN,
  pub UnderThresholdChangable: BOOLEAN,
  pub EventGenerated: BOOLEAN,
  pub Reserved0: BYTE,
  pub Reserved1: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_TEMPERATURE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TEMPERATURE_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_TEMPERATURE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TEMPERATURE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_TEMPERATURE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).Index as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(Index)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).Temperature as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(Temperature)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).OverThreshold as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(OverThreshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).UnderThreshold as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(UnderThreshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).OverThresholdChangable as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(OverThresholdChangable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).UnderThresholdChangable as *const _
        as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(UnderThresholdChangable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).EventGenerated as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(EventGenerated)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).Reserved0 as *const _ as usize },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_INFO>())).Reserved1 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_INFO),
      "::",
      stringify!(Reserved1)
    )
  );
}
pub type STORAGE_TEMPERATURE_INFO = _STORAGE_TEMPERATURE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_DATA_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub CriticalTemperature: SHORT,
  pub WarningTemperature: SHORT,
  pub InfoCount: WORD,
  pub Reserved0: [BYTE; 2usize],
  pub Reserved1: [DWORD; 2usize],
  pub TemperatureInfo: [STORAGE_TEMPERATURE_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_TEMPERATURE_DATA_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>(),
    40usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).CriticalTemperature
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(CriticalTemperature)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).WarningTemperature
        as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(WarningTemperature)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).InfoCount as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(InfoCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).Reserved0 as *const _
        as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).Reserved1 as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_DATA_DESCRIPTOR>())).TemperatureInfo as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_DATA_DESCRIPTOR),
      "::",
      stringify!(TemperatureInfo)
    )
  );
}
pub type STORAGE_TEMPERATURE_DATA_DESCRIPTOR = _STORAGE_TEMPERATURE_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TEMPERATURE_THRESHOLD {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: WORD,
  pub Index: WORD,
  pub Threshold: SHORT,
  pub OverThreshold: BOOLEAN,
  pub Reserved: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_TEMPERATURE_THRESHOLD() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TEMPERATURE_THRESHOLD>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_TEMPERATURE_THRESHOLD))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TEMPERATURE_THRESHOLD>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_TEMPERATURE_THRESHOLD))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Index as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Index)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Threshold as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Threshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).OverThreshold as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(OverThreshold)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_TEMPERATURE_THRESHOLD>())).Reserved as *const _ as usize
    },
    15usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TEMPERATURE_THRESHOLD),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_TEMPERATURE_THRESHOLD = _STORAGE_TEMPERATURE_THRESHOLD;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorUnknown: _STORAGE_DEVICE_FORM_FACTOR = 0;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactor3_5: _STORAGE_DEVICE_FORM_FACTOR = 1;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactor2_5: _STORAGE_DEVICE_FORM_FACTOR = 2;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactor1_8: _STORAGE_DEVICE_FORM_FACTOR = 3;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactor1_8Less: _STORAGE_DEVICE_FORM_FACTOR = 4;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorEmbedded: _STORAGE_DEVICE_FORM_FACTOR = 5;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorMemoryCard: _STORAGE_DEVICE_FORM_FACTOR = 6;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactormSata: _STORAGE_DEVICE_FORM_FACTOR = 7;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorM_2: _STORAGE_DEVICE_FORM_FACTOR = 8;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorPCIeBoard: _STORAGE_DEVICE_FORM_FACTOR = 9;
pub const _STORAGE_DEVICE_FORM_FACTOR_FormFactorDimm: _STORAGE_DEVICE_FORM_FACTOR = 10;
pub type _STORAGE_DEVICE_FORM_FACTOR = ::std::os::raw::c_int;
pub use self::_STORAGE_DEVICE_FORM_FACTOR as STORAGE_DEVICE_FORM_FACTOR;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusUnknown: _STORAGE_COMPONENT_HEALTH_STATUS =
  0;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusNormal: _STORAGE_COMPONENT_HEALTH_STATUS = 1;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusThrottled: _STORAGE_COMPONENT_HEALTH_STATUS =
  2;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusWarning: _STORAGE_COMPONENT_HEALTH_STATUS =
  3;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusDisabled: _STORAGE_COMPONENT_HEALTH_STATUS =
  4;
pub const _STORAGE_COMPONENT_HEALTH_STATUS_HealthStatusFailed: _STORAGE_COMPONENT_HEALTH_STATUS = 5;
pub type _STORAGE_COMPONENT_HEALTH_STATUS = ::std::os::raw::c_int;
pub use self::_STORAGE_COMPONENT_HEALTH_STATUS as STORAGE_COMPONENT_HEALTH_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_SPEC_VERSION {
  pub __bindgen_anon_1: _STORAGE_SPEC_VERSION__bindgen_ty_1,
  pub AsUlong: DWORD,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_SPEC_VERSION__bindgen_ty_1 {
  pub MinorVersion: _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1,
  pub MajorVersion: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1 {
  pub __bindgen_anon_1: _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  pub AsUshort: WORD,
  _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub SubMinor: BYTE,
  pub Minor: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .SubMinor as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(SubMinor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .Minor as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Minor)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1>())).AsUshort
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(AsUshort)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_SPEC_VERSION__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_SPEC_VERSION__bindgen_ty_1>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1>())).MinorVersion as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1),
      "::",
      stringify!(MinorVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION__bindgen_ty_1>())).MajorVersion as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION__bindgen_ty_1),
      "::",
      stringify!(MajorVersion)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_SPEC_VERSION() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_SPEC_VERSION>(),
    4usize,
    concat!("Size of: ", stringify!(_STORAGE_SPEC_VERSION))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_SPEC_VERSION>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_SPEC_VERSION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_SPEC_VERSION>())).AsUlong as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_SPEC_VERSION),
      "::",
      stringify!(AsUlong)
    )
  );
}
pub type STORAGE_SPEC_VERSION = _STORAGE_SPEC_VERSION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_PHYSICAL_DEVICE_DATA {
  pub DeviceId: DWORD,
  pub Role: DWORD,
  pub HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
  pub CommandProtocol: STORAGE_PROTOCOL_TYPE,
  pub SpecVersion: STORAGE_SPEC_VERSION,
  pub FormFactor: STORAGE_DEVICE_FORM_FACTOR,
  pub Vendor: [BYTE; 8usize],
  pub Model: [BYTE; 40usize],
  pub FirmwareRevision: [BYTE; 16usize],
  pub Capacity: DWORDLONG,
  pub PhysicalLocation: [BYTE; 32usize],
  pub Reserved: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PHYSICAL_DEVICE_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PHYSICAL_DEVICE_DATA>(),
    136usize,
    concat!("Size of: ", stringify!(_STORAGE_PHYSICAL_DEVICE_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PHYSICAL_DEVICE_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_PHYSICAL_DEVICE_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).DeviceId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(DeviceId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Role as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Role)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).HealthStatus as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(HealthStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).CommandProtocol as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(CommandProtocol)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).SpecVersion as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(SpecVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).FormFactor as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(FormFactor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Vendor as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Vendor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Model as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Model)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).FirmwareRevision as *const _
        as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(FirmwareRevision)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Capacity as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Capacity)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).PhysicalLocation as *const _
        as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(PhysicalLocation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_DEVICE_DATA>())).Reserved as *const _ as usize
    },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_DEVICE_DATA),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_PHYSICAL_DEVICE_DATA = _STORAGE_PHYSICAL_DEVICE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_PHYSICAL_ADAPTER_DATA {
  pub AdapterId: DWORD,
  pub HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
  pub CommandProtocol: STORAGE_PROTOCOL_TYPE,
  pub SpecVersion: STORAGE_SPEC_VERSION,
  pub Vendor: [BYTE; 8usize],
  pub Model: [BYTE; 40usize],
  pub FirmwareRevision: [BYTE; 16usize],
  pub PhysicalLocation: [BYTE; 32usize],
  pub ExpanderConnected: BOOLEAN,
  pub Reserved0: [BYTE; 3usize],
  pub Reserved1: [DWORD; 3usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PHYSICAL_ADAPTER_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PHYSICAL_ADAPTER_DATA>(),
    128usize,
    concat!("Size of: ", stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PHYSICAL_ADAPTER_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).AdapterId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(AdapterId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).HealthStatus as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(HealthStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).CommandProtocol as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(CommandProtocol)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).SpecVersion as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(SpecVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).Vendor as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(Vendor)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).Model as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(Model)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).FirmwareRevision as *const _
        as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(FirmwareRevision)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).PhysicalLocation as *const _
        as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(PhysicalLocation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).ExpanderConnected as *const _
        as usize
    },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(ExpanderConnected)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).Reserved0 as *const _ as usize
    },
    113usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_ADAPTER_DATA>())).Reserved1 as *const _ as usize
    },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_ADAPTER_DATA),
      "::",
      stringify!(Reserved1)
    )
  );
}
pub type STORAGE_PHYSICAL_ADAPTER_DATA = _STORAGE_PHYSICAL_ADAPTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PHYSICAL_NODE_DATA {
  pub NodeId: DWORD,
  pub AdapterCount: DWORD,
  pub AdapterDataLength: DWORD,
  pub AdapterDataOffset: DWORD,
  pub DeviceCount: DWORD,
  pub DeviceDataLength: DWORD,
  pub DeviceDataOffset: DWORD,
  pub Reserved: [DWORD; 3usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PHYSICAL_NODE_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PHYSICAL_NODE_DATA>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_PHYSICAL_NODE_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PHYSICAL_NODE_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PHYSICAL_NODE_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).NodeId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(NodeId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).AdapterCount as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(AdapterCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).AdapterDataLength as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(AdapterDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).AdapterDataOffset as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(AdapterDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).DeviceCount as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(DeviceCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).DeviceDataLength as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(DeviceDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).DeviceDataOffset as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(DeviceDataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_NODE_DATA>())).Reserved as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_NODE_DATA),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_PHYSICAL_NODE_DATA = _STORAGE_PHYSICAL_NODE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NodeCount: DWORD,
  pub Reserved: DWORD,
  pub Node: [STORAGE_PHYSICAL_NODE_DATA; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).NodeCount as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(NodeCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).Reserved as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR>())).Node as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR),
      "::",
      stringify!(Node)
    )
  );
}
pub type STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub LunMaxIoCount: DWORD,
  pub AdapterMaxIoCount: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>())).Version as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>())).LunMaxIoCount as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR),
      "::",
      stringify!(LunMaxIoCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR>())).AdapterMaxIoCount
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR),
      "::",
      stringify!(AdapterMaxIoCount)
    )
  );
}
pub type STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Attributes: DWORD64,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR>())).Attributes as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR),
      "::",
      stringify!(Attributes)
    )
  );
}
pub type STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthUnknown: _STORAGE_DISK_HEALTH_STATUS = 0;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthUnhealthy: _STORAGE_DISK_HEALTH_STATUS = 1;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthWarning: _STORAGE_DISK_HEALTH_STATUS = 2;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthHealthy: _STORAGE_DISK_HEALTH_STATUS = 3;
pub const _STORAGE_DISK_HEALTH_STATUS_DiskHealthMax: _STORAGE_DISK_HEALTH_STATUS = 4;
pub type _STORAGE_DISK_HEALTH_STATUS = ::std::os::raw::c_int;
pub use self::_STORAGE_DISK_HEALTH_STATUS as STORAGE_DISK_HEALTH_STATUS;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusNone: _STORAGE_DISK_OPERATIONAL_STATUS = 0;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusUnknown: _STORAGE_DISK_OPERATIONAL_STATUS =
  1;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusOk: _STORAGE_DISK_OPERATIONAL_STATUS = 2;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusPredictingFailure:
  _STORAGE_DISK_OPERATIONAL_STATUS = 3;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusInService: _STORAGE_DISK_OPERATIONAL_STATUS =
  4;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusHardwareError:
  _STORAGE_DISK_OPERATIONAL_STATUS = 5;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusNotUsable: _STORAGE_DISK_OPERATIONAL_STATUS =
  6;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusTransientError:
  _STORAGE_DISK_OPERATIONAL_STATUS = 7;
pub const _STORAGE_DISK_OPERATIONAL_STATUS_DiskOpStatusMissing: _STORAGE_DISK_OPERATIONAL_STATUS =
  8;
pub type _STORAGE_DISK_OPERATIONAL_STATUS = ::std::os::raw::c_int;
pub use self::_STORAGE_DISK_OPERATIONAL_STATUS as STORAGE_DISK_OPERATIONAL_STATUS;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonUnknown:
  _STORAGE_OPERATIONAL_STATUS_REASON = 0;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonScsiSenseCode:
  _STORAGE_OPERATIONAL_STATUS_REASON = 1;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonMedia: _STORAGE_OPERATIONAL_STATUS_REASON =
  2;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonIo: _STORAGE_OPERATIONAL_STATUS_REASON = 3;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonThresholdExceeded:
  _STORAGE_OPERATIONAL_STATUS_REASON = 4;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonLostData:
  _STORAGE_OPERATIONAL_STATUS_REASON = 5;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonEnergySource:
  _STORAGE_OPERATIONAL_STATUS_REASON = 6;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonConfiguration:
  _STORAGE_OPERATIONAL_STATUS_REASON = 7;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonDeviceController:
  _STORAGE_OPERATIONAL_STATUS_REASON = 8;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonMediaController:
  _STORAGE_OPERATIONAL_STATUS_REASON = 9;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonComponent:
  _STORAGE_OPERATIONAL_STATUS_REASON = 10;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonNVDIMM_N:
  _STORAGE_OPERATIONAL_STATUS_REASON = 11;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonBackgroundOperation:
  _STORAGE_OPERATIONAL_STATUS_REASON = 12;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonInvalidFirmware:
  _STORAGE_OPERATIONAL_STATUS_REASON = 13;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonHealthCheck:
  _STORAGE_OPERATIONAL_STATUS_REASON = 14;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonLostDataPersistence:
  _STORAGE_OPERATIONAL_STATUS_REASON = 15;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonDisabledByPlatform:
  _STORAGE_OPERATIONAL_STATUS_REASON = 16;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonLostWritePersistence:
  _STORAGE_OPERATIONAL_STATUS_REASON = 17;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonDataPersistenceLossImminent:
  _STORAGE_OPERATIONAL_STATUS_REASON = 18;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonWritePersistenceLossImminent:
  _STORAGE_OPERATIONAL_STATUS_REASON = 19;
pub const _STORAGE_OPERATIONAL_STATUS_REASON_DiskOpReasonMax: _STORAGE_OPERATIONAL_STATUS_REASON =
  20;
pub type _STORAGE_OPERATIONAL_STATUS_REASON = ::std::os::raw::c_int;
pub use self::_STORAGE_OPERATIONAL_STATUS_REASON as STORAGE_OPERATIONAL_STATUS_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Reason: STORAGE_OPERATIONAL_STATUS_REASON,
  pub RawBytes: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_OPERATIONAL_REASON__bindgen_ty_1 {
  pub ScsiSenseKey: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1,
  pub NVDIMM_N: _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2,
  pub AsUlong: DWORD,
  _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1 {
  pub SenseKey: BYTE,
  pub ASC: BYTE,
  pub ASCQ: BYTE,
  pub Reserved: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>())).SenseKey
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(SenseKey)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>())).ASC
        as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ASC)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>())).ASCQ
        as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ASCQ)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1>())).Reserved
        as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2 {
  pub CriticalHealth: BYTE,
  pub ModuleHealth: [BYTE; 2usize],
  pub ErrorThresholdStatus: BYTE,
}
#[test]
fn bindgen_test_layout__STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>()))
        .CriticalHealth as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(CriticalHealth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>()))
        .ModuleHealth as *const _ as usize
    },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(ModuleHealth)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2>()))
        .ErrorThresholdStatus as *const _ as usize
    },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(ErrorThresholdStatus)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_OPERATIONAL_REASON__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>())).ScsiSenseKey as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1),
      "::",
      stringify!(ScsiSenseKey)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>())).NVDIMM_N as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1),
      "::",
      stringify!(NVDIMM_N)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON__bindgen_ty_1>())).AsUlong as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON__bindgen_ty_1),
      "::",
      stringify!(AsUlong)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_OPERATIONAL_REASON() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OPERATIONAL_REASON>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_OPERATIONAL_REASON))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OPERATIONAL_REASON>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_OPERATIONAL_REASON))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON>())).Reason as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON),
      "::",
      stringify!(Reason)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OPERATIONAL_REASON>())).RawBytes as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OPERATIONAL_REASON),
      "::",
      stringify!(RawBytes)
    )
  );
}
pub type STORAGE_OPERATIONAL_REASON = _STORAGE_OPERATIONAL_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_DEVICE_MANAGEMENT_STATUS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Health: STORAGE_DISK_HEALTH_STATUS,
  pub NumberOfOperationalStatus: DWORD,
  pub NumberOfAdditionalReasons: DWORD,
  pub OperationalStatus: [STORAGE_DISK_OPERATIONAL_STATUS; 16usize],
  pub AdditionalReasons: [STORAGE_OPERATIONAL_REASON; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_MANAGEMENT_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_MANAGEMENT_STATUS>(),
    100usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_MANAGEMENT_STATUS>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).Health as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(Health)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).NumberOfOperationalStatus
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(NumberOfOperationalStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).NumberOfAdditionalReasons
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(NumberOfAdditionalReasons)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).OperationalStatus as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(OperationalStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_MANAGEMENT_STATUS>())).AdditionalReasons as *const _
        as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_MANAGEMENT_STATUS),
      "::",
      stringify!(AdditionalReasons)
    )
  );
}
pub type STORAGE_DEVICE_MANAGEMENT_STATUS = _STORAGE_DEVICE_MANAGEMENT_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_ADAPTER_SERIAL_NUMBER {
  pub Version: DWORD,
  pub Size: DWORD,
  pub SerialNumber: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout__STORAGE_ADAPTER_SERIAL_NUMBER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ADAPTER_SERIAL_NUMBER>(),
    264usize,
    concat!("Size of: ", stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ADAPTER_SERIAL_NUMBER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_SERIAL_NUMBER>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ADAPTER_SERIAL_NUMBER>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ADAPTER_SERIAL_NUMBER>())).SerialNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ADAPTER_SERIAL_NUMBER),
      "::",
      stringify!(SerialNumber)
    )
  );
}
pub type STORAGE_ADAPTER_SERIAL_NUMBER = _STORAGE_ADAPTER_SERIAL_NUMBER;
pub const _STORAGE_ZONED_DEVICE_TYPES_ZonedDeviceTypeUnknown: _STORAGE_ZONED_DEVICE_TYPES = 0;
pub const _STORAGE_ZONED_DEVICE_TYPES_ZonedDeviceTypeHostManaged: _STORAGE_ZONED_DEVICE_TYPES = 1;
pub const _STORAGE_ZONED_DEVICE_TYPES_ZonedDeviceTypeHostAware: _STORAGE_ZONED_DEVICE_TYPES = 2;
pub const _STORAGE_ZONED_DEVICE_TYPES_ZonedDeviceTypeDeviceManaged: _STORAGE_ZONED_DEVICE_TYPES = 3;
pub type _STORAGE_ZONED_DEVICE_TYPES = ::std::os::raw::c_int;
pub use self::_STORAGE_ZONED_DEVICE_TYPES as STORAGE_ZONED_DEVICE_TYPES;
pub const _STORAGE_ZONE_TYPES_ZoneTypeUnknown: _STORAGE_ZONE_TYPES = 0;
pub const _STORAGE_ZONE_TYPES_ZoneTypeConventional: _STORAGE_ZONE_TYPES = 1;
pub const _STORAGE_ZONE_TYPES_ZoneTypeSequentialWriteRequired: _STORAGE_ZONE_TYPES = 2;
pub const _STORAGE_ZONE_TYPES_ZoneTypeSequentialWritePreferred: _STORAGE_ZONE_TYPES = 3;
pub const _STORAGE_ZONE_TYPES_ZoneTypeMax: _STORAGE_ZONE_TYPES = 4;
pub type _STORAGE_ZONE_TYPES = ::std::os::raw::c_int;
pub use self::_STORAGE_ZONE_TYPES as STORAGE_ZONE_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONE_GROUP {
  pub ZoneCount: DWORD,
  pub ZoneType: STORAGE_ZONE_TYPES,
  pub ZoneSize: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_ZONE_GROUP() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONE_GROUP>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_ZONE_GROUP))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONE_GROUP>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_ZONE_GROUP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_GROUP>())).ZoneCount as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_GROUP),
      "::",
      stringify!(ZoneCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_GROUP>())).ZoneType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_GROUP),
      "::",
      stringify!(ZoneType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_GROUP>())).ZoneSize as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_GROUP),
      "::",
      stringify!(ZoneSize)
    )
  );
}
pub type STORAGE_ZONE_GROUP = _STORAGE_ZONE_GROUP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceType: STORAGE_ZONED_DEVICE_TYPES,
  pub ZoneCount: DWORD,
  pub ZoneAttributes: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1,
  pub ZoneGroupCount: DWORD,
  pub ZoneGroup: [STORAGE_ZONE_GROUP; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1 {
  pub SequentialRequiredZone: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
  pub SequentialPreferredZone: _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
  pub MaxOpenZoneCount: DWORD,
  pub UnrestrictedRead: BOOLEAN,
  pub Reserved: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()))
        .MaxOpenZoneCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(MaxOpenZoneCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()))
        .UnrestrictedRead as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(UnrestrictedRead)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>()))
        .Reserved as *const _ as usize
    },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Reserved)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
  pub OptimalOpenZoneCount: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>()))
        .OptimalOpenZoneCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(OptimalOpenZoneCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>()))
        .Reserved as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Reserved)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1>()))
        .SequentialRequiredZone as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1),
      "::",
      stringify!(SequentialRequiredZone)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1>()))
        .SequentialPreferredZone as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR__bindgen_ty_1),
      "::",
      stringify!(SequentialPreferredZone)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_ZONED_DEVICE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>(),
    48usize,
    concat!("Size of: ", stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).DeviceType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(DeviceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).ZoneCount as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ZoneCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).ZoneAttributes as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ZoneAttributes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).ZoneGroupCount as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ZoneGroupCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONED_DEVICE_DESCRIPTOR>())).ZoneGroup as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONED_DEVICE_DESCRIPTOR),
      "::",
      stringify!(ZoneGroup)
    )
  );
}
pub type STORAGE_ZONED_DEVICE_DESCRIPTOR = _STORAGE_ZONED_DEVICE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DEVICE_LOCATION {
  pub Socket: DWORD,
  pub Slot: DWORD,
  pub Adapter: DWORD,
  pub Port: DWORD,
  pub __bindgen_anon_1: _DEVICE_LOCATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_LOCATION__bindgen_ty_1 {
  pub __bindgen_anon_1: _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1,
  pub __bindgen_anon_2: _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1 {
  pub Channel: DWORD,
  pub Device: DWORD,
}
#[test]
fn bindgen_test_layout__DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1>())).Channel as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Channel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1>())).Device as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Device)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2 {
  pub Target: DWORD,
  pub Lun: DWORD,
}
#[test]
fn bindgen_test_layout__DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2>())).Target as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Target)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2>())).Lun as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION__bindgen_ty_1__bindgen_ty_2),
      "::",
      stringify!(Lun)
    )
  );
}
#[test]
fn bindgen_test_layout__DEVICE_LOCATION__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_DEVICE_LOCATION__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_DEVICE_LOCATION__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_DEVICE_LOCATION__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(_DEVICE_LOCATION__bindgen_ty_1))
  );
}
#[test]
fn bindgen_test_layout__DEVICE_LOCATION() {
  assert_eq!(
    ::std::mem::size_of::<_DEVICE_LOCATION>(),
    24usize,
    concat!("Size of: ", stringify!(_DEVICE_LOCATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_DEVICE_LOCATION>(),
    4usize,
    concat!("Alignment of ", stringify!(_DEVICE_LOCATION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DEVICE_LOCATION>())).Socket as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION),
      "::",
      stringify!(Socket)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DEVICE_LOCATION>())).Slot as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DEVICE_LOCATION>())).Adapter as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION),
      "::",
      stringify!(Adapter)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DEVICE_LOCATION>())).Port as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_DEVICE_LOCATION),
      "::",
      stringify!(Port)
    )
  );
}
pub type DEVICE_LOCATION = _DEVICE_LOCATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_DEVICE_LOCATION_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Location: DEVICE_LOCATION,
  pub StringOffset: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_LOCATION_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>(),
    36usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>())).Location as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR),
      "::",
      stringify!(Location)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_LOCATION_DESCRIPTOR>())).StringOffset as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_LOCATION_DESCRIPTOR),
      "::",
      stringify!(StringOffset)
    )
  );
}
pub type STORAGE_DEVICE_LOCATION_DESCRIPTOR = _STORAGE_DEVICE_LOCATION_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_NUMA_PROPERTY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumaNode: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_NUMA_PROPERTY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_NUMA_PROPERTY>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_NUMA_PROPERTY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_NUMA_PROPERTY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_NUMA_PROPERTY))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMA_PROPERTY>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMA_PROPERTY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMA_PROPERTY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMA_PROPERTY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_NUMA_PROPERTY>())).NumaNode as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_NUMA_PROPERTY),
      "::",
      stringify!(NumaNode)
    )
  );
}
pub type STORAGE_DEVICE_NUMA_PROPERTY = _STORAGE_DEVICE_NUMA_PROPERTY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub UnsafeShutdownCount: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT>())).UnsafeShutdownCount
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT),
      "::",
      stringify!(UnsafeShutdownCount)
    )
  );
}
pub type STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_INFO {
  pub ValidFields: DWORD,
  pub GroupId: DWORD,
  pub Flags: _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1,
  pub LifePercentage: DWORD,
  pub BytesReadCount: [BYTE; 16usize],
  pub ByteWriteCount: [BYTE; 16usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1)
    )
  );
}
impl _STORAGE_HW_ENDURANCE_INFO__bindgen_ty_1 {
  #[inline]
  pub fn Shared(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Shared(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 31u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    Shared: DWORD,
    Reserved: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Shared: u32 = unsafe { ::std::mem::transmute(Shared) };
      Shared as u64
    });
    __bindgen_bitfield_unit.set(1usize, 31u8, {
      let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__STORAGE_HW_ENDURANCE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_ENDURANCE_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_ENDURANCE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_ENDURANCE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_ENDURANCE_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).ValidFields as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(ValidFields)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).GroupId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(GroupId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).LifePercentage as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(LifePercentage)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).BytesReadCount as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(BytesReadCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_INFO>())).ByteWriteCount as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_INFO),
      "::",
      stringify!(ByteWriteCount)
    )
  );
}
pub type STORAGE_HW_ENDURANCE_INFO = _STORAGE_HW_ENDURANCE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR {
  pub Version: DWORD,
  pub Size: DWORD,
  pub EnduranceInfo: STORAGE_HW_ENDURANCE_INFO,
}
#[test]
fn bindgen_test_layout__STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR>())).EnduranceInfo as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR),
      "::",
      stringify!(EnduranceInfo)
    )
  );
}
pub type STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = _STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OFFLOAD_TOKEN {
  pub TokenType: [BYTE; 4usize],
  pub Reserved: [BYTE; 2usize],
  pub TokenIdLength: [BYTE; 2usize],
  pub __bindgen_anon_1: _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1 {
  pub StorageOffloadZeroDataToken: _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1,
  pub Token: [BYTE; 504usize],
  _bindgen_union_align: [u8; 504usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1 {
  pub Reserved2: [BYTE; 504usize],
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1>(),
    504usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1>())).Reserved2
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Reserved2)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_TOKEN__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1>(),
    504usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1>(),
    1usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1>())).StorageOffloadZeroDataToken
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1),
      "::",
      stringify!(StorageOffloadZeroDataToken)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1>())).Token as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN__bindgen_ty_1),
      "::",
      stringify!(Token)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_TOKEN() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_TOKEN>(),
    512usize,
    concat!("Size of: ", stringify!(_STORAGE_OFFLOAD_TOKEN))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_TOKEN>(),
    1usize,
    concat!("Alignment of ", stringify!(_STORAGE_OFFLOAD_TOKEN))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN>())).TokenType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN),
      "::",
      stringify!(TokenType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN>())).Reserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_TOKEN>())).TokenIdLength as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_TOKEN),
      "::",
      stringify!(TokenIdLength)
    )
  );
}
pub type STORAGE_OFFLOAD_TOKEN = _STORAGE_OFFLOAD_TOKEN;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_OFFLOAD_READ_OUTPUT {
  pub OffloadReadFlags: DWORD,
  pub Reserved: DWORD,
  pub LengthProtected: DWORDLONG,
  pub TokenLength: DWORD,
  pub Token: STORAGE_OFFLOAD_TOKEN,
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_READ_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_READ_OUTPUT>(),
    536usize,
    concat!("Size of: ", stringify!(_STORAGE_OFFLOAD_READ_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_READ_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_OFFLOAD_READ_OUTPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).OffloadReadFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(OffloadReadFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).Reserved as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).LengthProtected as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(LengthProtected)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).TokenLength as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(TokenLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_OFFLOAD_READ_OUTPUT>())).Token as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_READ_OUTPUT),
      "::",
      stringify!(Token)
    )
  );
}
pub type STORAGE_OFFLOAD_READ_OUTPUT = _STORAGE_OFFLOAD_READ_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_OFFLOAD_WRITE_OUTPUT {
  pub OffloadWriteFlags: DWORD,
  pub Reserved: DWORD,
  pub LengthCopied: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_OFFLOAD_WRITE_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_OFFLOAD_WRITE_OUTPUT>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_OFFLOAD_WRITE_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_WRITE_OUTPUT>())).OffloadWriteFlags as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT),
      "::",
      stringify!(OffloadWriteFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_WRITE_OUTPUT>())).Reserved as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_OFFLOAD_WRITE_OUTPUT>())).LengthCopied as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_OFFLOAD_WRITE_OUTPUT),
      "::",
      stringify!(LengthCopied)
    )
  );
}
pub type STORAGE_OFFLOAD_WRITE_OUTPUT = _STORAGE_OFFLOAD_WRITE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_TIER_REGION {
  pub TierId: GUID,
  pub Offset: DWORDLONG,
  pub Length: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_TIER_REGION() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_TIER_REGION>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_TIER_REGION))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_TIER_REGION>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_TIER_REGION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER_REGION>())).TierId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER_REGION),
      "::",
      stringify!(TierId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER_REGION>())).Offset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER_REGION),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_TIER_REGION>())).Length as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_TIER_REGION),
      "::",
      stringify!(Length)
    )
  );
}
pub type STORAGE_TIER_REGION = _STORAGE_TIER_REGION;
pub const _STORAGE_ZONES_ATTRIBUTES_ZonesAttributeTypeAndLengthMayDifferent:
  _STORAGE_ZONES_ATTRIBUTES = 0;
pub const _STORAGE_ZONES_ATTRIBUTES_ZonesAttributeTypeSameLengthSame: _STORAGE_ZONES_ATTRIBUTES = 1;
pub const _STORAGE_ZONES_ATTRIBUTES_ZonesAttributeTypeSameLastZoneLengthDifferent:
  _STORAGE_ZONES_ATTRIBUTES = 2;
pub const _STORAGE_ZONES_ATTRIBUTES_ZonesAttributeTypeMayDifferentLengthSame:
  _STORAGE_ZONES_ATTRIBUTES = 3;
pub type _STORAGE_ZONES_ATTRIBUTES = ::std::os::raw::c_int;
pub use self::_STORAGE_ZONES_ATTRIBUTES as STORAGE_ZONES_ATTRIBUTES;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionConventional: _STORAGE_ZONE_CONDITION = 0;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionEmpty: _STORAGE_ZONE_CONDITION = 1;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionImplicitlyOpened: _STORAGE_ZONE_CONDITION = 2;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionExplicitlyOpened: _STORAGE_ZONE_CONDITION = 3;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionClosed: _STORAGE_ZONE_CONDITION = 4;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionReadOnly: _STORAGE_ZONE_CONDITION = 13;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionFull: _STORAGE_ZONE_CONDITION = 14;
pub const _STORAGE_ZONE_CONDITION_ZoneConditionOffline: _STORAGE_ZONE_CONDITION = 15;
pub type _STORAGE_ZONE_CONDITION = ::std::os::raw::c_int;
pub use self::_STORAGE_ZONE_CONDITION as STORAGE_ZONE_CONDITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ZONE_DESCRIPTOR {
  pub Size: DWORD,
  pub ZoneType: STORAGE_ZONE_TYPES,
  pub ZoneCondition: STORAGE_ZONE_CONDITION,
  pub ResetWritePointerRecommend: BOOLEAN,
  pub Reserved0: [BYTE; 3usize],
  pub ZoneSize: DWORDLONG,
  pub WritePointerOffset: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_ZONE_DESCRIPTOR() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ZONE_DESCRIPTOR>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_ZONE_DESCRIPTOR))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ZONE_DESCRIPTOR>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_ZONE_DESCRIPTOR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).ZoneType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(ZoneType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).ZoneCondition as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(ZoneCondition)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).ResetWritePointerRecommend as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(ResetWritePointerRecommend)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).Reserved0 as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).ZoneSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(ZoneSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ZONE_DESCRIPTOR>())).WritePointerOffset as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ZONE_DESCRIPTOR),
      "::",
      stringify!(WritePointerOffset)
    )
  );
}
pub type STORAGE_ZONE_DESCRIPTOR = _STORAGE_ZONE_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_GET_BC_PROPERTIES_OUTPUT {
  pub MaximumRequestsPerPeriod: DWORD,
  pub MinimumPeriod: DWORD,
  pub MaximumRequestSize: DWORDLONG,
  pub EstimatedTimePerRequest: DWORD,
  pub NumOutStandingRequests: DWORD,
  pub RequestSize: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_GET_BC_PROPERTIES_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).MaximumRequestsPerPeriod
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(MaximumRequestsPerPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).MinimumPeriod as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(MinimumPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).MaximumRequestSize as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(MaximumRequestSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).EstimatedTimePerRequest
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(EstimatedTimePerRequest)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).NumOutStandingRequests
        as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(NumOutStandingRequests)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_GET_BC_PROPERTIES_OUTPUT>())).RequestSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_GET_BC_PROPERTIES_OUTPUT),
      "::",
      stringify!(RequestSize)
    )
  );
}
pub type STORAGE_GET_BC_PROPERTIES_OUTPUT = _STORAGE_GET_BC_PROPERTIES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ALLOCATE_BC_STREAM_INPUT {
  pub Version: DWORD,
  pub RequestsPerPeriod: DWORD,
  pub Period: DWORD,
  pub RetryFailures: BOOLEAN,
  pub Discardable: BOOLEAN,
  pub Reserved1: [BOOLEAN; 2usize],
  pub AccessType: DWORD,
  pub AccessMode: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ALLOCATE_BC_STREAM_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).RequestsPerPeriod as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(RequestsPerPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).Period as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(Period)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).RetryFailures as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(RetryFailures)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).Discardable as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(Discardable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).Reserved1 as *const _ as usize
    },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).AccessType as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(AccessType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_INPUT>())).AccessMode as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_INPUT),
      "::",
      stringify!(AccessMode)
    )
  );
}
pub type STORAGE_ALLOCATE_BC_STREAM_INPUT = _STORAGE_ALLOCATE_BC_STREAM_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
  pub RequestSize: DWORDLONG,
  pub NumOutStandingRequests: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ALLOCATE_BC_STREAM_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ALLOCATE_BC_STREAM_OUTPUT>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ALLOCATE_BC_STREAM_OUTPUT>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_OUTPUT>())).RequestSize as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT),
      "::",
      stringify!(RequestSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_ALLOCATE_BC_STREAM_OUTPUT>())).NumOutStandingRequests
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ALLOCATE_BC_STREAM_OUTPUT),
      "::",
      stringify!(NumOutStandingRequests)
    )
  );
}
pub type STORAGE_ALLOCATE_BC_STREAM_OUTPUT = _STORAGE_ALLOCATE_BC_STREAM_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PRIORITY_HINT_SUPPORT {
  pub SupportFlags: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_PRIORITY_HINT_SUPPORT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PRIORITY_HINT_SUPPORT>(),
    4usize,
    concat!("Size of: ", stringify!(_STORAGE_PRIORITY_HINT_SUPPORT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PRIORITY_HINT_SUPPORT>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PRIORITY_HINT_SUPPORT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PRIORITY_HINT_SUPPORT>())).SupportFlags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PRIORITY_HINT_SUPPORT),
      "::",
      stringify!(SupportFlags)
    )
  );
}
pub type STORAGE_PRIORITY_HINT_SUPPORT = _STORAGE_PRIORITY_HINT_SUPPORT;
pub const _STORAGE_DIAGNOSTIC_LEVEL_StorageDiagnosticLevelDefault: _STORAGE_DIAGNOSTIC_LEVEL = 0;
pub const _STORAGE_DIAGNOSTIC_LEVEL_StorageDiagnosticLevelMax: _STORAGE_DIAGNOSTIC_LEVEL = 1;
pub type _STORAGE_DIAGNOSTIC_LEVEL = ::std::os::raw::c_int;
pub use self::_STORAGE_DIAGNOSTIC_LEVEL as STORAGE_DIAGNOSTIC_LEVEL;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypeUndefined:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 0;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypePort:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 1;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypeMiniport:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 2;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypeHbaFirmware:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 3;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE_StorageDiagnosticTargetTypeMax:
  _STORAGE_DIAGNOSTIC_TARGET_TYPE = 4;
pub type _STORAGE_DIAGNOSTIC_TARGET_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_DIAGNOSTIC_TARGET_TYPE as STORAGE_DIAGNOSTIC_TARGET_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DIAGNOSTIC_REQUEST {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Reserved: DWORD,
  pub TargetType: STORAGE_DIAGNOSTIC_TARGET_TYPE,
  pub Level: STORAGE_DIAGNOSTIC_LEVEL,
}
#[test]
fn bindgen_test_layout__STORAGE_DIAGNOSTIC_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DIAGNOSTIC_REQUEST>(),
    20usize,
    concat!("Size of: ", stringify!(_STORAGE_DIAGNOSTIC_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DIAGNOSTIC_REQUEST>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DIAGNOSTIC_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).Reserved as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).TargetType as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(TargetType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_REQUEST>())).Level as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_REQUEST),
      "::",
      stringify!(Level)
    )
  );
}
pub type STORAGE_DIAGNOSTIC_REQUEST = _STORAGE_DIAGNOSTIC_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DIAGNOSTIC_DATA {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProviderId: GUID,
  pub BufferSize: DWORD,
  pub Reserved: DWORD,
  pub DiagnosticDataBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_DIAGNOSTIC_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DIAGNOSTIC_DATA>(),
    36usize,
    concat!("Size of: ", stringify!(_STORAGE_DIAGNOSTIC_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DIAGNOSTIC_DATA>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_DIAGNOSTIC_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).ProviderId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(ProviderId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).BufferSize as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(BufferSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).Reserved as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_DIAGNOSTIC_DATA>())).DiagnosticDataBuffer as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DIAGNOSTIC_DATA),
      "::",
      stringify!(DiagnosticDataBuffer)
    )
  );
}
pub type STORAGE_DIAGNOSTIC_DATA = _STORAGE_DIAGNOSTIC_DATA;
#[repr(C)]
#[derive(Debug)]
pub struct _STORAGE_MEDIA_SERIAL_NUMBER_DATA {
  pub Reserved: WORD,
  pub SerialNumberLength: WORD,
  pub SerialNumber: __IncompleteArrayField<BYTE>,
}
#[test]
fn bindgen_test_layout__STORAGE_MEDIA_SERIAL_NUMBER_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>(),
    4usize,
    concat!("Size of: ", stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>(),
    2usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>())).Reserved as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>())).SerialNumberLength as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA),
      "::",
      stringify!(SerialNumberLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_MEDIA_SERIAL_NUMBER_DATA>())).SerialNumber as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_MEDIA_SERIAL_NUMBER_DATA),
      "::",
      stringify!(SerialNumber)
    )
  );
}
pub type STORAGE_MEDIA_SERIAL_NUMBER_DATA = _STORAGE_MEDIA_SERIAL_NUMBER_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_READ_CAPACITY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub BlockLength: DWORD,
  pub NumberOfBlocks: LARGE_INTEGER,
  pub DiskLength: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__STORAGE_READ_CAPACITY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_READ_CAPACITY>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_READ_CAPACITY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_READ_CAPACITY>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_READ_CAPACITY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).BlockLength as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(BlockLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).NumberOfBlocks as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(NumberOfBlocks)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_READ_CAPACITY>())).DiskLength as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_READ_CAPACITY),
      "::",
      stringify!(DiskLength)
    )
  );
}
pub type STORAGE_READ_CAPACITY = _STORAGE_READ_CAPACITY;
pub const _WRITE_CACHE_TYPE_WriteCacheTypeUnknown: _WRITE_CACHE_TYPE = 0;
pub const _WRITE_CACHE_TYPE_WriteCacheTypeNone: _WRITE_CACHE_TYPE = 1;
pub const _WRITE_CACHE_TYPE_WriteCacheTypeWriteBack: _WRITE_CACHE_TYPE = 2;
pub const _WRITE_CACHE_TYPE_WriteCacheTypeWriteThrough: _WRITE_CACHE_TYPE = 3;
pub type _WRITE_CACHE_TYPE = ::std::os::raw::c_int;
pub use self::_WRITE_CACHE_TYPE as WRITE_CACHE_TYPE;
pub const _WRITE_CACHE_ENABLE_WriteCacheEnableUnknown: _WRITE_CACHE_ENABLE = 0;
pub const _WRITE_CACHE_ENABLE_WriteCacheDisabled: _WRITE_CACHE_ENABLE = 1;
pub const _WRITE_CACHE_ENABLE_WriteCacheEnabled: _WRITE_CACHE_ENABLE = 2;
pub type _WRITE_CACHE_ENABLE = ::std::os::raw::c_int;
pub use self::_WRITE_CACHE_ENABLE as WRITE_CACHE_ENABLE;
pub const _WRITE_CACHE_CHANGE_WriteCacheChangeUnknown: _WRITE_CACHE_CHANGE = 0;
pub const _WRITE_CACHE_CHANGE_WriteCacheNotChangeable: _WRITE_CACHE_CHANGE = 1;
pub const _WRITE_CACHE_CHANGE_WriteCacheChangeable: _WRITE_CACHE_CHANGE = 2;
pub type _WRITE_CACHE_CHANGE = ::std::os::raw::c_int;
pub use self::_WRITE_CACHE_CHANGE as WRITE_CACHE_CHANGE;
pub const _WRITE_THROUGH_WriteThroughUnknown: _WRITE_THROUGH = 0;
pub const _WRITE_THROUGH_WriteThroughNotSupported: _WRITE_THROUGH = 1;
pub const _WRITE_THROUGH_WriteThroughSupported: _WRITE_THROUGH = 2;
pub type _WRITE_THROUGH = ::std::os::raw::c_int;
pub use self::_WRITE_THROUGH as WRITE_THROUGH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_WRITE_CACHE_PROPERTY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub WriteCacheType: WRITE_CACHE_TYPE,
  pub WriteCacheEnabled: WRITE_CACHE_ENABLE,
  pub WriteCacheChangeable: WRITE_CACHE_CHANGE,
  pub WriteThroughSupported: WRITE_THROUGH,
  pub FlushCacheSupported: BOOLEAN,
  pub UserDefinedPowerProtection: BOOLEAN,
  pub NVCacheEnabled: BOOLEAN,
}
#[test]
fn bindgen_test_layout__STORAGE_WRITE_CACHE_PROPERTY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_WRITE_CACHE_PROPERTY>(),
    28usize,
    concat!("Size of: ", stringify!(_STORAGE_WRITE_CACHE_PROPERTY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_WRITE_CACHE_PROPERTY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_WRITE_CACHE_PROPERTY))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).WriteCacheType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(WriteCacheType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).WriteCacheEnabled as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(WriteCacheEnabled)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).WriteCacheChangeable as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(WriteCacheChangeable)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).WriteThroughSupported as *const _
        as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(WriteThroughSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).FlushCacheSupported as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(FlushCacheSupported)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).UserDefinedPowerProtection
        as *const _ as usize
    },
    25usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(UserDefinedPowerProtection)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_WRITE_CACHE_PROPERTY>())).NVCacheEnabled as *const _ as usize
    },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_WRITE_CACHE_PROPERTY),
      "::",
      stringify!(NVCacheEnabled)
    )
  );
}
pub type STORAGE_WRITE_CACHE_PROPERTY = _STORAGE_WRITE_CACHE_PROPERTY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDLE_POWER {
  pub Version: DWORD,
  pub Size: DWORD,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
  pub D3IdleTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_IDLE_POWER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_IDLE_POWER>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_IDLE_POWER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_IDLE_POWER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_IDLE_POWER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDLE_POWER>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDLE_POWER>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWER),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDLE_POWER>())).D3IdleTimeout as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWER),
      "::",
      stringify!(D3IdleTimeout)
    )
  );
}
impl _STORAGE_IDLE_POWER {
  #[inline]
  pub fn WakeCapableHint(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_WakeCapableHint(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn D3ColdSupported(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_D3ColdSupported(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
  }
  #[inline]
  pub fn set_Reserved(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(2usize, 30u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    WakeCapableHint: DWORD,
    D3ColdSupported: DWORD,
    Reserved: DWORD,
  ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let WakeCapableHint: u32 = unsafe { ::std::mem::transmute(WakeCapableHint) };
      WakeCapableHint as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let D3ColdSupported: u32 = unsafe { ::std::mem::transmute(D3ColdSupported) };
      D3ColdSupported as u64
    });
    __bindgen_bitfield_unit.set(2usize, 30u8, {
      let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
      Reserved as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type STORAGE_IDLE_POWER = _STORAGE_IDLE_POWER;
pub const _STORAGE_POWERUP_REASON_TYPE_StoragePowerupUnknown: _STORAGE_POWERUP_REASON_TYPE = 0;
pub const _STORAGE_POWERUP_REASON_TYPE_StoragePowerupIO: _STORAGE_POWERUP_REASON_TYPE = 1;
pub const _STORAGE_POWERUP_REASON_TYPE_StoragePowerupDeviceAttention: _STORAGE_POWERUP_REASON_TYPE =
  2;
pub type _STORAGE_POWERUP_REASON_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_POWERUP_REASON_TYPE as STORAGE_POWERUP_REASON_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_IDLE_POWERUP_REASON {
  pub Version: DWORD,
  pub Size: DWORD,
  pub PowerupReason: STORAGE_POWERUP_REASON_TYPE,
}
#[test]
fn bindgen_test_layout__STORAGE_IDLE_POWERUP_REASON() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_IDLE_POWERUP_REASON>(),
    12usize,
    concat!("Size of: ", stringify!(_STORAGE_IDLE_POWERUP_REASON))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_IDLE_POWERUP_REASON>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_IDLE_POWERUP_REASON))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_IDLE_POWERUP_REASON>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWERUP_REASON),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_IDLE_POWERUP_REASON>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWERUP_REASON),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_IDLE_POWERUP_REASON>())).PowerupReason as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_IDLE_POWERUP_REASON),
      "::",
      stringify!(PowerupReason)
    )
  );
}
pub type STORAGE_IDLE_POWERUP_REASON = _STORAGE_IDLE_POWERUP_REASON;
pub const _STORAGE_DEVICE_POWER_CAP_UNITS_StorageDevicePowerCapUnitsPercent:
  _STORAGE_DEVICE_POWER_CAP_UNITS = 0;
pub const _STORAGE_DEVICE_POWER_CAP_UNITS_StorageDevicePowerCapUnitsMilliwatts:
  _STORAGE_DEVICE_POWER_CAP_UNITS = 1;
pub type _STORAGE_DEVICE_POWER_CAP_UNITS = ::std::os::raw::c_int;
pub use self::_STORAGE_DEVICE_POWER_CAP_UNITS as STORAGE_DEVICE_POWER_CAP_UNITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_DEVICE_POWER_CAP {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Units: STORAGE_DEVICE_POWER_CAP_UNITS,
  pub MaxPower: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_DEVICE_POWER_CAP() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_DEVICE_POWER_CAP>(),
    24usize,
    concat!("Size of: ", stringify!(_STORAGE_DEVICE_POWER_CAP))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_DEVICE_POWER_CAP>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_DEVICE_POWER_CAP))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_POWER_CAP>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_POWER_CAP),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_POWER_CAP>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_POWER_CAP),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_POWER_CAP>())).Units as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_POWER_CAP),
      "::",
      stringify!(Units)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_DEVICE_POWER_CAP>())).MaxPower as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_DEVICE_POWER_CAP),
      "::",
      stringify!(MaxPower)
    )
  );
}
pub type STORAGE_DEVICE_POWER_CAP = _STORAGE_DEVICE_POWER_CAP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_RPMB_DATA_FRAME {
  pub Stuff: [BYTE; 196usize],
  pub KeyOrMAC: [BYTE; 32usize],
  pub Data: [BYTE; 256usize],
  pub Nonce: [BYTE; 16usize],
  pub WriteCounter: [BYTE; 4usize],
  pub Address: [BYTE; 2usize],
  pub BlockCount: [BYTE; 2usize],
  pub OperationResult: [BYTE; 2usize],
  pub RequestOrResponseType: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout__STORAGE_RPMB_DATA_FRAME() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_RPMB_DATA_FRAME>(),
    512usize,
    concat!("Size of: ", stringify!(_STORAGE_RPMB_DATA_FRAME))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_RPMB_DATA_FRAME>(),
    1usize,
    concat!("Alignment of ", stringify!(_STORAGE_RPMB_DATA_FRAME))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).Stuff as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(Stuff)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).KeyOrMAC as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(KeyOrMAC)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).Data as *const _ as usize },
    228usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(Data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).Nonce as *const _ as usize },
    484usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(Nonce)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).WriteCounter as *const _ as usize
    },
    500usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(WriteCounter)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).Address as *const _ as usize },
    504usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(Address)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).BlockCount as *const _ as usize },
    506usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(BlockCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).OperationResult as *const _ as usize
    },
    508usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(OperationResult)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_RPMB_DATA_FRAME>())).RequestOrResponseType as *const _
        as usize
    },
    510usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_RPMB_DATA_FRAME),
      "::",
      stringify!(RequestOrResponseType)
    )
  );
}
pub type STORAGE_RPMB_DATA_FRAME = _STORAGE_RPMB_DATA_FRAME;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbProgramAuthKey: _STORAGE_RPMB_COMMAND_TYPE = 1;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbQueryWriteCounter: _STORAGE_RPMB_COMMAND_TYPE = 2;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbAuthenticatedWrite: _STORAGE_RPMB_COMMAND_TYPE = 3;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbAuthenticatedRead: _STORAGE_RPMB_COMMAND_TYPE = 4;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbReadResultRequest: _STORAGE_RPMB_COMMAND_TYPE = 5;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbAuthenticatedDeviceConfigWrite:
  _STORAGE_RPMB_COMMAND_TYPE = 6;
pub const _STORAGE_RPMB_COMMAND_TYPE_StorRpmbAuthenticatedDeviceConfigRead:
  _STORAGE_RPMB_COMMAND_TYPE = 7;
pub type _STORAGE_RPMB_COMMAND_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_RPMB_COMMAND_TYPE as STORAGE_RPMB_COMMAND_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_EVENT_NOTIFICATION {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Events: DWORDLONG,
}
#[test]
fn bindgen_test_layout__STORAGE_EVENT_NOTIFICATION() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_EVENT_NOTIFICATION>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_EVENT_NOTIFICATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_EVENT_NOTIFICATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_EVENT_NOTIFICATION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_EVENT_NOTIFICATION>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_EVENT_NOTIFICATION),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_EVENT_NOTIFICATION>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_EVENT_NOTIFICATION),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_EVENT_NOTIFICATION>())).Events as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_EVENT_NOTIFICATION),
      "::",
      stringify!(Events)
    )
  );
}
pub type STORAGE_EVENT_NOTIFICATION = _STORAGE_EVENT_NOTIFICATION;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeUnknown: _STORAGE_COUNTER_TYPE = 0;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeTemperatureCelsius: _STORAGE_COUNTER_TYPE = 1;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeTemperatureCelsiusMax: _STORAGE_COUNTER_TYPE = 2;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeReadErrorsTotal: _STORAGE_COUNTER_TYPE = 3;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeReadErrorsCorrected: _STORAGE_COUNTER_TYPE = 4;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeReadErrorsUncorrected: _STORAGE_COUNTER_TYPE = 5;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWriteErrorsTotal: _STORAGE_COUNTER_TYPE = 6;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWriteErrorsCorrected: _STORAGE_COUNTER_TYPE = 7;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWriteErrorsUncorrected: _STORAGE_COUNTER_TYPE = 8;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeManufactureDate: _STORAGE_COUNTER_TYPE = 9;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeStartStopCycleCount: _STORAGE_COUNTER_TYPE = 10;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeStartStopCycleCountMax: _STORAGE_COUNTER_TYPE =
  11;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeLoadUnloadCycleCount: _STORAGE_COUNTER_TYPE = 12;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeLoadUnloadCycleCountMax: _STORAGE_COUNTER_TYPE =
  13;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWearPercentage: _STORAGE_COUNTER_TYPE = 14;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWearPercentageWarning: _STORAGE_COUNTER_TYPE = 15;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWearPercentageMax: _STORAGE_COUNTER_TYPE = 16;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypePowerOnHours: _STORAGE_COUNTER_TYPE = 17;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeReadLatency100NSMax: _STORAGE_COUNTER_TYPE = 18;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeWriteLatency100NSMax: _STORAGE_COUNTER_TYPE = 19;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeFlushLatency100NSMax: _STORAGE_COUNTER_TYPE = 20;
pub const _STORAGE_COUNTER_TYPE_StorageCounterTypeMax: _STORAGE_COUNTER_TYPE = 21;
pub type _STORAGE_COUNTER_TYPE = ::std::os::raw::c_int;
pub use self::_STORAGE_COUNTER_TYPE as STORAGE_COUNTER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_COUNTER {
  pub Type: STORAGE_COUNTER_TYPE,
  pub Value: _STORAGE_COUNTER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STORAGE_COUNTER__bindgen_ty_1 {
  pub ManufactureDate: _STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1,
  pub AsUlonglong: DWORDLONG,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1 {
  pub Week: DWORD,
  pub Year: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1>())).Week as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Week)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1>())).Year as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Year)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_COUNTER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_COUNTER__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(_STORAGE_COUNTER__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_COUNTER__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_COUNTER__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_COUNTER__bindgen_ty_1>())).ManufactureDate as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1),
      "::",
      stringify!(ManufactureDate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_COUNTER__bindgen_ty_1>())).AsUlonglong as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER__bindgen_ty_1),
      "::",
      stringify!(AsUlonglong)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_COUNTER() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_COUNTER>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_COUNTER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_COUNTER>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_COUNTER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTER>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTER>())).Value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTER),
      "::",
      stringify!(Value)
    )
  );
}
pub type STORAGE_COUNTER = _STORAGE_COUNTER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STORAGE_COUNTERS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfCounters: DWORD,
  pub Counters: [STORAGE_COUNTER; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_COUNTERS() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_COUNTERS>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_COUNTERS))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_COUNTERS>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_COUNTERS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTERS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTERS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTERS>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTERS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTERS>())).NumberOfCounters as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTERS),
      "::",
      stringify!(NumberOfCounters)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_COUNTERS>())).Counters as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_COUNTERS),
      "::",
      stringify!(Counters)
    )
  );
}
pub type STORAGE_COUNTERS = _STORAGE_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_INFO_QUERY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_INFO_QUERY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_INFO_QUERY>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_INFO_QUERY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO_QUERY>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO_QUERY>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO_QUERY>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO_QUERY>())).Reserved as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO_QUERY),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type STORAGE_HW_FIRMWARE_INFO_QUERY = _STORAGE_HW_FIRMWARE_INFO_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_SLOT_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub SlotNumber: BYTE,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub Reserved1: [BYTE; 6usize],
  pub Revision: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_SLOT_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_SLOT_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_SLOT_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).SlotNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(SlotNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).Reserved1 as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_SLOT_INFO>())).Revision as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Revision)
    )
  );
}
impl _STORAGE_HW_FIRMWARE_SLOT_INFO {
  #[inline]
  pub fn ReadOnly(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_ReadOnly(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 7u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    ReadOnly: BYTE,
    Reserved0: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let ReadOnly: u8 = unsafe { ::std::mem::transmute(ReadOnly) };
      ReadOnly as u64
    });
    __bindgen_bitfield_unit.set(1usize, 7u8, {
      let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type STORAGE_HW_FIRMWARE_SLOT_INFO = _STORAGE_HW_FIRMWARE_SLOT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub SlotCount: BYTE,
  pub ActiveSlot: BYTE,
  pub PendingActivateSlot: BYTE,
  pub FirmwareShared: BOOLEAN,
  pub Reserved: [BYTE; 3usize],
  pub ImagePayloadAlignment: DWORD,
  pub ImagePayloadMaxSize: DWORD,
  pub Slot: [STORAGE_HW_FIRMWARE_SLOT_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_INFO>(),
    56usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).SlotCount as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(SlotCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).ActiveSlot as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(ActiveSlot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).PendingActivateSlot as *const _ as usize
    },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(PendingActivateSlot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).FirmwareShared as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(FirmwareShared)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).Reserved as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).ImagePayloadAlignment as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(ImagePayloadAlignment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).ImagePayloadMaxSize as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(ImagePayloadMaxSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_INFO>())).Slot as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_INFO),
      "::",
      stringify!(Slot)
    )
  );
}
impl _STORAGE_HW_FIRMWARE_INFO {
  #[inline]
  pub fn SupportUpgrade(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_SupportUpgrade(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 7u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    SupportUpgrade: BYTE,
    Reserved0: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let SupportUpgrade: u8 = unsafe { ::std::mem::transmute(SupportUpgrade) };
      SupportUpgrade as u64
    });
    __bindgen_bitfield_unit.set(1usize, 7u8, {
      let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type STORAGE_HW_FIRMWARE_INFO = _STORAGE_HW_FIRMWARE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_DOWNLOAD {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
  pub Reserved: [BYTE; 3usize],
  pub Offset: DWORDLONG,
  pub BufferSize: DWORDLONG,
  pub ImageBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_DOWNLOAD() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_DOWNLOAD>(),
    40usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_DOWNLOAD>(),
    8usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Slot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Reserved as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).Offset as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).BufferSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(BufferSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD>())).ImageBuffer as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(ImageBuffer)
    )
  );
}
pub type STORAGE_HW_FIRMWARE_DOWNLOAD = _STORAGE_HW_FIRMWARE_DOWNLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_DOWNLOAD_V2 {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
  pub Reserved: [BYTE; 3usize],
  pub Offset: DWORDLONG,
  pub BufferSize: DWORDLONG,
  pub ImageSize: DWORD,
  pub Reserved2: DWORD,
  pub ImageBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_DOWNLOAD_V2() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>(),
    48usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Flags as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Slot as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Reserved as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Offset as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).BufferSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(BufferSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).ImageSize as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(ImageSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).Reserved2 as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(Reserved2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_DOWNLOAD_V2>())).ImageBuffer as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_DOWNLOAD_V2),
      "::",
      stringify!(ImageBuffer)
    )
  );
}
pub type STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = _STORAGE_HW_FIRMWARE_DOWNLOAD_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_HW_FIRMWARE_ACTIVATE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
  pub Reserved0: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__STORAGE_HW_FIRMWARE_ACTIVATE() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_HW_FIRMWARE_ACTIVATE>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_HW_FIRMWARE_ACTIVATE>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Slot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_HW_FIRMWARE_ACTIVATE>())).Reserved0 as *const _ as usize
    },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_HW_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Reserved0)
    )
  );
}
pub type STORAGE_HW_FIRMWARE_ACTIVATE = _STORAGE_HW_FIRMWARE_ACTIVATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_PROTOCOL_COMMAND {
  pub Version: DWORD,
  pub Length: DWORD,
  pub ProtocolType: STORAGE_PROTOCOL_TYPE,
  pub Flags: DWORD,
  pub ReturnStatus: DWORD,
  pub ErrorCode: DWORD,
  pub CommandLength: DWORD,
  pub ErrorInfoLength: DWORD,
  pub DataToDeviceTransferLength: DWORD,
  pub DataFromDeviceTransferLength: DWORD,
  pub TimeOutValue: DWORD,
  pub ErrorInfoOffset: DWORD,
  pub DataToDeviceBufferOffset: DWORD,
  pub DataFromDeviceBufferOffset: DWORD,
  pub CommandSpecific: DWORD,
  pub Reserved0: DWORD,
  pub FixedProtocolReturnData: DWORD,
  pub Reserved1: [DWORD; 3usize],
  pub Command: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__STORAGE_PROTOCOL_COMMAND() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_PROTOCOL_COMMAND>(),
    84usize,
    concat!("Size of: ", stringify!(_STORAGE_PROTOCOL_COMMAND))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_PROTOCOL_COMMAND>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_PROTOCOL_COMMAND))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Length as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ProtocolType as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ProtocolType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Flags as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ReturnStatus as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ReturnStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ErrorCode as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ErrorCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).CommandLength as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(CommandLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ErrorInfoLength as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ErrorInfoLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).DataToDeviceTransferLength as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(DataToDeviceTransferLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).DataFromDeviceTransferLength as *const _
        as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(DataFromDeviceTransferLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).TimeOutValue as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(TimeOutValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).ErrorInfoOffset as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(ErrorInfoOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).DataToDeviceBufferOffset as *const _
        as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(DataToDeviceBufferOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).DataFromDeviceBufferOffset as *const _
        as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(DataFromDeviceBufferOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).CommandSpecific as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(CommandSpecific)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Reserved0 as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Reserved0)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).FixedProtocolReturnData as *const _
        as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(FixedProtocolReturnData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Reserved1 as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_PROTOCOL_COMMAND>())).Command as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_PROTOCOL_COMMAND),
      "::",
      stringify!(Command)
    )
  );
}
pub type STORAGE_PROTOCOL_COMMAND = _STORAGE_PROTOCOL_COMMAND;
pub const _STORAGE_ATTRIBUTE_MGMT_ACTION_StorAttributeMgmt_ClearAttribute:
  _STORAGE_ATTRIBUTE_MGMT_ACTION = 0;
pub const _STORAGE_ATTRIBUTE_MGMT_ACTION_StorAttributeMgmt_SetAttribute:
  _STORAGE_ATTRIBUTE_MGMT_ACTION = 1;
pub const _STORAGE_ATTRIBUTE_MGMT_ACTION_StorAttributeMgmt_ResetAttribute:
  _STORAGE_ATTRIBUTE_MGMT_ACTION = 2;
pub type _STORAGE_ATTRIBUTE_MGMT_ACTION = ::std::os::raw::c_int;
pub use self::_STORAGE_ATTRIBUTE_MGMT_ACTION as STORAGE_ATTRIBUTE_MGMT_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_ATTRIBUTE_MGMT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Action: STORAGE_ATTRIBUTE_MGMT_ACTION,
  pub Attribute: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_ATTRIBUTE_MGMT() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_ATTRIBUTE_MGMT>(),
    16usize,
    concat!("Size of: ", stringify!(_STORAGE_ATTRIBUTE_MGMT))
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_ATTRIBUTE_MGMT>(),
    4usize,
    concat!("Alignment of ", stringify!(_STORAGE_ATTRIBUTE_MGMT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ATTRIBUTE_MGMT>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ATTRIBUTE_MGMT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ATTRIBUTE_MGMT>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ATTRIBUTE_MGMT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ATTRIBUTE_MGMT>())).Action as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ATTRIBUTE_MGMT),
      "::",
      stringify!(Action)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STORAGE_ATTRIBUTE_MGMT>())).Attribute as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_ATTRIBUTE_MGMT),
      "::",
      stringify!(Attribute)
    )
  );
}
pub type STORAGE_ATTRIBUTE_MGMT = _STORAGE_ATTRIBUTE_MGMT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_HEALTH_NOTIFICATION_DATA {
  pub DeviceGuid: GUID,
}
#[test]
fn bindgen_test_layout__SCM_PD_HEALTH_NOTIFICATION_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_HEALTH_NOTIFICATION_DATA>(),
    16usize,
    concat!("Size of: ", stringify!(_SCM_PD_HEALTH_NOTIFICATION_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_HEALTH_NOTIFICATION_DATA>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_HEALTH_NOTIFICATION_DATA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_HEALTH_NOTIFICATION_DATA>())).DeviceGuid as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_HEALTH_NOTIFICATION_DATA),
      "::",
      stringify!(DeviceGuid)
    )
  );
}
pub type SCM_PD_HEALTH_NOTIFICATION_DATA = _SCM_PD_HEALTH_NOTIFICATION_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_LOGICAL_DEVICE_INSTANCE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceGuid: GUID,
  pub SymbolicLink: [WCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__SCM_LOGICAL_DEVICE_INSTANCE() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_LOGICAL_DEVICE_INSTANCE>(),
    536usize,
    concat!("Size of: ", stringify!(_SCM_LOGICAL_DEVICE_INSTANCE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_LOGICAL_DEVICE_INSTANCE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_LOGICAL_DEVICE_INSTANCE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICE_INSTANCE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICE_INSTANCE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICE_INSTANCE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICE_INSTANCE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICE_INSTANCE>())).DeviceGuid as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICE_INSTANCE),
      "::",
      stringify!(DeviceGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICE_INSTANCE>())).SymbolicLink as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICE_INSTANCE),
      "::",
      stringify!(SymbolicLink)
    )
  );
}
pub type SCM_LOGICAL_DEVICE_INSTANCE = _SCM_LOGICAL_DEVICE_INSTANCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_LOGICAL_DEVICES {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceCount: DWORD,
  pub Devices: [SCM_LOGICAL_DEVICE_INSTANCE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_LOGICAL_DEVICES() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_LOGICAL_DEVICES>(),
    548usize,
    concat!("Size of: ", stringify!(_SCM_LOGICAL_DEVICES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_LOGICAL_DEVICES>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_LOGICAL_DEVICES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICES>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICES),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICES>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICES),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICES>())).DeviceCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICES),
      "::",
      stringify!(DeviceCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LOGICAL_DEVICES>())).Devices as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LOGICAL_DEVICES),
      "::",
      stringify!(Devices)
    )
  );
}
pub type SCM_LOGICAL_DEVICES = _SCM_LOGICAL_DEVICES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_PHYSICAL_DEVICE_INSTANCE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NfitHandle: DWORD,
  pub SymbolicLink: [WCHAR; 256usize],
}
#[test]
fn bindgen_test_layout__SCM_PHYSICAL_DEVICE_INSTANCE() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PHYSICAL_DEVICE_INSTANCE>(),
    524usize,
    concat!("Size of: ", stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PHYSICAL_DEVICE_INSTANCE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICE_INSTANCE>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICE_INSTANCE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICE_INSTANCE>())).NfitHandle as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE),
      "::",
      stringify!(NfitHandle)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICE_INSTANCE>())).SymbolicLink as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICE_INSTANCE),
      "::",
      stringify!(SymbolicLink)
    )
  );
}
pub type SCM_PHYSICAL_DEVICE_INSTANCE = _SCM_PHYSICAL_DEVICE_INSTANCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_PHYSICAL_DEVICES {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceCount: DWORD,
  pub Devices: [SCM_PHYSICAL_DEVICE_INSTANCE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PHYSICAL_DEVICES() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PHYSICAL_DEVICES>(),
    536usize,
    concat!("Size of: ", stringify!(_SCM_PHYSICAL_DEVICES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PHYSICAL_DEVICES>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PHYSICAL_DEVICES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICES>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICES),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICES>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICES),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICES>())).DeviceCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICES),
      "::",
      stringify!(DeviceCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PHYSICAL_DEVICES>())).Devices as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PHYSICAL_DEVICES),
      "::",
      stringify!(Devices)
    )
  );
}
pub type SCM_PHYSICAL_DEVICES = _SCM_PHYSICAL_DEVICES;
pub const _SCM_REGION_FLAG_ScmRegionFlagNone: _SCM_REGION_FLAG = 0;
pub const _SCM_REGION_FLAG_ScmRegionFlagLabel: _SCM_REGION_FLAG = 1;
pub type _SCM_REGION_FLAG = ::std::os::raw::c_int;
pub use self::_SCM_REGION_FLAG as SCM_REGION_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_REGION {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub NfitHandle: DWORD,
  pub LogicalDeviceGuid: GUID,
  pub AddressRangeType: GUID,
  pub AssociatedId: DWORD,
  pub Length: DWORD64,
  pub StartingDPA: DWORD64,
  pub BaseSPA: DWORD64,
  pub SPAOffset: DWORD64,
  pub RegionOffset: DWORD64,
}
#[test]
fn bindgen_test_layout__SCM_REGION() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_REGION>(),
    96usize,
    concat!("Size of: ", stringify!(_SCM_REGION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_REGION>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_REGION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).NfitHandle as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(NfitHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).LogicalDeviceGuid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(LogicalDeviceGuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).AddressRangeType as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(AddressRangeType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).AssociatedId as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(AssociatedId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).Length as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).StartingDPA as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(StartingDPA)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).BaseSPA as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(BaseSPA)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).SPAOffset as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(SPAOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGION>())).RegionOffset as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGION),
      "::",
      stringify!(RegionOffset)
    )
  );
}
pub type SCM_REGION = _SCM_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_REGIONS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub RegionCount: DWORD,
  pub Regions: [SCM_REGION; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_REGIONS() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_REGIONS>(),
    112usize,
    concat!("Size of: ", stringify!(_SCM_REGIONS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_REGIONS>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_REGIONS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGIONS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGIONS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGIONS>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGIONS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGIONS>())).RegionCount as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGIONS),
      "::",
      stringify!(RegionCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_REGIONS>())).Regions as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_REGIONS),
      "::",
      stringify!(Regions)
    )
  );
}
pub type SCM_REGIONS = _SCM_REGIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_INTERLEAVED_PD_INFO {
  pub DeviceHandle: DWORD,
  pub DeviceGuid: GUID,
}
#[test]
fn bindgen_test_layout__SCM_INTERLEAVED_PD_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_INTERLEAVED_PD_INFO>(),
    20usize,
    concat!("Size of: ", stringify!(_SCM_INTERLEAVED_PD_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_INTERLEAVED_PD_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_INTERLEAVED_PD_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_INTERLEAVED_PD_INFO>())).DeviceHandle as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_INTERLEAVED_PD_INFO),
      "::",
      stringify!(DeviceHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_INTERLEAVED_PD_INFO>())).DeviceGuid as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_INTERLEAVED_PD_INFO),
      "::",
      stringify!(DeviceGuid)
    )
  );
}
pub type SCM_INTERLEAVED_PD_INFO = _SCM_INTERLEAVED_PD_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_LD_INTERLEAVE_SET_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub InterleaveSetSize: DWORD,
  pub InterleaveSet: [SCM_INTERLEAVED_PD_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_LD_INTERLEAVE_SET_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_LD_INTERLEAVE_SET_INFO>(),
    32usize,
    concat!("Size of: ", stringify!(_SCM_LD_INTERLEAVE_SET_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_LD_INTERLEAVE_SET_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_LD_INTERLEAVE_SET_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LD_INTERLEAVE_SET_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LD_INTERLEAVE_SET_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_LD_INTERLEAVE_SET_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LD_INTERLEAVE_SET_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LD_INTERLEAVE_SET_INFO>())).InterleaveSetSize as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LD_INTERLEAVE_SET_INFO),
      "::",
      stringify!(InterleaveSetSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_LD_INTERLEAVE_SET_INFO>())).InterleaveSet as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_LD_INTERLEAVE_SET_INFO),
      "::",
      stringify!(InterleaveSet)
    )
  );
}
pub type SCM_LD_INTERLEAVE_SET_INFO = _SCM_LD_INTERLEAVE_SET_INFO;
pub const _SCM_PD_QUERY_TYPE_ScmPhysicalDeviceQuery_Descriptor: _SCM_PD_QUERY_TYPE = 0;
pub const _SCM_PD_QUERY_TYPE_ScmPhysicalDeviceQuery_IsSupported: _SCM_PD_QUERY_TYPE = 1;
pub const _SCM_PD_QUERY_TYPE_ScmPhysicalDeviceQuery_Max: _SCM_PD_QUERY_TYPE = 2;
pub type _SCM_PD_QUERY_TYPE = ::std::os::raw::c_int;
pub use self::_SCM_PD_QUERY_TYPE as SCM_PD_QUERY_TYPE;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_DeviceInfo: _SCM_PD_PROPERTY_ID = 0;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_ManagementStatus: _SCM_PD_PROPERTY_ID = 1;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_FirmwareInfo: _SCM_PD_PROPERTY_ID = 2;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_LocationString: _SCM_PD_PROPERTY_ID = 3;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_DeviceSpecificInfo: _SCM_PD_PROPERTY_ID = 4;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_DeviceHandle: _SCM_PD_PROPERTY_ID = 5;
pub const _SCM_PD_PROPERTY_ID_ScmPhysicalDeviceProperty_Max: _SCM_PD_PROPERTY_ID = 6;
pub type _SCM_PD_PROPERTY_ID = ::std::os::raw::c_int;
pub use self::_SCM_PD_PROPERTY_ID as SCM_PD_PROPERTY_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PROPERTY_QUERY {
  pub Version: DWORD,
  pub Size: DWORD,
  pub PropertyId: SCM_PD_PROPERTY_ID,
  pub QueryType: SCM_PD_QUERY_TYPE,
  pub AdditionalParameters: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PROPERTY_QUERY() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PROPERTY_QUERY>(),
    20usize,
    concat!("Size of: ", stringify!(_SCM_PD_PROPERTY_QUERY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PROPERTY_QUERY>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_PROPERTY_QUERY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).PropertyId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(PropertyId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).QueryType as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(QueryType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PROPERTY_QUERY>())).AdditionalParameters as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PROPERTY_QUERY),
      "::",
      stringify!(AdditionalParameters)
    )
  );
}
pub type SCM_PD_PROPERTY_QUERY = _SCM_PD_PROPERTY_QUERY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DESCRIPTOR_HEADER {
  pub Version: DWORD,
  pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__SCM_PD_DESCRIPTOR_HEADER() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DESCRIPTOR_HEADER>(),
    8usize,
    concat!("Size of: ", stringify!(_SCM_PD_DESCRIPTOR_HEADER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DESCRIPTOR_HEADER>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_DESCRIPTOR_HEADER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DESCRIPTOR_HEADER>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DESCRIPTOR_HEADER),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DESCRIPTOR_HEADER>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DESCRIPTOR_HEADER),
      "::",
      stringify!(Size)
    )
  );
}
pub type SCM_PD_DESCRIPTOR_HEADER = _SCM_PD_DESCRIPTOR_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DEVICE_HANDLE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceGuid: GUID,
  pub DeviceHandle: DWORD,
}
#[test]
fn bindgen_test_layout__SCM_PD_DEVICE_HANDLE() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DEVICE_HANDLE>(),
    28usize,
    concat!("Size of: ", stringify!(_SCM_PD_DEVICE_HANDLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DEVICE_HANDLE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_DEVICE_HANDLE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_HANDLE>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_HANDLE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_HANDLE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_HANDLE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_HANDLE>())).DeviceGuid as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_HANDLE),
      "::",
      stringify!(DeviceGuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_HANDLE>())).DeviceHandle as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_HANDLE),
      "::",
      stringify!(DeviceHandle)
    )
  );
}
pub type SCM_PD_DEVICE_HANDLE = _SCM_PD_DEVICE_HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_DEVICE_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub DeviceGuid: GUID,
  pub UnsafeShutdownCount: DWORD,
  pub PersistentMemorySizeInBytes: DWORD64,
  pub VolatileMemorySizeInBytes: DWORD64,
  pub TotalMemorySizeInBytes: DWORD64,
  pub SlotNumber: DWORD,
  pub DeviceHandle: DWORD,
  pub PhysicalId: WORD,
  pub NumberOfFormatInterfaceCodes: BYTE,
  pub FormatInterfaceCodes: [WORD; 8usize],
  pub VendorId: DWORD,
  pub ProductId: DWORD,
  pub SubsystemDeviceId: DWORD,
  pub SubsystemVendorId: DWORD,
  pub ManufacturingLocation: BYTE,
  pub ManufacturingWeek: BYTE,
  pub ManufacturingYear: BYTE,
  pub SerialNumber4Byte: DWORD,
  pub SerialNumberLengthInChars: DWORD,
  pub SerialNumber: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_DEVICE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DEVICE_INFO>(),
    120usize,
    concat!("Size of: ", stringify!(_SCM_PD_DEVICE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DEVICE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_PD_DEVICE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).DeviceGuid as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(DeviceGuid)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).UnsafeShutdownCount as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(UnsafeShutdownCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).PersistentMemorySizeInBytes as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(PersistentMemorySizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).VolatileMemorySizeInBytes as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(VolatileMemorySizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).TotalMemorySizeInBytes as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(TotalMemorySizeInBytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SlotNumber as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SlotNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).DeviceHandle as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(DeviceHandle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).PhysicalId as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(PhysicalId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).NumberOfFormatInterfaceCodes as *const _
        as usize
    },
    66usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(NumberOfFormatInterfaceCodes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).FormatInterfaceCodes as *const _ as usize
    },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(FormatInterfaceCodes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).VendorId as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(VendorId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).ProductId as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(ProductId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SubsystemDeviceId as *const _ as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SubsystemDeviceId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SubsystemVendorId as *const _ as usize
    },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SubsystemVendorId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).ManufacturingLocation as *const _ as usize
    },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(ManufacturingLocation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).ManufacturingWeek as *const _ as usize
    },
    101usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(ManufacturingWeek)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).ManufacturingYear as *const _ as usize
    },
    102usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(ManufacturingYear)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SerialNumber4Byte as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SerialNumber4Byte)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SerialNumberLengthInChars as *const _ as usize
    },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SerialNumberLengthInChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_INFO>())).SerialNumber as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_INFO),
      "::",
      stringify!(SerialNumber)
    )
  );
}
pub type SCM_PD_DEVICE_INFO = _SCM_PD_DEVICE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_PD_DEVICE_SPECIFIC_PROPERTY {
  pub Name: [WCHAR; 128usize],
  pub Value: LONGLONG,
}
#[test]
fn bindgen_test_layout__SCM_PD_DEVICE_SPECIFIC_PROPERTY() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DEVICE_SPECIFIC_PROPERTY>(),
    264usize,
    concat!("Size of: ", stringify!(_SCM_PD_DEVICE_SPECIFIC_PROPERTY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DEVICE_SPECIFIC_PROPERTY>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_PROPERTY)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_PROPERTY>())).Name as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_PROPERTY),
      "::",
      stringify!(Name)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_PROPERTY>())).Value as *const _ as usize
    },
    256usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_PROPERTY),
      "::",
      stringify!(Value)
    )
  );
}
pub type SCM_PD_DEVICE_SPECIFIC_PROPERTY = _SCM_PD_DEVICE_SPECIFIC_PROPERTY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCM_PD_DEVICE_SPECIFIC_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub NumberOfProperties: DWORD,
  pub DeviceSpecificProperties: [SCM_PD_DEVICE_SPECIFIC_PROPERTY; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_DEVICE_SPECIFIC_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_DEVICE_SPECIFIC_INFO>(),
    280usize,
    concat!("Size of: ", stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_DEVICE_SPECIFIC_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_INFO>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_INFO>())).NumberOfProperties as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO),
      "::",
      stringify!(NumberOfProperties)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_DEVICE_SPECIFIC_INFO>())).DeviceSpecificProperties as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_DEVICE_SPECIFIC_INFO),
      "::",
      stringify!(DeviceSpecificProperties)
    )
  );
}
pub type SCM_PD_DEVICE_SPECIFIC_INFO = _SCM_PD_DEVICE_SPECIFIC_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_SLOT_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub SlotNumber: BYTE,
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub Reserved1: [BYTE; 6usize],
  pub Revision: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_FIRMWARE_SLOT_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_FIRMWARE_SLOT_INFO>(),
    48usize,
    concat!("Size of: ", stringify!(_SCM_PD_FIRMWARE_SLOT_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_FIRMWARE_SLOT_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_FIRMWARE_SLOT_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).SlotNumber as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(SlotNumber)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).Reserved1 as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_SLOT_INFO>())).Revision as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_SLOT_INFO),
      "::",
      stringify!(Revision)
    )
  );
}
impl _SCM_PD_FIRMWARE_SLOT_INFO {
  #[inline]
  pub fn ReadOnly(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
  }
  #[inline]
  pub fn set_ReadOnly(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn Reserved0(&self) -> BYTE {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
  }
  #[inline]
  pub fn set_Reserved0(&mut self, val: BYTE) {
    unsafe {
      let val: u8 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 7u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(
    ReadOnly: BYTE,
    Reserved0: BYTE,
  ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let ReadOnly: u8 = unsafe { ::std::mem::transmute(ReadOnly) };
      ReadOnly as u64
    });
    __bindgen_bitfield_unit.set(1usize, 7u8, {
      let Reserved0: u8 = unsafe { ::std::mem::transmute(Reserved0) };
      Reserved0 as u64
    });
    __bindgen_bitfield_unit
  }
}
pub type SCM_PD_FIRMWARE_SLOT_INFO = _SCM_PD_FIRMWARE_SLOT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_INFO {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ActiveSlot: BYTE,
  pub NextActiveSlot: BYTE,
  pub SlotCount: BYTE,
  pub Slots: [SCM_PD_FIRMWARE_SLOT_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_FIRMWARE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_FIRMWARE_INFO>(),
    60usize,
    concat!("Size of: ", stringify!(_SCM_PD_FIRMWARE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_FIRMWARE_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_FIRMWARE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).ActiveSlot as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(ActiveSlot)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).NextActiveSlot as *const _ as usize
    },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(NextActiveSlot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).SlotCount as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(SlotCount)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_INFO>())).Slots as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_INFO),
      "::",
      stringify!(Slots)
    )
  );
}
pub type SCM_PD_FIRMWARE_INFO = _SCM_PD_FIRMWARE_INFO;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Unknown: _SCM_PD_HEALTH_STATUS = 0;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Unhealthy: _SCM_PD_HEALTH_STATUS = 1;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Warning: _SCM_PD_HEALTH_STATUS = 2;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Healthy: _SCM_PD_HEALTH_STATUS = 3;
pub const _SCM_PD_HEALTH_STATUS_ScmPhysicalDeviceHealth_Max: _SCM_PD_HEALTH_STATUS = 4;
pub type _SCM_PD_HEALTH_STATUS = ::std::os::raw::c_int;
pub use self::_SCM_PD_HEALTH_STATUS as SCM_PD_HEALTH_STATUS;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_Unknown: _SCM_PD_OPERATIONAL_STATUS =
  0;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_Ok: _SCM_PD_OPERATIONAL_STATUS = 1;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_PredictingFailure:
  _SCM_PD_OPERATIONAL_STATUS = 2;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_InService:
  _SCM_PD_OPERATIONAL_STATUS = 3;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_HardwareError:
  _SCM_PD_OPERATIONAL_STATUS = 4;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_NotUsable:
  _SCM_PD_OPERATIONAL_STATUS = 5;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_TransientError:
  _SCM_PD_OPERATIONAL_STATUS = 6;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_Missing: _SCM_PD_OPERATIONAL_STATUS =
  7;
pub const _SCM_PD_OPERATIONAL_STATUS_ScmPhysicalDeviceOpStatus_Max: _SCM_PD_OPERATIONAL_STATUS = 8;
pub type _SCM_PD_OPERATIONAL_STATUS = ::std::os::raw::c_int;
pub use self::_SCM_PD_OPERATIONAL_STATUS as SCM_PD_OPERATIONAL_STATUS;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Unknown:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 0;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Media:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 1;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_ThresholdExceeded:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 2;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_LostData:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 3;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_EnergySource:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 4;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Configuration:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 5;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_DeviceController:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 6;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_MediaController:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 7;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Component:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 8;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_BackgroundOperation:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 9;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_InvalidFirmware:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 10;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_HealthCheck:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 11;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_LostDataPersistence:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 12;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_DisabledByPlatform:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 13;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_PermanentError:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 14;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_LostWritePersistence:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 15;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_FatalError:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 16;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_DataPersistenceLossImminent : _SCM_PD_OPERATIONAL_STATUS_REASON = 17 ;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_WritePersistenceLossImminent : _SCM_PD_OPERATIONAL_STATUS_REASON = 18 ;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 19;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_PerformanceDegradation:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 20;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_ExcessiveTemperature:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 21;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON_ScmPhysicalDeviceOpReason_Max:
  _SCM_PD_OPERATIONAL_STATUS_REASON = 22;
pub type _SCM_PD_OPERATIONAL_STATUS_REASON = ::std::os::raw::c_int;
pub use self::_SCM_PD_OPERATIONAL_STATUS_REASON as SCM_PD_OPERATIONAL_STATUS_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_MANAGEMENT_STATUS {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Health: SCM_PD_HEALTH_STATUS,
  pub NumberOfOperationalStatus: DWORD,
  pub NumberOfAdditionalReasons: DWORD,
  pub OperationalStatus: [SCM_PD_OPERATIONAL_STATUS; 16usize],
  pub AdditionalReasons: [SCM_PD_OPERATIONAL_STATUS_REASON; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_MANAGEMENT_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_MANAGEMENT_STATUS>(),
    88usize,
    concat!("Size of: ", stringify!(_SCM_PD_MANAGEMENT_STATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_MANAGEMENT_STATUS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_MANAGEMENT_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).Health as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(Health)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).NumberOfOperationalStatus as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(NumberOfOperationalStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).NumberOfAdditionalReasons as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(NumberOfAdditionalReasons)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).OperationalStatus as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(OperationalStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_MANAGEMENT_STATUS>())).AdditionalReasons as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_MANAGEMENT_STATUS),
      "::",
      stringify!(AdditionalReasons)
    )
  );
}
pub type SCM_PD_MANAGEMENT_STATUS = _SCM_PD_MANAGEMENT_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_LOCATION_STRING {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Location: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_LOCATION_STRING() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_LOCATION_STRING>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_LOCATION_STRING))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_LOCATION_STRING>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_LOCATION_STRING))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_LOCATION_STRING>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_LOCATION_STRING),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_LOCATION_STRING>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_LOCATION_STRING),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_LOCATION_STRING>())).Location as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_LOCATION_STRING),
      "::",
      stringify!(Location)
    )
  );
}
pub type SCM_PD_LOCATION_STRING = _SCM_PD_LOCATION_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_DOWNLOAD {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
  pub Reserved: [BYTE; 3usize],
  pub Offset: DWORD64,
  pub FirmwareImageSizeInBytes: DWORD,
  pub FirmwareImage: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_FIRMWARE_DOWNLOAD() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_FIRMWARE_DOWNLOAD>(),
    32usize,
    concat!("Size of: ", stringify!(_SCM_PD_FIRMWARE_DOWNLOAD))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_FIRMWARE_DOWNLOAD>(),
    8usize,
    concat!("Alignment of ", stringify!(_SCM_PD_FIRMWARE_DOWNLOAD))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Slot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Slot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Reserved as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).Offset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).FirmwareImageSizeInBytes as *const _
        as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(FirmwareImageSizeInBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_DOWNLOAD>())).FirmwareImage as *const _ as usize
    },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_DOWNLOAD),
      "::",
      stringify!(FirmwareImage)
    )
  );
}
pub type SCM_PD_FIRMWARE_DOWNLOAD = _SCM_PD_FIRMWARE_DOWNLOAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_FIRMWARE_ACTIVATE {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Flags: DWORD,
  pub Slot: BYTE,
}
#[test]
fn bindgen_test_layout__SCM_PD_FIRMWARE_ACTIVATE() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_FIRMWARE_ACTIVATE>(),
    16usize,
    concat!("Size of: ", stringify!(_SCM_PD_FIRMWARE_ACTIVATE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_FIRMWARE_ACTIVATE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_FIRMWARE_ACTIVATE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_ACTIVATE>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_ACTIVATE>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_ACTIVATE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_FIRMWARE_ACTIVATE>())).Slot as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_FIRMWARE_ACTIVATE),
      "::",
      stringify!(Slot)
    )
  );
}
pub type SCM_PD_FIRMWARE_ACTIVATE = _SCM_PD_FIRMWARE_ACTIVATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INPUT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProtocolGuid: GUID,
  pub DataSize: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PASSTHROUGH_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PASSTHROUGH_INPUT>(),
    32usize,
    concat!("Size of: ", stringify!(_SCM_PD_PASSTHROUGH_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PASSTHROUGH_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_PASSTHROUGH_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).ProtocolGuid as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(ProtocolGuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).DataSize as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(DataSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INPUT>())).Data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INPUT),
      "::",
      stringify!(Data)
    )
  );
}
pub type SCM_PD_PASSTHROUGH_INPUT = _SCM_PD_PASSTHROUGH_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_OUTPUT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub ProtocolGuid: GUID,
  pub DataSize: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PASSTHROUGH_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PASSTHROUGH_OUTPUT>(),
    32usize,
    concat!("Size of: ", stringify!(_SCM_PD_PASSTHROUGH_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PASSTHROUGH_OUTPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCM_PD_PASSTHROUGH_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).Size as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).ProtocolGuid as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(ProtocolGuid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).DataSize as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(DataSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_OUTPUT>())).Data as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_OUTPUT),
      "::",
      stringify!(Data)
    )
  );
}
pub type SCM_PD_PASSTHROUGH_OUTPUT = _SCM_PD_PASSTHROUGH_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INVDIMM_INPUT {
  pub Opcode: DWORD,
  pub OpcodeParametersLength: DWORD,
  pub OpcodeParameters: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PASSTHROUGH_INVDIMM_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>())).Opcode as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT),
      "::",
      stringify!(Opcode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>())).OpcodeParametersLength
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT),
      "::",
      stringify!(OpcodeParametersLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_INPUT>())).OpcodeParameters as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_INPUT),
      "::",
      stringify!(OpcodeParameters)
    )
  );
}
pub type SCM_PD_PASSTHROUGH_INVDIMM_INPUT = _SCM_PD_PASSTHROUGH_INVDIMM_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT {
  pub GeneralStatus: WORD,
  pub ExtendedStatus: WORD,
  pub OutputDataLength: DWORD,
  pub OutputData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>())).GeneralStatus as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT),
      "::",
      stringify!(GeneralStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>())).ExtendedStatus as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT),
      "::",
      stringify!(ExtendedStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>())).OutputDataLength as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT),
      "::",
      stringify!(OutputDataLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT>())).OutputData as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT),
      "::",
      stringify!(OutputData)
    )
  );
}
pub type SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_INPUT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Options: _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1 {
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
  pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1)
    )
  );
}
impl _SCM_PD_REINITIALIZE_MEDIA_INPUT__bindgen_ty_1 {
  #[inline]
  pub fn Overwrite(&self) -> DWORD {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_Overwrite(&mut self, val: DWORD) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(Overwrite: DWORD) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let Overwrite: u32 = unsafe { ::std::mem::transmute(Overwrite) };
      Overwrite as u64
    });
    __bindgen_bitfield_unit
  }
}
#[test]
fn bindgen_test_layout__SCM_PD_REINITIALIZE_MEDIA_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_INPUT>())).Options as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_INPUT),
      "::",
      stringify!(Options)
    )
  );
}
pub type SCM_PD_REINITIALIZE_MEDIA_INPUT = _SCM_PD_REINITIALIZE_MEDIA_INPUT;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS_ScmPhysicalDeviceReinit_Success:
  _SCM_PD_MEDIA_REINITIALIZATION_STATUS = 0;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS_ScmPhysicalDeviceReinit_RebootNeeded:
  _SCM_PD_MEDIA_REINITIALIZATION_STATUS = 1;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS_ScmPhysicalDeviceReinit_ColdBootNeeded:
  _SCM_PD_MEDIA_REINITIALIZATION_STATUS = 2;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS_ScmPhysicalDeviceReinit_Max:
  _SCM_PD_MEDIA_REINITIALIZATION_STATUS = 3;
pub type _SCM_PD_MEDIA_REINITIALIZATION_STATUS = ::std::os::raw::c_int;
pub use self::_SCM_PD_MEDIA_REINITIALIZATION_STATUS as SCM_PD_MEDIA_REINITIALIZATION_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCM_PD_REINITIALIZE_MEDIA_OUTPUT {
  pub Version: DWORD,
  pub Size: DWORD,
  pub Status: SCM_PD_MEDIA_REINITIALIZATION_STATUS,
}
#[test]
fn bindgen_test_layout__SCM_PD_REINITIALIZE_MEDIA_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>(),
    12usize,
    concat!("Size of: ", stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>())).Version as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>())).Size as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCM_PD_REINITIALIZE_MEDIA_OUTPUT>())).Status as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCM_PD_REINITIALIZE_MEDIA_OUTPUT),
      "::",
      stringify!(Status)
    )
  );
}
pub type SCM_PD_REINITIALIZE_MEDIA_OUTPUT = _SCM_PD_REINITIALIZE_MEDIA_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_PARTITION_INFORMATION {
  pub PartitionType: BYTE,
}
#[test]
fn bindgen_test_layout__SET_PARTITION_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SET_PARTITION_INFORMATION>(),
    1usize,
    concat!("Size of: ", stringify!(_SET_PARTITION_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_PARTITION_INFORMATION>(),
    1usize,
    concat!("Alignment of ", stringify!(_SET_PARTITION_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_PARTITION_INFORMATION>())).PartitionType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PARTITION_INFORMATION),
      "::",
      stringify!(PartitionType)
    )
  );
}
pub type SET_PARTITION_INFORMATION = _SET_PARTITION_INFORMATION;
pub const _PARTITION_STYLE_PARTITION_STYLE_MBR: _PARTITION_STYLE = 0;
pub const _PARTITION_STYLE_PARTITION_STYLE_GPT: _PARTITION_STYLE = 1;
pub const _PARTITION_STYLE_PARTITION_STYLE_RAW: _PARTITION_STYLE = 2;
pub type _PARTITION_STYLE = ::std::os::raw::c_int;
pub use self::_PARTITION_STYLE as PARTITION_STYLE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PARTITION_INFORMATION_GPT {
  pub PartitionType: GUID,
  pub PartitionId: GUID,
  pub Attributes: DWORD64,
  pub Name: [WCHAR; 36usize],
}
#[test]
fn bindgen_test_layout__PARTITION_INFORMATION_GPT() {
  assert_eq!(
    ::std::mem::size_of::<_PARTITION_INFORMATION_GPT>(),
    112usize,
    concat!("Size of: ", stringify!(_PARTITION_INFORMATION_GPT))
  );
  assert_eq!(
    ::std::mem::align_of::<_PARTITION_INFORMATION_GPT>(),
    8usize,
    concat!("Alignment of ", stringify!(_PARTITION_INFORMATION_GPT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PARTITION_INFORMATION_GPT>())).PartitionType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_PARTITION_INFORMATION_GPT),
      "::",
      stringify!(PartitionType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PARTITION_INFORMATION_GPT>())).PartitionId as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_PARTITION_INFORMATION_GPT),
      "::",
      stringify!(PartitionId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_PARTITION_INFORMATION_GPT>())).Attributes as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_PARTITION_INFORMATION_GPT),
      "::",
      stringify!(Attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_PARTITION_INFORMATION_GPT>())).Name as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_PARTITION_INFORMATION_GPT),
      "::",
      stringify!(Name)
    )
  );
}
pub type PARTITION_INFORMATION_GPT = _PARTITION_INFORMATION_GPT;
pub type SET_PARTITION_INFORMATION_MBR = SET_PARTITION_INFORMATION;
pub type SET_PARTITION_INFORMATION_GPT = PARTITION_INFORMATION_GPT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SET_PARTITION_INFORMATION_EX {
  pub PartitionStyle: PARTITION_STYLE,
  pub __bindgen_anon_1: _SET_PARTITION_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SET_PARTITION_INFORMATION_EX__bindgen_ty_1 {
  pub Mbr: SET_PARTITION_INFORMATION_MBR,
  pub Gpt: SET_PARTITION_INFORMATION_GPT,
  _bindgen_union_align: [u64; 14usize],
}
#[test]
fn bindgen_test_layout__SET_PARTITION_INFORMATION_EX__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SET_PARTITION_INFORMATION_EX__bindgen_ty_1>(),
    112usize,
    concat!(
      "Size of: ",
      stringify!(_SET_PARTITION_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_PARTITION_INFORMATION_EX__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SET_PARTITION_INFORMATION_EX__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_PARTITION_INFORMATION_EX__bindgen_ty_1>())).Mbr as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PARTITION_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Mbr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_PARTITION_INFORMATION_EX__bindgen_ty_1>())).Gpt as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PARTITION_INFORMATION_EX__bindgen_ty_1),
      "::",
      stringify!(Gpt)
    )
  );
}
#[test]
fn bindgen_test_layout__SET_PARTITION_INFORMATION_EX() {
  assert_eq!(
    ::std::mem::size_of::<_SET_PARTITION_INFORMATION_EX>(),
    120usize,
    concat!("Size of: ", stringify!(_SET_PARTITION_INFORMATION_EX))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_PARTITION_INFORMATION_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(_SET_PARTITION_INFORMATION_EX))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_PARTITION_INFORMATION_EX>())).PartitionStyle as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PARTITION_INFORMATION_EX),
      "::",
      stringify!(PartitionStyle)
    )
  );
}
pub type SET_PARTITION_INFORMATION_EX = _SET_PARTITION_INFORMATION_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IDEREGS {
  pub bFeaturesReg: BYTE,
  pub bSectorCountReg: BYTE,
  pub bSectorNumberReg: BYTE,
  pub bCylLowReg: BYTE,
  pub bCylHighReg: BYTE,
  pub bDriveHeadReg: BYTE,
  pub bCommandReg: BYTE,
  pub bReserved: BYTE,
}
#[test]
fn bindgen_test_layout__IDEREGS() {
  assert_eq!(
    ::std::mem::size_of::<_IDEREGS>(),
    8usize,
    concat!("Size of: ", stringify!(_IDEREGS))
  );
  assert_eq!(
    ::std::mem::align_of::<_IDEREGS>(),
    1usize,
    concat!("Alignment of ", stringify!(_IDEREGS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bFeaturesReg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bFeaturesReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bSectorCountReg as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bSectorCountReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bSectorNumberReg as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bSectorNumberReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bCylLowReg as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bCylLowReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bCylHighReg as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bCylHighReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bDriveHeadReg as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bDriveHeadReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bCommandReg as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bCommandReg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IDEREGS>())).bReserved as *const _ as usize },
    7usize,
    concat!(
      "Offset of field: ",
      stringify!(_IDEREGS),
      "::",
      stringify!(bReserved)
    )
  );
}
pub type IDEREGS = _IDEREGS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SENDCMDINPARAMS {
  pub cBufferSize: DWORD,
  pub irDriveRegs: IDEREGS,
  pub bDriveNumber: BYTE,
  pub bReserved: [BYTE; 3usize],
  pub dwReserved: [DWORD; 4usize],
  pub bBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SENDCMDINPARAMS() {
  assert_eq!(
    ::std::mem::size_of::<_SENDCMDINPARAMS>(),
    33usize,
    concat!("Size of: ", stringify!(_SENDCMDINPARAMS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SENDCMDINPARAMS>(),
    1usize,
    concat!("Alignment of ", stringify!(_SENDCMDINPARAMS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).cBufferSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(cBufferSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).irDriveRegs as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(irDriveRegs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).bDriveNumber as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(bDriveNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).bReserved as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(bReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).dwReserved as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDINPARAMS>())).bBuffer as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDINPARAMS),
      "::",
      stringify!(bBuffer)
    )
  );
}
pub type SENDCMDINPARAMS = _SENDCMDINPARAMS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVERSTATUS {
  pub bDriverError: BYTE,
  pub bIDEError: BYTE,
  pub bReserved: [BYTE; 2usize],
  pub dwReserved: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout__DRIVERSTATUS() {
  assert_eq!(
    ::std::mem::size_of::<_DRIVERSTATUS>(),
    12usize,
    concat!("Size of: ", stringify!(_DRIVERSTATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_DRIVERSTATUS>(),
    1usize,
    concat!("Alignment of ", stringify!(_DRIVERSTATUS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DRIVERSTATUS>())).bDriverError as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRIVERSTATUS),
      "::",
      stringify!(bDriverError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DRIVERSTATUS>())).bIDEError as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRIVERSTATUS),
      "::",
      stringify!(bIDEError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DRIVERSTATUS>())).bReserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRIVERSTATUS),
      "::",
      stringify!(bReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_DRIVERSTATUS>())).dwReserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_DRIVERSTATUS),
      "::",
      stringify!(dwReserved)
    )
  );
}
pub type DRIVERSTATUS = _DRIVERSTATUS;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SENDCMDOUTPARAMS {
  pub cBufferSize: DWORD,
  pub DriverStatus: DRIVERSTATUS,
  pub bBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SENDCMDOUTPARAMS() {
  assert_eq!(
    ::std::mem::size_of::<_SENDCMDOUTPARAMS>(),
    17usize,
    concat!("Size of: ", stringify!(_SENDCMDOUTPARAMS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SENDCMDOUTPARAMS>(),
    1usize,
    concat!("Alignment of ", stringify!(_SENDCMDOUTPARAMS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDOUTPARAMS>())).cBufferSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDOUTPARAMS),
      "::",
      stringify!(cBufferSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDOUTPARAMS>())).DriverStatus as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDOUTPARAMS),
      "::",
      stringify!(DriverStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SENDCMDOUTPARAMS>())).bBuffer as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SENDCMDOUTPARAMS),
      "::",
      stringify!(bBuffer)
    )
  );
}
pub type SENDCMDOUTPARAMS = _SENDCMDOUTPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_DISK_ATTRIBUTES {
  pub Version: DWORD,
  pub Persist: BOOLEAN,
  pub Reserved1: [BYTE; 3usize],
  pub Attributes: DWORDLONG,
  pub AttributesMask: DWORDLONG,
  pub Reserved2: [DWORD; 4usize],
}
#[test]
fn bindgen_test_layout__SET_DISK_ATTRIBUTES() {
  assert_eq!(
    ::std::mem::size_of::<_SET_DISK_ATTRIBUTES>(),
    40usize,
    concat!("Size of: ", stringify!(_SET_DISK_ATTRIBUTES))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_DISK_ATTRIBUTES>(),
    8usize,
    concat!("Alignment of ", stringify!(_SET_DISK_ATTRIBUTES))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Persist as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Persist)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Reserved1 as *const _ as usize },
    5usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Attributes as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).AttributesMask as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(AttributesMask)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_DISK_ATTRIBUTES>())).Reserved2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DISK_ATTRIBUTES),
      "::",
      stringify!(Reserved2)
    )
  );
}
pub type SET_DISK_ATTRIBUTES = _SET_DISK_ATTRIBUTES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_LCN_INPUT_BUFFER {
  pub StartingLcn: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_STARTING_LCN_INPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<STARTING_LCN_INPUT_BUFFER>(),
    8usize,
    concat!("Size of: ", stringify!(STARTING_LCN_INPUT_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<STARTING_LCN_INPUT_BUFFER>(),
    8usize,
    concat!("Alignment of ", stringify!(STARTING_LCN_INPUT_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STARTING_LCN_INPUT_BUFFER>())).StartingLcn as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(STARTING_LCN_INPUT_BUFFER),
      "::",
      stringify!(StartingLcn)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_LCN_INPUT_BUFFER_EX {
  pub StartingLcn: LARGE_INTEGER,
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout_STARTING_LCN_INPUT_BUFFER_EX() {
  assert_eq!(
    ::std::mem::size_of::<STARTING_LCN_INPUT_BUFFER_EX>(),
    16usize,
    concat!("Size of: ", stringify!(STARTING_LCN_INPUT_BUFFER_EX))
  );
  assert_eq!(
    ::std::mem::align_of::<STARTING_LCN_INPUT_BUFFER_EX>(),
    8usize,
    concat!("Alignment of ", stringify!(STARTING_LCN_INPUT_BUFFER_EX))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STARTING_LCN_INPUT_BUFFER_EX>())).StartingLcn as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(STARTING_LCN_INPUT_BUFFER_EX),
      "::",
      stringify!(StartingLcn)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<STARTING_LCN_INPUT_BUFFER_EX>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(STARTING_LCN_INPUT_BUFFER_EX),
      "::",
      stringify!(Flags)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct STARTING_VCN_INPUT_BUFFER {
  pub StartingVcn: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_STARTING_VCN_INPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<STARTING_VCN_INPUT_BUFFER>(),
    8usize,
    concat!("Size of: ", stringify!(STARTING_VCN_INPUT_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<STARTING_VCN_INPUT_BUFFER>(),
    8usize,
    concat!("Alignment of ", stringify!(STARTING_VCN_INPUT_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<STARTING_VCN_INPUT_BUFFER>())).StartingVcn as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(STARTING_VCN_INPUT_BUFFER),
      "::",
      stringify!(StartingVcn)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_BUFFER {
  pub ExtentCount: DWORD,
  pub StartingVcn: LARGE_INTEGER,
  pub Extents: [RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1 {
  pub NextVcn: LARGE_INTEGER,
  pub Lcn: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout_RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1>())).NextVcn as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1),
      "::",
      stringify!(NextVcn)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1>())).Lcn as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER__bindgen_ty_1),
      "::",
      stringify!(Lcn)
    )
  );
}
#[test]
fn bindgen_test_layout_RETRIEVAL_POINTERS_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<RETRIEVAL_POINTERS_BUFFER>(),
    32usize,
    concat!("Size of: ", stringify!(RETRIEVAL_POINTERS_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<RETRIEVAL_POINTERS_BUFFER>(),
    8usize,
    concat!("Alignment of ", stringify!(RETRIEVAL_POINTERS_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER>())).ExtentCount as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER),
      "::",
      stringify!(ExtentCount)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER>())).StartingVcn as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER),
      "::",
      stringify!(StartingVcn)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<RETRIEVAL_POINTERS_BUFFER>())).Extents as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(RETRIEVAL_POINTERS_BUFFER),
      "::",
      stringify!(Extents)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SI_COPYFILE {
  pub SourceFileNameLength: DWORD,
  pub DestinationFileNameLength: DWORD,
  pub Flags: DWORD,
  pub FileNameBuffer: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__SI_COPYFILE() {
  assert_eq!(
    ::std::mem::size_of::<_SI_COPYFILE>(),
    16usize,
    concat!("Size of: ", stringify!(_SI_COPYFILE))
  );
  assert_eq!(
    ::std::mem::align_of::<_SI_COPYFILE>(),
    4usize,
    concat!("Alignment of ", stringify!(_SI_COPYFILE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SI_COPYFILE>())).SourceFileNameLength as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SI_COPYFILE),
      "::",
      stringify!(SourceFileNameLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SI_COPYFILE>())).DestinationFileNameLength as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SI_COPYFILE),
      "::",
      stringify!(DestinationFileNameLength)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SI_COPYFILE>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SI_COPYFILE),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SI_COPYFILE>())).FileNameBuffer as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SI_COPYFILE),
      "::",
      stringify!(FileNameBuffer)
    )
  );
}
pub type SI_COPYFILE = _SI_COPYFILE;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkPrepare: _SHRINK_VOLUME_REQUEST_TYPES = 1;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkCommit: _SHRINK_VOLUME_REQUEST_TYPES = 2;
pub const _SHRINK_VOLUME_REQUEST_TYPES_ShrinkAbort: _SHRINK_VOLUME_REQUEST_TYPES = 3;
pub type _SHRINK_VOLUME_REQUEST_TYPES = ::std::os::raw::c_int;
pub use self::_SHRINK_VOLUME_REQUEST_TYPES as SHRINK_VOLUME_REQUEST_TYPES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHRINK_VOLUME_INFORMATION {
  pub ShrinkRequestType: SHRINK_VOLUME_REQUEST_TYPES,
  pub Flags: DWORDLONG,
  pub NewNumberOfSectors: LONGLONG,
}
#[test]
fn bindgen_test_layout__SHRINK_VOLUME_INFORMATION() {
  assert_eq!(
    ::std::mem::size_of::<_SHRINK_VOLUME_INFORMATION>(),
    24usize,
    concat!("Size of: ", stringify!(_SHRINK_VOLUME_INFORMATION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SHRINK_VOLUME_INFORMATION>(),
    8usize,
    concat!("Alignment of ", stringify!(_SHRINK_VOLUME_INFORMATION))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHRINK_VOLUME_INFORMATION>())).ShrinkRequestType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHRINK_VOLUME_INFORMATION),
      "::",
      stringify!(ShrinkRequestType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SHRINK_VOLUME_INFORMATION>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHRINK_VOLUME_INFORMATION),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SHRINK_VOLUME_INFORMATION>())).NewNumberOfSectors as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SHRINK_VOLUME_INFORMATION),
      "::",
      stringify!(NewNumberOfSectors)
    )
  );
}
pub type SHRINK_VOLUME_INFORMATION = _SHRINK_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VIRTUAL_STORAGE_TYPE {
  pub DeviceId: DWORD,
  pub VendorId: GUID,
}
#[test]
fn bindgen_test_layout__VIRTUAL_STORAGE_TYPE() {
  assert_eq!(
    ::std::mem::size_of::<_VIRTUAL_STORAGE_TYPE>(),
    20usize,
    concat!("Size of: ", stringify!(_VIRTUAL_STORAGE_TYPE))
  );
  assert_eq!(
    ::std::mem::align_of::<_VIRTUAL_STORAGE_TYPE>(),
    4usize,
    concat!("Alignment of ", stringify!(_VIRTUAL_STORAGE_TYPE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_VIRTUAL_STORAGE_TYPE>())).DeviceId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIRTUAL_STORAGE_TYPE),
      "::",
      stringify!(DeviceId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_VIRTUAL_STORAGE_TYPE>())).VendorId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_VIRTUAL_STORAGE_TYPE),
      "::",
      stringify!(VendorId)
    )
  );
}
pub type VIRTUAL_STORAGE_TYPE = _VIRTUAL_STORAGE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
  pub RequestLevel: DWORD,
  pub RequestFlags: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST>())).RequestLevel as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST),
      "::",
      stringify!(RequestLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST>())).RequestFlags as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST),
      "::",
      stringify!(RequestFlags)
    )
  );
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
  pub EntryLength: DWORD,
  pub DependencyTypeFlags: DWORD,
  pub ProviderSpecificFlags: DWORD,
  pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>())).EntryLength as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY),
      "::",
      stringify!(EntryLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>())).DependencyTypeFlags
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY),
      "::",
      stringify!(DependencyTypeFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>())).ProviderSpecificFlags
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY),
      "::",
      stringify!(ProviderSpecificFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY>())).VirtualStorageType
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY),
      "::",
      stringify!(VirtualStorageType)
    )
  );
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
  pub EntryLength: DWORD,
  pub DependencyTypeFlags: DWORD,
  pub ProviderSpecificFlags: DWORD,
  pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
  pub AncestorLevel: DWORD,
  pub HostVolumeNameOffset: DWORD,
  pub HostVolumeNameSize: DWORD,
  pub DependentVolumeNameOffset: DWORD,
  pub DependentVolumeNameSize: DWORD,
  pub RelativePathOffset: DWORD,
  pub RelativePathSize: DWORD,
  pub DependentDeviceNameOffset: DWORD,
  pub DependentDeviceNameSize: DWORD,
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>(),
    68usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).EntryLength as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(EntryLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).DependencyTypeFlags
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependencyTypeFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).ProviderSpecificFlags
        as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(ProviderSpecificFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).VirtualStorageType
        as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(VirtualStorageType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).AncestorLevel
        as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(AncestorLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).HostVolumeNameOffset
        as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(HostVolumeNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).HostVolumeNameSize
        as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(HostVolumeNameSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>()))
        .DependentVolumeNameOffset as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependentVolumeNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).DependentVolumeNameSize
        as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependentVolumeNameSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).RelativePathOffset
        as *const _ as usize
    },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(RelativePathOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).RelativePathSize
        as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(RelativePathSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>()))
        .DependentDeviceNameOffset as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependentDeviceNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY>())).DependentDeviceNameSize
        as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY),
      "::",
      stringify!(DependentDeviceNameSize)
    )
  );
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
#[repr(C)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
  pub ResponseLevel: DWORD,
  pub NumberEntries: DWORD,
  pub __bindgen_anon_1: _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1,
}
#[repr(C)]
pub struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1 {
  pub Lev1Depends: __BindgenUnionField<[STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY; 0usize]>,
  pub Lev2Depends: __BindgenUnionField<[STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY; 0usize]>,
  pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1>(),
    4usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1>())).Lev1Depends
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1),
      "::",
      stringify!(Lev1Depends)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1>())).Lev2Depends
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE__bindgen_ty_1),
      "::",
      stringify!(Lev2Depends)
    )
  );
}
#[test]
fn bindgen_test_layout__STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE() {
  assert_eq!(
    ::std::mem::size_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE>(),
    12usize,
    concat!(
      "Size of: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE>())).ResponseLevel as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE),
      "::",
      stringify!(ResponseLevel)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE>())).NumberEntries as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE),
      "::",
      stringify!(NumberEntries)
    )
  );
}
pub type STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_CHANGE_MACHINE_SID_INPUT {
  pub CurrentMachineSIDOffset: WORD,
  pub CurrentMachineSIDLength: WORD,
  pub NewMachineSIDOffset: WORD,
  pub NewMachineSIDLength: WORD,
}
#[test]
fn bindgen_test_layout__SD_CHANGE_MACHINE_SID_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_CHANGE_MACHINE_SID_INPUT>(),
    8usize,
    concat!("Size of: ", stringify!(_SD_CHANGE_MACHINE_SID_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_CHANGE_MACHINE_SID_INPUT>(),
    2usize,
    concat!("Alignment of ", stringify!(_SD_CHANGE_MACHINE_SID_INPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_INPUT>())).CurrentMachineSIDOffset as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_INPUT),
      "::",
      stringify!(CurrentMachineSIDOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_INPUT>())).CurrentMachineSIDLength as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_INPUT),
      "::",
      stringify!(CurrentMachineSIDLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_INPUT>())).NewMachineSIDOffset as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_INPUT),
      "::",
      stringify!(NewMachineSIDOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_INPUT>())).NewMachineSIDLength as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_INPUT),
      "::",
      stringify!(NewMachineSIDLength)
    )
  );
}
pub type SD_CHANGE_MACHINE_SID_INPUT = _SD_CHANGE_MACHINE_SID_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_CHANGE_MACHINE_SID_OUTPUT {
  pub NumSDChangedSuccess: DWORDLONG,
  pub NumSDChangedFail: DWORDLONG,
  pub NumSDUnused: DWORDLONG,
  pub NumSDTotal: DWORDLONG,
  pub NumMftSDChangedSuccess: DWORDLONG,
  pub NumMftSDChangedFail: DWORDLONG,
  pub NumMftSDTotal: DWORDLONG,
}
#[test]
fn bindgen_test_layout__SD_CHANGE_MACHINE_SID_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_CHANGE_MACHINE_SID_OUTPUT>(),
    56usize,
    concat!("Size of: ", stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_CHANGE_MACHINE_SID_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumSDChangedSuccess as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumSDChangedSuccess)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumSDChangedFail as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumSDChangedFail)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumSDUnused as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumSDUnused)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumSDTotal as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumSDTotal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumMftSDChangedSuccess as *const _
        as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumMftSDChangedSuccess)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumMftSDChangedFail as *const _
        as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumMftSDChangedFail)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_CHANGE_MACHINE_SID_OUTPUT>())).NumMftSDTotal as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_CHANGE_MACHINE_SID_OUTPUT),
      "::",
      stringify!(NumMftSDTotal)
    )
  );
}
pub type SD_CHANGE_MACHINE_SID_OUTPUT = _SD_CHANGE_MACHINE_SID_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_QUERY_STATS_INPUT {
  pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__SD_QUERY_STATS_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_QUERY_STATS_INPUT>(),
    4usize,
    concat!("Size of: ", stringify!(_SD_QUERY_STATS_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_QUERY_STATS_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SD_QUERY_STATS_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_QUERY_STATS_INPUT>())).Reserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_INPUT),
      "::",
      stringify!(Reserved)
    )
  );
}
pub type SD_QUERY_STATS_INPUT = _SD_QUERY_STATS_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_QUERY_STATS_OUTPUT {
  pub SdsStreamSize: DWORDLONG,
  pub SdsAllocationSize: DWORDLONG,
  pub SiiStreamSize: DWORDLONG,
  pub SiiAllocationSize: DWORDLONG,
  pub SdhStreamSize: DWORDLONG,
  pub SdhAllocationSize: DWORDLONG,
  pub NumSDTotal: DWORDLONG,
  pub NumSDUnused: DWORDLONG,
}
#[test]
fn bindgen_test_layout__SD_QUERY_STATS_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_QUERY_STATS_OUTPUT>(),
    64usize,
    concat!("Size of: ", stringify!(_SD_QUERY_STATS_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_QUERY_STATS_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_QUERY_STATS_OUTPUT))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SdsStreamSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SdsStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SdsAllocationSize as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SdsAllocationSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SiiStreamSize as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SiiStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SiiAllocationSize as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SiiAllocationSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SdhStreamSize as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SdhStreamSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).SdhAllocationSize as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(SdhAllocationSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).NumSDTotal as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(NumSDTotal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_QUERY_STATS_OUTPUT>())).NumSDUnused as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_QUERY_STATS_OUTPUT),
      "::",
      stringify!(NumSDUnused)
    )
  );
}
pub type SD_QUERY_STATS_OUTPUT = _SD_QUERY_STATS_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_INPUT {
  pub StartingOffset: DWORDLONG,
  pub MaxSDEntriesToReturn: DWORDLONG,
}
#[test]
fn bindgen_test_layout__SD_ENUM_SDS_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_ENUM_SDS_INPUT>(),
    16usize,
    concat!("Size of: ", stringify!(_SD_ENUM_SDS_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_ENUM_SDS_INPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_ENUM_SDS_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_INPUT>())).StartingOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_INPUT),
      "::",
      stringify!(StartingOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_ENUM_SDS_INPUT>())).MaxSDEntriesToReturn as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_INPUT),
      "::",
      stringify!(MaxSDEntriesToReturn)
    )
  );
}
pub type SD_ENUM_SDS_INPUT = _SD_ENUM_SDS_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_ENTRY {
  pub Hash: DWORD,
  pub SecurityId: DWORD,
  pub Offset: DWORDLONG,
  pub Length: DWORD,
  pub Descriptor: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SD_ENUM_SDS_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_SD_ENUM_SDS_ENTRY>(),
    24usize,
    concat!("Size of: ", stringify!(_SD_ENUM_SDS_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_ENUM_SDS_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_ENUM_SDS_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).Hash as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(Hash)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).SecurityId as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(SecurityId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).Offset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(Offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).Length as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(Length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_ENTRY>())).Descriptor as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_ENTRY),
      "::",
      stringify!(Descriptor)
    )
  );
}
pub type SD_ENUM_SDS_ENTRY = _SD_ENUM_SDS_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SD_ENUM_SDS_OUTPUT {
  pub NextOffset: DWORDLONG,
  pub NumSDEntriesReturned: DWORDLONG,
  pub NumSDBytesReturned: DWORDLONG,
  pub SDEntry: [SD_ENUM_SDS_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__SD_ENUM_SDS_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_ENUM_SDS_OUTPUT>(),
    48usize,
    concat!("Size of: ", stringify!(_SD_ENUM_SDS_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_ENUM_SDS_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_ENUM_SDS_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_OUTPUT>())).NextOffset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_OUTPUT),
      "::",
      stringify!(NextOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_ENUM_SDS_OUTPUT>())).NumSDEntriesReturned as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_OUTPUT),
      "::",
      stringify!(NumSDEntriesReturned)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_ENUM_SDS_OUTPUT>())).NumSDBytesReturned as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_OUTPUT),
      "::",
      stringify!(NumSDBytesReturned)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_ENUM_SDS_OUTPUT>())).SDEntry as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_ENUM_SDS_OUTPUT),
      "::",
      stringify!(SDEntry)
    )
  );
}
pub type SD_ENUM_SDS_OUTPUT = _SD_ENUM_SDS_OUTPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SD_GLOBAL_CHANGE_INPUT {
  pub Flags: DWORD,
  pub ChangeType: DWORD,
  pub __bindgen_anon_1: _SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1 {
  pub SdChange: SD_CHANGE_MACHINE_SID_INPUT,
  pub SdQueryStats: SD_QUERY_STATS_INPUT,
  pub SdEnumSds: SD_ENUM_SDS_INPUT,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>())).SdChange as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1),
      "::",
      stringify!(SdChange)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>())).SdQueryStats as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1),
      "::",
      stringify!(SdQueryStats)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1>())).SdEnumSds as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT__bindgen_ty_1),
      "::",
      stringify!(SdEnumSds)
    )
  );
}
#[test]
fn bindgen_test_layout__SD_GLOBAL_CHANGE_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_GLOBAL_CHANGE_INPUT>(),
    24usize,
    concat!("Size of: ", stringify!(_SD_GLOBAL_CHANGE_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_GLOBAL_CHANGE_INPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_GLOBAL_CHANGE_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_INPUT>())).ChangeType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_INPUT),
      "::",
      stringify!(ChangeType)
    )
  );
}
pub type SD_GLOBAL_CHANGE_INPUT = _SD_GLOBAL_CHANGE_INPUT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SD_GLOBAL_CHANGE_OUTPUT {
  pub Flags: DWORD,
  pub ChangeType: DWORD,
  pub __bindgen_anon_1: _SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1 {
  pub SdChange: SD_CHANGE_MACHINE_SID_OUTPUT,
  pub SdQueryStats: SD_QUERY_STATS_OUTPUT,
  pub SdEnumSds: SD_ENUM_SDS_OUTPUT,
  _bindgen_union_align: [u64; 8usize],
}
#[test]
fn bindgen_test_layout__SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>(),
    64usize,
    concat!(
      "Size of: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>())).SdChange as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1),
      "::",
      stringify!(SdChange)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>())).SdQueryStats as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1),
      "::",
      stringify!(SdQueryStats)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1>())).SdEnumSds as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT__bindgen_ty_1),
      "::",
      stringify!(SdEnumSds)
    )
  );
}
#[test]
fn bindgen_test_layout__SD_GLOBAL_CHANGE_OUTPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SD_GLOBAL_CHANGE_OUTPUT>(),
    72usize,
    concat!("Size of: ", stringify!(_SD_GLOBAL_CHANGE_OUTPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SD_GLOBAL_CHANGE_OUTPUT>(),
    8usize,
    concat!("Alignment of ", stringify!(_SD_GLOBAL_CHANGE_OUTPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SD_GLOBAL_CHANGE_OUTPUT>())).ChangeType as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SD_GLOBAL_CHANGE_OUTPUT),
      "::",
      stringify!(ChangeType)
    )
  );
}
pub type SD_GLOBAL_CHANGE_OUTPUT = _SD_GLOBAL_CHANGE_OUTPUT;
pub const _STORAGE_RESERVE_ID_StorageReserveIdNone: _STORAGE_RESERVE_ID = 0;
pub const _STORAGE_RESERVE_ID_StorageReserveIdHard: _STORAGE_RESERVE_ID = 1;
pub const _STORAGE_RESERVE_ID_StorageReserveIdSoft: _STORAGE_RESERVE_ID = 2;
pub const _STORAGE_RESERVE_ID_StorageReserveIdUpdateScratch: _STORAGE_RESERVE_ID = 3;
pub const _STORAGE_RESERVE_ID_StorageReserveIdMax: _STORAGE_RESERVE_ID = 4;
pub type _STORAGE_RESERVE_ID = ::std::os::raw::c_int;
pub use self::_STORAGE_RESERVE_ID as STORAGE_RESERVE_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_LAYOUT_ENTRY {
  pub Version: DWORD,
  pub NextStreamOffset: DWORD,
  pub Flags: DWORD,
  pub ExtentInformationOffset: DWORD,
  pub AllocationSize: LARGE_INTEGER,
  pub EndOfFile: LARGE_INTEGER,
  pub StreamInformationOffset: DWORD,
  pub AttributeTypeCode: DWORD,
  pub AttributeFlags: DWORD,
  pub StreamIdentifierLength: DWORD,
  pub StreamIdentifier: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__STREAM_LAYOUT_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_LAYOUT_ENTRY>(),
    56usize,
    concat!("Size of: ", stringify!(_STREAM_LAYOUT_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_LAYOUT_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_STREAM_LAYOUT_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).NextStreamOffset as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(NextStreamOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).Flags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).ExtentInformationOffset as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(ExtentInformationOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).AllocationSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(AllocationSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).EndOfFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(EndOfFile)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).StreamInformationOffset as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(StreamInformationOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).AttributeTypeCode as *const _ as usize
    },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(AttributeTypeCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).AttributeFlags as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(AttributeFlags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).StreamIdentifierLength as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(StreamIdentifierLength)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_LAYOUT_ENTRY>())).StreamIdentifier as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_LAYOUT_ENTRY),
      "::",
      stringify!(StreamIdentifier)
    )
  );
}
pub type STREAM_LAYOUT_ENTRY = _STREAM_LAYOUT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_EXTENT_ENTRY {
  pub Flags: DWORD,
  pub ExtentInformation: _STREAM_EXTENT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STREAM_EXTENT_ENTRY__bindgen_ty_1 {
  pub RetrievalPointers: RETRIEVAL_POINTERS_BUFFER,
  _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__STREAM_EXTENT_ENTRY__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_EXTENT_ENTRY__bindgen_ty_1>(),
    32usize,
    concat!("Size of: ", stringify!(_STREAM_EXTENT_ENTRY__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_EXTENT_ENTRY__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAM_EXTENT_ENTRY__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_EXTENT_ENTRY__bindgen_ty_1>())).RetrievalPointers as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_EXTENT_ENTRY__bindgen_ty_1),
      "::",
      stringify!(RetrievalPointers)
    )
  );
}
#[test]
fn bindgen_test_layout__STREAM_EXTENT_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_EXTENT_ENTRY>(),
    40usize,
    concat!("Size of: ", stringify!(_STREAM_EXTENT_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_EXTENT_ENTRY>(),
    8usize,
    concat!("Alignment of ", stringify!(_STREAM_EXTENT_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_EXTENT_ENTRY>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_EXTENT_ENTRY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_EXTENT_ENTRY>())).ExtentInformation as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_EXTENT_ENTRY),
      "::",
      stringify!(ExtentInformation)
    )
  );
}
pub type STREAM_EXTENT_ENTRY = _STREAM_EXTENT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_PURGE_FAILURE_MODE_INPUT {
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__SET_PURGE_FAILURE_MODE_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SET_PURGE_FAILURE_MODE_INPUT>(),
    4usize,
    concat!("Size of: ", stringify!(_SET_PURGE_FAILURE_MODE_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_PURGE_FAILURE_MODE_INPUT>(),
    4usize,
    concat!("Alignment of ", stringify!(_SET_PURGE_FAILURE_MODE_INPUT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SET_PURGE_FAILURE_MODE_INPUT>())).Flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_PURGE_FAILURE_MODE_INPUT),
      "::",
      stringify!(Flags)
    )
  );
}
pub type SET_PURGE_FAILURE_MODE_INPUT = _SET_PURGE_FAILURE_MODE_INPUT;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassUnspecified: _FILE_STORAGE_TIER_CLASS = 0;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassCapacity: _FILE_STORAGE_TIER_CLASS = 1;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassPerformance: _FILE_STORAGE_TIER_CLASS = 2;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassMax: _FILE_STORAGE_TIER_CLASS = 3;
pub type _FILE_STORAGE_TIER_CLASS = ::std::os::raw::c_int;
pub use self::_FILE_STORAGE_TIER_CLASS as FILE_STORAGE_TIER_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY {
  pub Version: DWORD,
  pub Flags: DWORD,
  pub StreamInformation: _STREAM_INFORMATION_ENTRY__StreamInformation,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _STREAM_INFORMATION_ENTRY__StreamInformation {
  pub DesiredStorageClass: _STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass {
  pub Class: FILE_STORAGE_TIER_CLASS,
  pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass>()))
        .Class as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass),
      "::",
      stringify!(Class)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass>()))
        .Flags as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation__DesiredStorageClass),
      "::",
      stringify!(Flags)
    )
  );
}
#[test]
fn bindgen_test_layout__STREAM_INFORMATION_ENTRY__StreamInformation() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_INFORMATION_ENTRY__StreamInformation>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_INFORMATION_ENTRY__StreamInformation>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY__StreamInformation>())).DesiredStorageClass
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY__StreamInformation),
      "::",
      stringify!(DesiredStorageClass)
    )
  );
}
#[test]
fn bindgen_test_layout__STREAM_INFORMATION_ENTRY() {
  assert_eq!(
    ::std::mem::size_of::<_STREAM_INFORMATION_ENTRY>(),
    16usize,
    concat!("Size of: ", stringify!(_STREAM_INFORMATION_ENTRY))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAM_INFORMATION_ENTRY>(),
    4usize,
    concat!("Alignment of ", stringify!(_STREAM_INFORMATION_ENTRY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY>())).Version as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY),
      "::",
      stringify!(Version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY>())).Flags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAM_INFORMATION_ENTRY>())).StreamInformation as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAM_INFORMATION_ENTRY),
      "::",
      stringify!(StreamInformation)
    )
  );
}
pub type STREAM_INFORMATION_ENTRY = _STREAM_INFORMATION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
  pub OptimalWriteSize: DWORD,
  pub StreamGranularitySize: DWORD,
  pub StreamIdMin: DWORD,
  pub StreamIdMax: DWORD,
}
#[test]
fn bindgen_test_layout__STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>())).OptimalWriteSize
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER),
      "::",
      stringify!(OptimalWriteSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>())).StreamGranularitySize
        as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER),
      "::",
      stringify!(StreamGranularitySize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>())).StreamIdMin as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER),
      "::",
      stringify!(StreamIdMin)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER>())).StreamIdMax as *const _
        as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER),
      "::",
      stringify!(StreamIdMax)
    )
  );
}
pub type STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
  pub Flags: DWORD,
  pub StreamId: DWORD,
}
#[test]
fn bindgen_test_layout__STREAMS_ASSOCIATE_ID_INPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<_STREAMS_ASSOCIATE_ID_INPUT_BUFFER>(),
    8usize,
    concat!("Size of: ", stringify!(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAMS_ASSOCIATE_ID_INPUT_BUFFER>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_ASSOCIATE_ID_INPUT_BUFFER>())).Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_ASSOCIATE_ID_INPUT_BUFFER>())).StreamId as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_ASSOCIATE_ID_INPUT_BUFFER),
      "::",
      stringify!(StreamId)
    )
  );
}
pub type STREAMS_ASSOCIATE_ID_INPUT_BUFFER = _STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STREAMS_QUERY_ID_OUTPUT_BUFFER {
  pub StreamId: DWORD,
}
#[test]
fn bindgen_test_layout__STREAMS_QUERY_ID_OUTPUT_BUFFER() {
  assert_eq!(
    ::std::mem::size_of::<_STREAMS_QUERY_ID_OUTPUT_BUFFER>(),
    4usize,
    concat!("Size of: ", stringify!(_STREAMS_QUERY_ID_OUTPUT_BUFFER))
  );
  assert_eq!(
    ::std::mem::align_of::<_STREAMS_QUERY_ID_OUTPUT_BUFFER>(),
    4usize,
    concat!("Alignment of ", stringify!(_STREAMS_QUERY_ID_OUTPUT_BUFFER))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_STREAMS_QUERY_ID_OUTPUT_BUFFER>())).StreamId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_STREAMS_QUERY_ID_OUTPUT_BUFFER),
      "::",
      stringify!(StreamId)
    )
  );
}
pub type STREAMS_QUERY_ID_OUTPUT_BUFFER = _STREAMS_QUERY_ID_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
  pub Flags: DWORD,
  pub AlignmentShift: DWORD,
  pub FileOffsetToAlign: DWORDLONG,
  pub FallbackAlignmentShift: DWORD,
}
#[test]
fn bindgen_test_layout__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT() {
  assert_eq!(
    ::std::mem::size_of::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>(),
    24usize,
    concat!("Size of: ", stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT))
  );
  assert_eq!(
    ::std::mem::align_of::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>())).Flags as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT),
      "::",
      stringify!(Flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>())).AlignmentShift as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT),
      "::",
      stringify!(AlignmentShift)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>())).FileOffsetToAlign as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT),
      "::",
      stringify!(FileOffsetToAlign)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT>())).FallbackAlignmentShift
        as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT),
      "::",
      stringify!(FallbackAlignmentShift)
    )
  );
}
pub type SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_IO_REQUEST {
  pub dwProtocol: DWORD,
  pub cbPciLength: DWORD,
}
#[test]
fn bindgen_test_layout__SCARD_IO_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_IO_REQUEST>(),
    8usize,
    concat!("Size of: ", stringify!(_SCARD_IO_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_IO_REQUEST>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCARD_IO_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_IO_REQUEST>())).dwProtocol as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_IO_REQUEST),
      "::",
      stringify!(dwProtocol)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_IO_REQUEST>())).cbPciLength as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_IO_REQUEST),
      "::",
      stringify!(cbPciLength)
    )
  );
}
pub type SCARD_IO_REQUEST = _SCARD_IO_REQUEST;
pub type LPSCARD_IO_REQUEST = *mut _SCARD_IO_REQUEST;
pub type LPCSCARD_IO_REQUEST = *const SCARD_IO_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_T0_COMMAND {
  pub bCla: BYTE,
  pub bIns: BYTE,
  pub bP1: BYTE,
  pub bP2: BYTE,
  pub bP3: BYTE,
}
#[test]
fn bindgen_test_layout__SCARD_T0_COMMAND() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_T0_COMMAND>(),
    5usize,
    concat!("Size of: ", stringify!(_SCARD_T0_COMMAND))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_T0_COMMAND>(),
    1usize,
    concat!("Alignment of ", stringify!(_SCARD_T0_COMMAND))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bCla as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bCla)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bIns as *const _ as usize },
    1usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bIns)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bP1 as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bP1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bP2 as *const _ as usize },
    3usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bP2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_COMMAND>())).bP3 as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_COMMAND),
      "::",
      stringify!(bP3)
    )
  );
}
pub type SCARD_T0_COMMAND = _SCARD_T0_COMMAND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCARD_T0_REQUEST {
  pub ioRequest: SCARD_IO_REQUEST,
  pub bSw1: BYTE,
  pub bSw2: BYTE,
  pub __bindgen_anon_1: _SCARD_T0_REQUEST__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SCARD_T0_REQUEST__bindgen_ty_1 {
  pub CmdBytes: SCARD_T0_COMMAND,
  pub rgbHeader: [BYTE; 5usize],
  _bindgen_union_align: [u8; 5usize],
}
#[test]
fn bindgen_test_layout__SCARD_T0_REQUEST__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_T0_REQUEST__bindgen_ty_1>(),
    5usize,
    concat!("Size of: ", stringify!(_SCARD_T0_REQUEST__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_T0_REQUEST__bindgen_ty_1>(),
    1usize,
    concat!("Alignment of ", stringify!(_SCARD_T0_REQUEST__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCARD_T0_REQUEST__bindgen_ty_1>())).CmdBytes as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST__bindgen_ty_1),
      "::",
      stringify!(CmdBytes)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SCARD_T0_REQUEST__bindgen_ty_1>())).rgbHeader as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST__bindgen_ty_1),
      "::",
      stringify!(rgbHeader)
    )
  );
}
#[test]
fn bindgen_test_layout__SCARD_T0_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_T0_REQUEST>(),
    16usize,
    concat!("Size of: ", stringify!(_SCARD_T0_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_T0_REQUEST>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCARD_T0_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_REQUEST>())).ioRequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST),
      "::",
      stringify!(ioRequest)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_REQUEST>())).bSw1 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST),
      "::",
      stringify!(bSw1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T0_REQUEST>())).bSw2 as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T0_REQUEST),
      "::",
      stringify!(bSw2)
    )
  );
}
pub type SCARD_T0_REQUEST = _SCARD_T0_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCARD_T1_REQUEST {
  pub ioRequest: SCARD_IO_REQUEST,
}
#[test]
fn bindgen_test_layout__SCARD_T1_REQUEST() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_T1_REQUEST>(),
    8usize,
    concat!("Size of: ", stringify!(_SCARD_T1_REQUEST))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_T1_REQUEST>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCARD_T1_REQUEST))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_T1_REQUEST>())).ioRequest as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_T1_REQUEST),
      "::",
      stringify!(ioRequest)
    )
  );
}
pub type SCARD_T1_REQUEST = _SCARD_T1_REQUEST;
pub type LPCBYTE = *const BYTE;
pub type SCARDCONTEXT = ULONG_PTR;
pub type LPSCARDCONTEXT = *mut SCARDCONTEXT;
pub type SCARDHANDLE = ULONG_PTR;
pub type LPSCARDHANDLE = *mut SCARDHANDLE;
extern "C" {
  pub fn SCardEstablishContext(
    dwScope: DWORD,
    pvReserved1: LPCVOID,
    pvReserved2: LPCVOID,
    phContext: LPSCARDCONTEXT,
  ) -> LONG;
}
extern "C" {
  pub fn SCardReleaseContext(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
  pub fn SCardIsValidContext(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
  pub fn SCardListReaderGroupsA(
    hContext: SCARDCONTEXT,
    mszGroups: LPSTR,
    pcchGroups: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReaderGroupsW(
    hContext: SCARDCONTEXT,
    mszGroups: LPWSTR,
    pcchGroups: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReadersA(
    hContext: SCARDCONTEXT,
    mszGroups: LPCSTR,
    mszReaders: LPSTR,
    pcchReaders: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReadersW(
    hContext: SCARDCONTEXT,
    mszGroups: LPCWSTR,
    mszReaders: LPWSTR,
    pcchReaders: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListCardsA(
    hContext: SCARDCONTEXT,
    pbAtr: LPCBYTE,
    rgquidInterfaces: LPCGUID,
    cguidInterfaceCount: DWORD,
    mszCards: *mut CHAR,
    pcchCards: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListCardsW(
    hContext: SCARDCONTEXT,
    pbAtr: LPCBYTE,
    rgquidInterfaces: LPCGUID,
    cguidInterfaceCount: DWORD,
    mszCards: *mut WCHAR,
    pcchCards: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListInterfacesA(
    hContext: SCARDCONTEXT,
    szCard: LPCSTR,
    pguidInterfaces: LPGUID,
    pcguidInterfaces: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListInterfacesW(
    hContext: SCARDCONTEXT,
    szCard: LPCWSTR,
    pguidInterfaces: LPGUID,
    pcguidInterfaces: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetProviderIdA(
    hContext: SCARDCONTEXT,
    szCard: LPCSTR,
    pguidProviderId: LPGUID,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetProviderIdW(
    hContext: SCARDCONTEXT,
    szCard: LPCWSTR,
    pguidProviderId: LPGUID,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetCardTypeProviderNameA(
    hContext: SCARDCONTEXT,
    szCardName: LPCSTR,
    dwProviderId: DWORD,
    szProvider: *mut CHAR,
    pcchProvider: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetCardTypeProviderNameW(
    hContext: SCARDCONTEXT,
    szCardName: LPCWSTR,
    dwProviderId: DWORD,
    szProvider: *mut WCHAR,
    pcchProvider: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceReaderGroupA(hContext: SCARDCONTEXT, szGroupName: LPCSTR) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceReaderGroupW(hContext: SCARDCONTEXT, szGroupName: LPCWSTR) -> LONG;
}
extern "C" {
  pub fn SCardForgetReaderGroupA(hContext: SCARDCONTEXT, szGroupName: LPCSTR) -> LONG;
}
extern "C" {
  pub fn SCardForgetReaderGroupW(hContext: SCARDCONTEXT, szGroupName: LPCWSTR) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceReaderA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    szDeviceName: LPCSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceReaderW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    szDeviceName: LPCWSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardForgetReaderA(hContext: SCARDCONTEXT, szReaderName: LPCSTR) -> LONG;
}
extern "C" {
  pub fn SCardForgetReaderW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR) -> LONG;
}
extern "C" {
  pub fn SCardAddReaderToGroupA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    szGroupName: LPCSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardAddReaderToGroupW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    szGroupName: LPCWSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardRemoveReaderFromGroupA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    szGroupName: LPCSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardRemoveReaderFromGroupW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    szGroupName: LPCWSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceCardTypeA(
    hContext: SCARDCONTEXT,
    szCardName: LPCSTR,
    pguidPrimaryProvider: LPCGUID,
    rgguidInterfaces: LPCGUID,
    dwInterfaceCount: DWORD,
    pbAtr: LPCBYTE,
    pbAtrMask: LPCBYTE,
    cbAtrLen: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardIntroduceCardTypeW(
    hContext: SCARDCONTEXT,
    szCardName: LPCWSTR,
    pguidPrimaryProvider: LPCGUID,
    rgguidInterfaces: LPCGUID,
    dwInterfaceCount: DWORD,
    pbAtr: LPCBYTE,
    pbAtrMask: LPCBYTE,
    cbAtrLen: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardSetCardTypeProviderNameA(
    hContext: SCARDCONTEXT,
    szCardName: LPCSTR,
    dwProviderId: DWORD,
    szProvider: LPCSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardSetCardTypeProviderNameW(
    hContext: SCARDCONTEXT,
    szCardName: LPCWSTR,
    dwProviderId: DWORD,
    szProvider: LPCWSTR,
  ) -> LONG;
}
extern "C" {
  pub fn SCardForgetCardTypeA(hContext: SCARDCONTEXT, szCardName: LPCSTR) -> LONG;
}
extern "C" {
  pub fn SCardForgetCardTypeW(hContext: SCARDCONTEXT, szCardName: LPCWSTR) -> LONG;
}
extern "C" {
  pub fn SCardFreeMemory(hContext: SCARDCONTEXT, pvMem: LPCVOID) -> LONG;
}
extern "C" {
  pub fn SCardAccessStartedEvent() -> HANDLE;
}
extern "C" {
  pub fn SCardReleaseStartedEvent();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCARD_READERSTATEA {
  pub szReader: LPCSTR,
  pub pvUserData: LPVOID,
  pub dwCurrentState: DWORD,
  pub dwEventState: DWORD,
  pub cbAtr: DWORD,
  pub rgbAtr: [BYTE; 36usize],
}
#[test]
fn bindgen_test_layout_SCARD_READERSTATEA() {
  assert_eq!(
    ::std::mem::size_of::<SCARD_READERSTATEA>(),
    64usize,
    concat!("Size of: ", stringify!(SCARD_READERSTATEA))
  );
  assert_eq!(
    ::std::mem::align_of::<SCARD_READERSTATEA>(),
    8usize,
    concat!("Alignment of ", stringify!(SCARD_READERSTATEA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).szReader as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(szReader)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).pvUserData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).dwCurrentState as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).dwEventState as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(dwEventState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).cbAtr as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(cbAtr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEA>())).rgbAtr as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEA),
      "::",
      stringify!(rgbAtr)
    )
  );
}
pub type LPSCARD_READERSTATEA = *mut SCARD_READERSTATEA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCARD_READERSTATEW {
  pub szReader: LPCWSTR,
  pub pvUserData: LPVOID,
  pub dwCurrentState: DWORD,
  pub dwEventState: DWORD,
  pub cbAtr: DWORD,
  pub rgbAtr: [BYTE; 36usize],
}
#[test]
fn bindgen_test_layout_SCARD_READERSTATEW() {
  assert_eq!(
    ::std::mem::size_of::<SCARD_READERSTATEW>(),
    64usize,
    concat!("Size of: ", stringify!(SCARD_READERSTATEW))
  );
  assert_eq!(
    ::std::mem::align_of::<SCARD_READERSTATEW>(),
    8usize,
    concat!("Alignment of ", stringify!(SCARD_READERSTATEW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).szReader as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(szReader)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).pvUserData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).dwCurrentState as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).dwEventState as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(dwEventState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).cbAtr as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(cbAtr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SCARD_READERSTATEW>())).rgbAtr as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(SCARD_READERSTATEW),
      "::",
      stringify!(rgbAtr)
    )
  );
}
pub type LPSCARD_READERSTATEW = *mut SCARD_READERSTATEW;
pub type SCARD_READERSTATE = SCARD_READERSTATEW;
extern "C" {
  pub fn SCardLocateCardsA(
    hContext: SCARDCONTEXT,
    mszCards: LPCSTR,
    rgReaderStates: LPSCARD_READERSTATEA,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardLocateCardsW(
    hContext: SCARDCONTEXT,
    mszCards: LPCWSTR,
    rgReaderStates: LPSCARD_READERSTATEW,
    cReaders: DWORD,
  ) -> LONG;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCARD_ATRMASK {
  pub cbAtr: DWORD,
  pub rgbAtr: [BYTE; 36usize],
  pub rgbMask: [BYTE; 36usize],
}
#[test]
fn bindgen_test_layout__SCARD_ATRMASK() {
  assert_eq!(
    ::std::mem::size_of::<_SCARD_ATRMASK>(),
    76usize,
    concat!("Size of: ", stringify!(_SCARD_ATRMASK))
  );
  assert_eq!(
    ::std::mem::align_of::<_SCARD_ATRMASK>(),
    4usize,
    concat!("Alignment of ", stringify!(_SCARD_ATRMASK))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_ATRMASK>())).cbAtr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_ATRMASK),
      "::",
      stringify!(cbAtr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_ATRMASK>())).rgbAtr as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_ATRMASK),
      "::",
      stringify!(rgbAtr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SCARD_ATRMASK>())).rgbMask as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SCARD_ATRMASK),
      "::",
      stringify!(rgbMask)
    )
  );
}
pub type SCARD_ATRMASK = _SCARD_ATRMASK;
pub type LPSCARD_ATRMASK = *mut _SCARD_ATRMASK;
extern "C" {
  pub fn SCardLocateCardsByATRA(
    hContext: SCARDCONTEXT,
    rgAtrMasks: LPSCARD_ATRMASK,
    cAtrs: DWORD,
    rgReaderStates: LPSCARD_READERSTATEA,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardLocateCardsByATRW(
    hContext: SCARDCONTEXT,
    rgAtrMasks: LPSCARD_ATRMASK,
    cAtrs: DWORD,
    rgReaderStates: LPSCARD_READERSTATEW,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetStatusChangeA(
    hContext: SCARDCONTEXT,
    dwTimeout: DWORD,
    rgReaderStates: LPSCARD_READERSTATEA,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetStatusChangeW(
    hContext: SCARDCONTEXT,
    dwTimeout: DWORD,
    rgReaderStates: LPSCARD_READERSTATEW,
    cReaders: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardCancel(hContext: SCARDCONTEXT) -> LONG;
}
extern "C" {
  pub fn SCardConnectA(
    hContext: SCARDCONTEXT,
    szReader: LPCSTR,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    phCard: LPSCARDHANDLE,
    pdwActiveProtocol: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardConnectW(
    hContext: SCARDCONTEXT,
    szReader: LPCWSTR,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    phCard: LPSCARDHANDLE,
    pdwActiveProtocol: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardReconnect(
    hCard: SCARDHANDLE,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    dwInitialization: DWORD,
    pdwActiveProtocol: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardDisconnect(hCard: SCARDHANDLE, dwDisposition: DWORD) -> LONG;
}
extern "C" {
  pub fn SCardBeginTransaction(hCard: SCARDHANDLE) -> LONG;
}
extern "C" {
  pub fn SCardEndTransaction(hCard: SCARDHANDLE, dwDisposition: DWORD) -> LONG;
}
extern "C" {
  pub fn SCardCancelTransaction(hCard: SCARDHANDLE) -> LONG;
}
extern "C" {
  pub fn SCardState(
    hCard: SCARDHANDLE,
    pdwState: LPDWORD,
    pdwProtocol: LPDWORD,
    pbAtr: LPBYTE,
    pcbAtrLen: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardStatusA(
    hCard: SCARDHANDLE,
    mszReaderNames: LPSTR,
    pcchReaderLen: LPDWORD,
    pdwState: LPDWORD,
    pdwProtocol: LPDWORD,
    pbAtr: LPBYTE,
    pcbAtrLen: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardStatusW(
    hCard: SCARDHANDLE,
    mszReaderNames: LPWSTR,
    pcchReaderLen: LPDWORD,
    pdwState: LPDWORD,
    pdwProtocol: LPDWORD,
    pbAtr: LPBYTE,
    pcbAtrLen: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardTransmit(
    hCard: SCARDHANDLE,
    pioSendPci: LPCSCARD_IO_REQUEST,
    pbSendBuffer: LPCBYTE,
    cbSendLength: DWORD,
    pioRecvPci: LPSCARD_IO_REQUEST,
    pbRecvBuffer: LPBYTE,
    pcbRecvLength: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetTransmitCount(hCard: SCARDHANDLE, pcTransmitCount: LPDWORD) -> LONG;
}
extern "C" {
  pub fn SCardControl(
    hCard: SCARDHANDLE,
    dwControlCode: DWORD,
    lpInBuffer: LPCVOID,
    cbInBufferSize: DWORD,
    lpOutBuffer: LPVOID,
    cbOutBufferSize: DWORD,
    lpBytesReturned: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetAttrib(
    hCard: SCARDHANDLE,
    dwAttrId: DWORD,
    pbAttr: LPBYTE,
    pcbAttrLen: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardSetAttrib(
    hCard: SCARDHANDLE,
    dwAttrId: DWORD,
    pbAttr: LPCBYTE,
    cbAttrLen: DWORD,
  ) -> LONG;
}
pub type LPOCNCONNPROCA = ::std::option::Option<
  unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: LPSTR, arg3: LPSTR, arg4: PVOID) -> SCARDHANDLE,
>;
pub type LPOCNCONNPROCW = ::std::option::Option<
  unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: LPWSTR, arg3: LPWSTR, arg4: PVOID) -> SCARDHANDLE,
>;
pub type LPOCNCHKPROC = ::std::option::Option<
  unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: SCARDHANDLE, arg3: PVOID) -> BOOL,
>;
pub type LPOCNDSCPROC =
  ::std::option::Option<unsafe extern "C" fn(arg1: SCARDCONTEXT, arg2: SCARDHANDLE, arg3: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARD_SEARCH_CRITERIAA {
  pub dwStructSize: DWORD,
  pub lpstrGroupNames: LPSTR,
  pub nMaxGroupNames: DWORD,
  pub rgguidInterfaces: LPCGUID,
  pub cguidInterfaces: DWORD,
  pub lpstrCardNames: LPSTR,
  pub nMaxCardNames: DWORD,
  pub lpfnCheck: LPOCNCHKPROC,
  pub lpfnConnect: LPOCNCONNPROCA,
  pub lpfnDisconnect: LPOCNDSCPROC,
  pub pvUserData: LPVOID,
  pub dwShareMode: DWORD,
  pub dwPreferredProtocols: DWORD,
}
#[test]
fn bindgen_test_layout_OPENCARD_SEARCH_CRITERIAA() {
  assert_eq!(
    ::std::mem::size_of::<OPENCARD_SEARCH_CRITERIAA>(),
    96usize,
    concat!("Size of: ", stringify!(OPENCARD_SEARCH_CRITERIAA))
  );
  assert_eq!(
    ::std::mem::align_of::<OPENCARD_SEARCH_CRITERIAA>(),
    8usize,
    concat!("Alignment of ", stringify!(OPENCARD_SEARCH_CRITERIAA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).dwStructSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(dwStructSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpstrGroupNames as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpstrGroupNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).nMaxGroupNames as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(nMaxGroupNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).rgguidInterfaces as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(rgguidInterfaces)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).cguidInterfaces as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(cguidInterfaces)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpstrCardNames as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpstrCardNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).nMaxCardNames as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(nMaxCardNames)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpfnCheck as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpfnCheck)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpfnConnect as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpfnConnect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).lpfnDisconnect as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(lpfnDisconnect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).pvUserData as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).dwShareMode as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(dwShareMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAA>())).dwPreferredProtocols as *const _
        as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAA),
      "::",
      stringify!(dwPreferredProtocols)
    )
  );
}
pub type POPENCARD_SEARCH_CRITERIAA = *mut OPENCARD_SEARCH_CRITERIAA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARD_SEARCH_CRITERIAW {
  pub dwStructSize: DWORD,
  pub lpstrGroupNames: LPWSTR,
  pub nMaxGroupNames: DWORD,
  pub rgguidInterfaces: LPCGUID,
  pub cguidInterfaces: DWORD,
  pub lpstrCardNames: LPWSTR,
  pub nMaxCardNames: DWORD,
  pub lpfnCheck: LPOCNCHKPROC,
  pub lpfnConnect: LPOCNCONNPROCW,
  pub lpfnDisconnect: LPOCNDSCPROC,
  pub pvUserData: LPVOID,
  pub dwShareMode: DWORD,
  pub dwPreferredProtocols: DWORD,
}
#[test]
fn bindgen_test_layout_OPENCARD_SEARCH_CRITERIAW() {
  assert_eq!(
    ::std::mem::size_of::<OPENCARD_SEARCH_CRITERIAW>(),
    96usize,
    concat!("Size of: ", stringify!(OPENCARD_SEARCH_CRITERIAW))
  );
  assert_eq!(
    ::std::mem::align_of::<OPENCARD_SEARCH_CRITERIAW>(),
    8usize,
    concat!("Alignment of ", stringify!(OPENCARD_SEARCH_CRITERIAW))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).dwStructSize as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(dwStructSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpstrGroupNames as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpstrGroupNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).nMaxGroupNames as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(nMaxGroupNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).rgguidInterfaces as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(rgguidInterfaces)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).cguidInterfaces as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(cguidInterfaces)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpstrCardNames as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpstrCardNames)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).nMaxCardNames as *const _ as usize
    },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(nMaxCardNames)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpfnCheck as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpfnCheck)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpfnConnect as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpfnConnect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).lpfnDisconnect as *const _ as usize
    },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(lpfnDisconnect)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).pvUserData as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).dwShareMode as *const _ as usize
    },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(dwShareMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARD_SEARCH_CRITERIAW>())).dwPreferredProtocols as *const _
        as usize
    },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARD_SEARCH_CRITERIAW),
      "::",
      stringify!(dwPreferredProtocols)
    )
  );
}
pub type POPENCARD_SEARCH_CRITERIAW = *mut OPENCARD_SEARCH_CRITERIAW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARDNAME_EXA {
  pub dwStructSize: DWORD,
  pub hSCardContext: SCARDCONTEXT,
  pub hwndOwner: HWND,
  pub dwFlags: DWORD,
  pub lpstrTitle: LPCSTR,
  pub lpstrSearchDesc: LPCSTR,
  pub hIcon: HICON,
  pub pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAA,
  pub lpfnConnect: LPOCNCONNPROCA,
  pub pvUserData: LPVOID,
  pub dwShareMode: DWORD,
  pub dwPreferredProtocols: DWORD,
  pub lpstrRdr: LPSTR,
  pub nMaxRdr: DWORD,
  pub lpstrCard: LPSTR,
  pub nMaxCard: DWORD,
  pub dwActiveProtocol: DWORD,
  pub hCardHandle: SCARDHANDLE,
}
#[test]
fn bindgen_test_layout_OPENCARDNAME_EXA() {
  assert_eq!(
    ::std::mem::size_of::<OPENCARDNAME_EXA>(),
    128usize,
    concat!("Size of: ", stringify!(OPENCARDNAME_EXA))
  );
  assert_eq!(
    ::std::mem::align_of::<OPENCARDNAME_EXA>(),
    8usize,
    concat!("Alignment of ", stringify!(OPENCARDNAME_EXA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwStructSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwStructSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).hSCardContext as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(hSCardContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).hwndOwner as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpstrTitle as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpstrTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpstrSearchDesc as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpstrSearchDesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).hIcon as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).pOpenCardSearchCriteria as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(pOpenCardSearchCriteria)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpfnConnect as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpfnConnect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).pvUserData as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwShareMode as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwShareMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwPreferredProtocols as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwPreferredProtocols)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpstrRdr as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpstrRdr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).nMaxRdr as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(nMaxRdr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).lpstrCard as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(lpstrCard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).nMaxCard as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(nMaxCard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).dwActiveProtocol as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(dwActiveProtocol)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXA>())).hCardHandle as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXA),
      "::",
      stringify!(hCardHandle)
    )
  );
}
pub type LPOPENCARDNAME_EXA = *mut OPENCARDNAME_EXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OPENCARDNAME_EXW {
  pub dwStructSize: DWORD,
  pub hSCardContext: SCARDCONTEXT,
  pub hwndOwner: HWND,
  pub dwFlags: DWORD,
  pub lpstrTitle: LPCWSTR,
  pub lpstrSearchDesc: LPCWSTR,
  pub hIcon: HICON,
  pub pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAW,
  pub lpfnConnect: LPOCNCONNPROCW,
  pub pvUserData: LPVOID,
  pub dwShareMode: DWORD,
  pub dwPreferredProtocols: DWORD,
  pub lpstrRdr: LPWSTR,
  pub nMaxRdr: DWORD,
  pub lpstrCard: LPWSTR,
  pub nMaxCard: DWORD,
  pub dwActiveProtocol: DWORD,
  pub hCardHandle: SCARDHANDLE,
}
#[test]
fn bindgen_test_layout_OPENCARDNAME_EXW() {
  assert_eq!(
    ::std::mem::size_of::<OPENCARDNAME_EXW>(),
    128usize,
    concat!("Size of: ", stringify!(OPENCARDNAME_EXW))
  );
  assert_eq!(
    ::std::mem::align_of::<OPENCARDNAME_EXW>(),
    8usize,
    concat!("Alignment of ", stringify!(OPENCARDNAME_EXW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwStructSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwStructSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).hSCardContext as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(hSCardContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).hwndOwner as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(hwndOwner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwFlags as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpstrTitle as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpstrTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpstrSearchDesc as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpstrSearchDesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).hIcon as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(hIcon)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).pOpenCardSearchCriteria as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(pOpenCardSearchCriteria)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpfnConnect as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpfnConnect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).pvUserData as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwShareMode as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwShareMode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwPreferredProtocols as *const _ as usize
    },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwPreferredProtocols)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpstrRdr as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpstrRdr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).nMaxRdr as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(nMaxRdr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).lpstrCard as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(lpstrCard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).nMaxCard as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(nMaxCard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).dwActiveProtocol as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(dwActiveProtocol)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<OPENCARDNAME_EXW>())).hCardHandle as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(OPENCARDNAME_EXW),
      "::",
      stringify!(hCardHandle)
    )
  );
}
pub type LPOPENCARDNAME_EXW = *mut OPENCARDNAME_EXW;
extern "C" {
  pub fn SCardUIDlgSelectCardA(arg1: LPOPENCARDNAME_EXA) -> LONG;
}
extern "C" {
  pub fn SCardUIDlgSelectCardW(arg1: LPOPENCARDNAME_EXW) -> LONG;
}
extern "C" {
  pub fn SCardDlgExtendedError() -> LONG;
}
extern "C" {
  pub fn SCardReadCacheA(
    hContext: SCARDCONTEXT,
    CardIdentifier: *mut UUID,
    FreshnessCounter: DWORD,
    LookupName: LPSTR,
    Data: PBYTE,
    DataLen: *mut DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardReadCacheW(
    hContext: SCARDCONTEXT,
    CardIdentifier: *mut UUID,
    FreshnessCounter: DWORD,
    LookupName: LPWSTR,
    Data: PBYTE,
    DataLen: *mut DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardWriteCacheA(
    hContext: SCARDCONTEXT,
    CardIdentifier: *mut UUID,
    FreshnessCounter: DWORD,
    LookupName: LPSTR,
    Data: PBYTE,
    DataLen: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardWriteCacheW(
    hContext: SCARDCONTEXT,
    CardIdentifier: *mut UUID,
    FreshnessCounter: DWORD,
    LookupName: LPWSTR,
    Data: PBYTE,
    DataLen: DWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetReaderIconA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    pbIcon: LPBYTE,
    pcbIcon: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetReaderIconW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    pbIcon: LPBYTE,
    pcbIcon: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetDeviceTypeIdA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    pdwDeviceTypeId: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetDeviceTypeIdW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    pdwDeviceTypeId: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetReaderDeviceInstanceIdA(
    hContext: SCARDCONTEXT,
    szReaderName: LPCSTR,
    szDeviceInstanceId: LPSTR,
    pcchDeviceInstanceId: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardGetReaderDeviceInstanceIdW(
    hContext: SCARDCONTEXT,
    szReaderName: LPCWSTR,
    szDeviceInstanceId: LPWSTR,
    pcchDeviceInstanceId: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReadersWithDeviceInstanceIdA(
    hContext: SCARDCONTEXT,
    szDeviceInstanceId: LPCSTR,
    mszReaders: LPSTR,
    pcchReaders: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardListReadersWithDeviceInstanceIdW(
    hContext: SCARDCONTEXT,
    szDeviceInstanceId: LPCWSTR,
    mszReaders: LPWSTR,
    pcchReaders: LPDWORD,
  ) -> LONG;
}
extern "C" {
  pub fn SCardAudit(hContext: SCARDCONTEXT, dwEvent: DWORD) -> LONG;
}
#[repr(C)]
pub struct IUnknown__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUnknown {
  pub vtable_: *const IUnknown__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_IUnknown() {
  assert_eq!(
    ::std::mem::size_of::<IUnknown>(),
    8usize,
    concat!("Size of: ", stringify!(IUnknown))
  );
  assert_eq!(
    ::std::mem::align_of::<IUnknown>(),
    8usize,
    concat!("Alignment of ", stringify!(IUnknown))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumString {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IEnumString() {
  assert_eq!(
    ::std::mem::size_of::<IEnumString>(),
    8usize,
    concat!("Size of: ", stringify!(IEnumString))
  );
  assert_eq!(
    ::std::mem::align_of::<IEnumString>(),
    8usize,
    concat!("Alignment of ", stringify!(IEnumString))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISequentialStream {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ISequentialStream() {
  assert_eq!(
    ::std::mem::size_of::<ISequentialStream>(),
    8usize,
    concat!("Size of: ", stringify!(ISequentialStream))
  );
  assert_eq!(
    ::std::mem::align_of::<ISequentialStream>(),
    8usize,
    concat!("Alignment of ", stringify!(ISequentialStream))
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagSTATSTG {
  pub pwcsName: LPOLESTR,
  pub type_: DWORD,
  pub cbSize: ULARGE_INTEGER,
  pub mtime: FILETIME,
  pub ctime: FILETIME,
  pub atime: FILETIME,
  pub grfMode: DWORD,
  pub grfLocksSupported: DWORD,
  pub clsid: CLSID,
  pub grfStateBits: DWORD,
  pub reserved: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTATSTG() {
  assert_eq!(
    ::std::mem::size_of::<tagSTATSTG>(),
    80usize,
    concat!("Size of: ", stringify!(tagSTATSTG))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTATSTG>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTATSTG))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).pwcsName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(pwcsName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).cbSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).mtime as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(mtime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).ctime as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(ctime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).atime as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(atime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).grfMode as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(grfMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).grfLocksSupported as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(grfLocksSupported)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).clsid as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(clsid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).grfStateBits as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(grfStateBits)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATSTG>())).reserved as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATSTG),
      "::",
      stringify!(reserved)
    )
  );
}
pub type STATSTG = tagSTATSTG;
pub const tagSTGTY_STGTY_STORAGE: tagSTGTY = 1;
pub const tagSTGTY_STGTY_STREAM: tagSTGTY = 2;
pub const tagSTGTY_STGTY_LOCKBYTES: tagSTGTY = 3;
pub const tagSTGTY_STGTY_PROPERTY: tagSTGTY = 4;
pub type tagSTGTY = ::std::os::raw::c_int;
pub use self::tagSTGTY as STGTY;
pub const tagSTREAM_SEEK_STREAM_SEEK_SET: tagSTREAM_SEEK = 0;
pub const tagSTREAM_SEEK_STREAM_SEEK_CUR: tagSTREAM_SEEK = 1;
pub const tagSTREAM_SEEK_STREAM_SEEK_END: tagSTREAM_SEEK = 2;
pub type tagSTREAM_SEEK = ::std::os::raw::c_int;
pub use self::tagSTREAM_SEEK as STREAM_SEEK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStream {
  pub _base: ISequentialStream,
}
#[test]
fn bindgen_test_layout_IStream() {
  assert_eq!(
    ::std::mem::size_of::<IStream>(),
    8usize,
    concat!("Size of: ", stringify!(IStream))
  );
  assert_eq!(
    ::std::mem::align_of::<IStream>(),
    8usize,
    concat!("Alignment of ", stringify!(IStream))
  );
}
pub type RPCOLEDATAREP = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRPCOLEMESSAGE {
  pub reserved1: *mut ::std::os::raw::c_void,
  pub dataRepresentation: RPCOLEDATAREP,
  pub Buffer: *mut ::std::os::raw::c_void,
  pub cbBuffer: ULONG,
  pub iMethod: ULONG,
  pub reserved2: [*mut ::std::os::raw::c_void; 5usize],
  pub rpcFlags: ULONG,
}
#[test]
fn bindgen_test_layout_tagRPCOLEMESSAGE() {
  assert_eq!(
    ::std::mem::size_of::<tagRPCOLEMESSAGE>(),
    80usize,
    concat!("Size of: ", stringify!(tagRPCOLEMESSAGE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagRPCOLEMESSAGE>(),
    8usize,
    concat!("Alignment of ", stringify!(tagRPCOLEMESSAGE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).reserved1 as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(reserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).dataRepresentation as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(dataRepresentation)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).Buffer as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(Buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).cbBuffer as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(cbBuffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).iMethod as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(iMethod)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).reserved2 as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(reserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagRPCOLEMESSAGE>())).rpcFlags as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(tagRPCOLEMESSAGE),
      "::",
      stringify!(rpcFlags)
    )
  );
}
pub type RPCOLEMESSAGE = tagRPCOLEMESSAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRpcChannelBuffer {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IRpcChannelBuffer() {
  assert_eq!(
    ::std::mem::size_of::<IRpcChannelBuffer>(),
    8usize,
    concat!("Size of: ", stringify!(IRpcChannelBuffer))
  );
  assert_eq!(
    ::std::mem::align_of::<IRpcChannelBuffer>(),
    8usize,
    concat!("Alignment of ", stringify!(IRpcChannelBuffer))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SChannelHookCallInfo {
  pub iid: IID,
  pub cbSize: DWORD,
  pub uCausality: GUID,
  pub dwServerPid: DWORD,
  pub iMethod: DWORD,
  pub pObject: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SChannelHookCallInfo() {
  assert_eq!(
    ::std::mem::size_of::<SChannelHookCallInfo>(),
    56usize,
    concat!("Size of: ", stringify!(SChannelHookCallInfo))
  );
  assert_eq!(
    ::std::mem::align_of::<SChannelHookCallInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(SChannelHookCallInfo))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).iid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(iid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).cbSize as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).uCausality as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(uCausality)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).dwServerPid as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(dwServerPid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).iMethod as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(iMethod)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SChannelHookCallInfo>())).pObject as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(SChannelHookCallInfo),
      "::",
      stringify!(pObject)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_SERVICE {
  pub dwAuthnSvc: DWORD,
  pub dwAuthzSvc: DWORD,
  pub pPrincipalName: *mut OLECHAR,
  pub hr: HRESULT,
}
#[test]
fn bindgen_test_layout_tagSOLE_AUTHENTICATION_SERVICE() {
  assert_eq!(
    ::std::mem::size_of::<tagSOLE_AUTHENTICATION_SERVICE>(),
    24usize,
    concat!("Size of: ", stringify!(tagSOLE_AUTHENTICATION_SERVICE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOLE_AUTHENTICATION_SERVICE>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOLE_AUTHENTICATION_SERVICE))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_SERVICE>())).dwAuthnSvc as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_SERVICE),
      "::",
      stringify!(dwAuthnSvc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_SERVICE>())).dwAuthzSvc as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_SERVICE),
      "::",
      stringify!(dwAuthzSvc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_SERVICE>())).pPrincipalName as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_SERVICE),
      "::",
      stringify!(pPrincipalName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_SERVICE>())).hr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_SERVICE),
      "::",
      stringify!(hr)
    )
  );
}
pub type SOLE_AUTHENTICATION_SERVICE = tagSOLE_AUTHENTICATION_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_INFO {
  pub dwAuthnSvc: DWORD,
  pub dwAuthzSvc: DWORD,
  pub pAuthInfo: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_tagSOLE_AUTHENTICATION_INFO() {
  assert_eq!(
    ::std::mem::size_of::<tagSOLE_AUTHENTICATION_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(tagSOLE_AUTHENTICATION_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOLE_AUTHENTICATION_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOLE_AUTHENTICATION_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_INFO>())).dwAuthnSvc as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_INFO),
      "::",
      stringify!(dwAuthnSvc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_INFO>())).dwAuthzSvc as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_INFO),
      "::",
      stringify!(dwAuthzSvc)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_INFO>())).pAuthInfo as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_INFO),
      "::",
      stringify!(pAuthInfo)
    )
  );
}
pub type SOLE_AUTHENTICATION_INFO = tagSOLE_AUTHENTICATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSOLE_AUTHENTICATION_LIST {
  pub cAuthInfo: DWORD,
  pub aAuthInfo: *mut SOLE_AUTHENTICATION_INFO,
}
#[test]
fn bindgen_test_layout_tagSOLE_AUTHENTICATION_LIST() {
  assert_eq!(
    ::std::mem::size_of::<tagSOLE_AUTHENTICATION_LIST>(),
    16usize,
    concat!("Size of: ", stringify!(tagSOLE_AUTHENTICATION_LIST))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSOLE_AUTHENTICATION_LIST>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSOLE_AUTHENTICATION_LIST))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_LIST>())).cAuthInfo as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_LIST),
      "::",
      stringify!(cAuthInfo)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSOLE_AUTHENTICATION_LIST>())).aAuthInfo as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSOLE_AUTHENTICATION_LIST),
      "::",
      stringify!(aAuthInfo)
    )
  );
}
pub type SOLE_AUTHENTICATION_LIST = tagSOLE_AUTHENTICATION_LIST;
pub const tagSTDMSHLFLAGS_SMEXF_SERVER: tagSTDMSHLFLAGS = 1;
pub const tagSTDMSHLFLAGS_SMEXF_HANDLER: tagSTDMSHLFLAGS = 2;
pub type tagSTDMSHLFLAGS = ::std::os::raw::c_int;
pub use self::tagSTDMSHLFLAGS as STDMSHLFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBIND_OPTS {
  pub cbStruct: DWORD,
  pub grfFlags: DWORD,
  pub grfMode: DWORD,
  pub dwTickCountDeadline: DWORD,
}
#[test]
fn bindgen_test_layout_tagBIND_OPTS() {
  assert_eq!(
    ::std::mem::size_of::<tagBIND_OPTS>(),
    16usize,
    concat!("Size of: ", stringify!(tagBIND_OPTS))
  );
  assert_eq!(
    ::std::mem::align_of::<tagBIND_OPTS>(),
    4usize,
    concat!("Alignment of ", stringify!(tagBIND_OPTS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBIND_OPTS>())).cbStruct as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBIND_OPTS),
      "::",
      stringify!(cbStruct)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBIND_OPTS>())).grfFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBIND_OPTS),
      "::",
      stringify!(grfFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBIND_OPTS>())).grfMode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBIND_OPTS),
      "::",
      stringify!(grfMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBIND_OPTS>())).dwTickCountDeadline as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBIND_OPTS),
      "::",
      stringify!(dwTickCountDeadline)
    )
  );
}
pub type BIND_OPTS = tagBIND_OPTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBindCtx {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IBindCtx() {
  assert_eq!(
    ::std::mem::size_of::<IBindCtx>(),
    8usize,
    concat!("Size of: ", stringify!(IBindCtx))
  );
  assert_eq!(
    ::std::mem::align_of::<IBindCtx>(),
    8usize,
    concat!("Alignment of ", stringify!(IBindCtx))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumMoniker {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IEnumMoniker() {
  assert_eq!(
    ::std::mem::size_of::<IEnumMoniker>(),
    8usize,
    concat!("Size of: ", stringify!(IEnumMoniker))
  );
  assert_eq!(
    ::std::mem::align_of::<IEnumMoniker>(),
    8usize,
    concat!("Alignment of ", stringify!(IEnumMoniker))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRunningObjectTable {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IRunningObjectTable() {
  assert_eq!(
    ::std::mem::size_of::<IRunningObjectTable>(),
    8usize,
    concat!("Size of: ", stringify!(IRunningObjectTable))
  );
  assert_eq!(
    ::std::mem::align_of::<IRunningObjectTable>(),
    8usize,
    concat!("Alignment of ", stringify!(IRunningObjectTable))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersist {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IPersist() {
  assert_eq!(
    ::std::mem::size_of::<IPersist>(),
    8usize,
    concat!("Size of: ", stringify!(IPersist))
  );
  assert_eq!(
    ::std::mem::align_of::<IPersist>(),
    8usize,
    concat!("Alignment of ", stringify!(IPersist))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPersistStream {
  pub _base: IPersist,
}
#[test]
fn bindgen_test_layout_IPersistStream() {
  assert_eq!(
    ::std::mem::size_of::<IPersistStream>(),
    8usize,
    concat!("Size of: ", stringify!(IPersistStream))
  );
  assert_eq!(
    ::std::mem::align_of::<IPersistStream>(),
    8usize,
    concat!("Alignment of ", stringify!(IPersistStream))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMoniker {
  pub _base: IPersistStream,
}
#[test]
fn bindgen_test_layout_IMoniker() {
  assert_eq!(
    ::std::mem::size_of::<IMoniker>(),
    8usize,
    concat!("Size of: ", stringify!(IMoniker))
  );
  assert_eq!(
    ::std::mem::align_of::<IMoniker>(),
    8usize,
    concat!("Alignment of ", stringify!(IMoniker))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumSTATSTG {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IEnumSTATSTG() {
  assert_eq!(
    ::std::mem::size_of::<IEnumSTATSTG>(),
    8usize,
    concat!("Size of: ", stringify!(IEnumSTATSTG))
  );
  assert_eq!(
    ::std::mem::align_of::<IEnumSTATSTG>(),
    8usize,
    concat!("Alignment of ", stringify!(IEnumSTATSTG))
  );
}
pub type SNB = *mut LPOLESTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStorage {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IStorage() {
  assert_eq!(
    ::std::mem::size_of::<IStorage>(),
    8usize,
    concat!("Size of: ", stringify!(IStorage))
  );
  assert_eq!(
    ::std::mem::align_of::<IStorage>(),
    8usize,
    concat!("Alignment of ", stringify!(IStorage))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDVTARGETDEVICE {
  pub tdSize: DWORD,
  pub tdDriverNameOffset: WORD,
  pub tdDeviceNameOffset: WORD,
  pub tdPortNameOffset: WORD,
  pub tdExtDevmodeOffset: WORD,
  pub tdData: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagDVTARGETDEVICE() {
  assert_eq!(
    ::std::mem::size_of::<tagDVTARGETDEVICE>(),
    16usize,
    concat!("Size of: ", stringify!(tagDVTARGETDEVICE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDVTARGETDEVICE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagDVTARGETDEVICE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdDriverNameOffset as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdDriverNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdDeviceNameOffset as *const _ as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdDeviceNameOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdPortNameOffset as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdPortNameOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdExtDevmodeOffset as *const _ as usize
    },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdExtDevmodeOffset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDVTARGETDEVICE>())).tdData as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDVTARGETDEVICE),
      "::",
      stringify!(tdData)
    )
  );
}
pub type DVTARGETDEVICE = tagDVTARGETDEVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagFORMATETC {
  pub cfFormat: CLIPFORMAT,
  pub ptd: *mut DVTARGETDEVICE,
  pub dwAspect: DWORD,
  pub lindex: LONG,
  pub tymed: DWORD,
}
#[test]
fn bindgen_test_layout_tagFORMATETC() {
  assert_eq!(
    ::std::mem::size_of::<tagFORMATETC>(),
    32usize,
    concat!("Size of: ", stringify!(tagFORMATETC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagFORMATETC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagFORMATETC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).cfFormat as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(cfFormat)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).ptd as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(ptd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).dwAspect as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(dwAspect)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).lindex as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(lindex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFORMATETC>())).tymed as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFORMATETC),
      "::",
      stringify!(tymed)
    )
  );
}
pub type FORMATETC = tagFORMATETC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATDATA {
  pub formatetc: FORMATETC,
  pub advf: DWORD,
  pub pAdvSink: *mut IAdviseSink,
  pub dwConnection: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTATDATA() {
  assert_eq!(
    ::std::mem::size_of::<tagSTATDATA>(),
    56usize,
    concat!("Size of: ", stringify!(tagSTATDATA))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTATDATA>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTATDATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATDATA>())).formatetc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATDATA),
      "::",
      stringify!(formatetc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATDATA>())).advf as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATDATA),
      "::",
      stringify!(advf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATDATA>())).pAdvSink as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATDATA),
      "::",
      stringify!(pAdvSink)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATDATA>())).dwConnection as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATDATA),
      "::",
      stringify!(dwConnection)
    )
  );
}
pub type STATDATA = tagSTATDATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagSTGMEDIUM {
  pub tymed: DWORD,
  pub __bindgen_anon_1: tagSTGMEDIUM__bindgen_ty_1,
  pub pUnkForRelease: *mut IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagSTGMEDIUM__bindgen_ty_1 {
  pub hBitmap: HBITMAP,
  pub hMetaFilePict: HMETAFILEPICT,
  pub hEnhMetaFile: HENHMETAFILE,
  pub hGlobal: HGLOBAL,
  pub lpszFileName: LPOLESTR,
  pub pstm: *mut IStream,
  pub pstg: *mut IStorage,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_tagSTGMEDIUM__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagSTGMEDIUM__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagSTGMEDIUM__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTGMEDIUM__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTGMEDIUM__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).hBitmap as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(hBitmap)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).hMetaFilePict as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(hMetaFilePict)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).hEnhMetaFile as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(hEnhMetaFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).hGlobal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(hGlobal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).lpszFileName as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(lpszFileName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).pstm as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(pstm)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM__bindgen_ty_1>())).pstg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM__bindgen_ty_1),
      "::",
      stringify!(pstg)
    )
  );
}
#[test]
fn bindgen_test_layout_tagSTGMEDIUM() {
  assert_eq!(
    ::std::mem::size_of::<tagSTGMEDIUM>(),
    24usize,
    concat!("Size of: ", stringify!(tagSTGMEDIUM))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTGMEDIUM>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTGMEDIUM))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM>())).tymed as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM),
      "::",
      stringify!(tymed)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGMEDIUM>())).pUnkForRelease as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGMEDIUM),
      "::",
      stringify!(pUnkForRelease)
    )
  );
}
pub type uSTGMEDIUM = tagSTGMEDIUM;
pub type STGMEDIUM = uSTGMEDIUM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IAdviseSink {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IAdviseSink() {
  assert_eq!(
    ::std::mem::size_of::<IAdviseSink>(),
    8usize,
    concat!("Size of: ", stringify!(IAdviseSink))
  );
  assert_eq!(
    ::std::mem::align_of::<IAdviseSink>(),
    8usize,
    concat!("Alignment of ", stringify!(IAdviseSink))
  );
}
pub const tagSERVERCALL_SERVERCALL_ISHANDLED: tagSERVERCALL = 0;
pub const tagSERVERCALL_SERVERCALL_REJECTED: tagSERVERCALL = 1;
pub const tagSERVERCALL_SERVERCALL_RETRYLATER: tagSERVERCALL = 2;
pub type tagSERVERCALL = ::std::os::raw::c_int;
pub use self::tagSERVERCALL as SERVERCALL;
extern "C" {
  pub fn SNB_UserSize(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut SNB,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn SNB_UserMarshal(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut SNB,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn SNB_UserUnmarshal(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut SNB,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn SNB_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut SNB);
}
extern "C" {
  pub fn STGMEDIUM_UserSize(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut STGMEDIUM,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn STGMEDIUM_UserMarshal(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut STGMEDIUM,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn STGMEDIUM_UserUnmarshal(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut STGMEDIUM,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn STGMEDIUM_UserFree(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut STGMEDIUM);
}
extern "C" {
  pub fn SNB_UserSize64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut SNB,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn SNB_UserMarshal64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut SNB,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn SNB_UserUnmarshal64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut SNB,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn SNB_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut SNB);
}
extern "C" {
  pub fn STGMEDIUM_UserSize64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
    arg3: *mut STGMEDIUM,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn STGMEDIUM_UserMarshal64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut STGMEDIUM,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn STGMEDIUM_UserUnmarshal64(
    arg1: *mut ::std::os::raw::c_ulong,
    arg2: *mut ::std::os::raw::c_uchar,
    arg3: *mut STGMEDIUM,
  ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
  pub fn STGMEDIUM_UserFree64(arg1: *mut ::std::os::raw::c_ulong, arg2: *mut STGMEDIUM);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAYBOUND {
  pub cElements: ULONG,
  pub lLbound: LONG,
}
#[test]
fn bindgen_test_layout_tagSAFEARRAYBOUND() {
  assert_eq!(
    ::std::mem::size_of::<tagSAFEARRAYBOUND>(),
    8usize,
    concat!("Size of: ", stringify!(tagSAFEARRAYBOUND))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSAFEARRAYBOUND>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSAFEARRAYBOUND))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAYBOUND>())).cElements as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAYBOUND),
      "::",
      stringify!(cElements)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAYBOUND>())).lLbound as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAYBOUND),
      "::",
      stringify!(lLbound)
    )
  );
}
pub type SAFEARRAYBOUND = tagSAFEARRAYBOUND;
pub type wireVARIANT = *mut _wireVARIANT;
pub type wireBRECORD = *mut _wireBRECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_BSTR {
  pub Size: ULONG,
  pub aBstr: *mut wireBSTR,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_BSTR() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_BSTR>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_BSTR))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_BSTR>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_BSTR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_BSTR>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_BSTR),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_BSTR>())).aBstr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_BSTR),
      "::",
      stringify!(aBstr)
    )
  );
}
pub type SAFEARR_BSTR = _wireSAFEARR_BSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_UNKNOWN {
  pub Size: ULONG,
  pub apUnknown: *mut *mut IUnknown,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_UNKNOWN() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_UNKNOWN>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_UNKNOWN))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_UNKNOWN>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_UNKNOWN))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_UNKNOWN>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_UNKNOWN),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_UNKNOWN>())).apUnknown as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_UNKNOWN),
      "::",
      stringify!(apUnknown)
    )
  );
}
pub type SAFEARR_UNKNOWN = _wireSAFEARR_UNKNOWN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_DISPATCH {
  pub Size: ULONG,
  pub apDispatch: *mut *mut IDispatch,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_DISPATCH() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_DISPATCH>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_DISPATCH))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_DISPATCH>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_DISPATCH))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_DISPATCH>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_DISPATCH),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_DISPATCH>())).apDispatch as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_DISPATCH),
      "::",
      stringify!(apDispatch)
    )
  );
}
pub type SAFEARR_DISPATCH = _wireSAFEARR_DISPATCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_VARIANT {
  pub Size: ULONG,
  pub aVariant: *mut wireVARIANT,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_VARIANT() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_VARIANT>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_VARIANT))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_VARIANT>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_VARIANT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_VARIANT>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_VARIANT),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_VARIANT>())).aVariant as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_VARIANT),
      "::",
      stringify!(aVariant)
    )
  );
}
pub type SAFEARR_VARIANT = _wireSAFEARR_VARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_BRECORD {
  pub Size: ULONG,
  pub aRecord: *mut wireBRECORD,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_BRECORD() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_BRECORD>(),
    16usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_BRECORD))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_BRECORD>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_BRECORD))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_BRECORD>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_BRECORD),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_BRECORD>())).aRecord as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_BRECORD),
      "::",
      stringify!(aRecord)
    )
  );
}
pub type SAFEARR_BRECORD = _wireSAFEARR_BRECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireSAFEARR_HAVEIID {
  pub Size: ULONG,
  pub apUnknown: *mut *mut IUnknown,
  pub iid: IID,
}
#[test]
fn bindgen_test_layout__wireSAFEARR_HAVEIID() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARR_HAVEIID>(),
    32usize,
    concat!("Size of: ", stringify!(_wireSAFEARR_HAVEIID))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARR_HAVEIID>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARR_HAVEIID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_HAVEIID>())).Size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_HAVEIID),
      "::",
      stringify!(Size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_HAVEIID>())).apUnknown as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_HAVEIID),
      "::",
      stringify!(apUnknown)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARR_HAVEIID>())).iid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARR_HAVEIID),
      "::",
      stringify!(iid)
    )
  );
}
pub type SAFEARR_HAVEIID = _wireSAFEARR_HAVEIID;
pub const tagSF_TYPE_SF_ERROR: tagSF_TYPE = 10;
pub const tagSF_TYPE_SF_I1: tagSF_TYPE = 16;
pub const tagSF_TYPE_SF_I2: tagSF_TYPE = 2;
pub const tagSF_TYPE_SF_I4: tagSF_TYPE = 3;
pub const tagSF_TYPE_SF_I8: tagSF_TYPE = 20;
pub const tagSF_TYPE_SF_BSTR: tagSF_TYPE = 8;
pub const tagSF_TYPE_SF_UNKNOWN: tagSF_TYPE = 13;
pub const tagSF_TYPE_SF_DISPATCH: tagSF_TYPE = 9;
pub const tagSF_TYPE_SF_VARIANT: tagSF_TYPE = 12;
pub const tagSF_TYPE_SF_RECORD: tagSF_TYPE = 36;
pub const tagSF_TYPE_SF_HAVEIID: tagSF_TYPE = 32781;
pub type tagSF_TYPE = ::std::os::raw::c_int;
pub use self::tagSF_TYPE as SF_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireSAFEARRAY_UNION {
  pub sfType: ULONG,
  pub u: _wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001 {
  pub BstrStr: SAFEARR_BSTR,
  pub UnknownStr: SAFEARR_UNKNOWN,
  pub DispatchStr: SAFEARR_DISPATCH,
  pub VariantStr: SAFEARR_VARIANT,
  pub RecordStr: SAFEARR_BRECORD,
  pub HaveIidStr: SAFEARR_HAVEIID,
  pub ByteStr: BYTE_SIZEDARR,
  pub WordStr: WORD_SIZEDARR,
  pub LongStr: DWORD_SIZEDARR,
  pub HyperStr: HYPER_SIZEDARR,
  _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>(),
    32usize,
    concat!(
      "Size of: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).BstrStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(BstrStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).UnknownStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(UnknownStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).DispatchStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(DispatchStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).VariantStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(VariantStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).RecordStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(RecordStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).HaveIidStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(HaveIidStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).ByteStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(ByteStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).WordStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(WordStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).LongStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(LongStr)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001>())).HyperStr
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION___MIDL_IOleAutomationTypes_0001),
      "::",
      stringify!(HyperStr)
    )
  );
}
#[test]
fn bindgen_test_layout__wireSAFEARRAY_UNION() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARRAY_UNION>(),
    40usize,
    concat!("Size of: ", stringify!(_wireSAFEARRAY_UNION))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARRAY_UNION>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARRAY_UNION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY_UNION>())).sfType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION),
      "::",
      stringify!(sfType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY_UNION>())).u as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY_UNION),
      "::",
      stringify!(u)
    )
  );
}
pub type SAFEARRAYUNION = _wireSAFEARRAY_UNION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireSAFEARRAY {
  pub cDims: USHORT,
  pub fFeatures: USHORT,
  pub cbElements: ULONG,
  pub cLocks: ULONG,
  pub uArrayStructs: SAFEARRAYUNION,
  pub rgsabound: [SAFEARRAYBOUND; 1usize],
}
#[test]
fn bindgen_test_layout__wireSAFEARRAY() {
  assert_eq!(
    ::std::mem::size_of::<_wireSAFEARRAY>(),
    64usize,
    concat!("Size of: ", stringify!(_wireSAFEARRAY))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireSAFEARRAY>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireSAFEARRAY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).cDims as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(cDims)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).fFeatures as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(fFeatures)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).cbElements as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(cbElements)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).cLocks as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(cLocks)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).uArrayStructs as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(uArrayStructs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireSAFEARRAY>())).rgsabound as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireSAFEARRAY),
      "::",
      stringify!(rgsabound)
    )
  );
}
pub type wireSAFEARRAY = *mut _wireSAFEARRAY;
pub type wirePSAFEARRAY = *mut wireSAFEARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAY {
  pub cDims: USHORT,
  pub fFeatures: USHORT,
  pub cbElements: ULONG,
  pub cLocks: ULONG,
  pub pvData: PVOID,
  pub rgsabound: [SAFEARRAYBOUND; 1usize],
}
#[test]
fn bindgen_test_layout_tagSAFEARRAY() {
  assert_eq!(
    ::std::mem::size_of::<tagSAFEARRAY>(),
    32usize,
    concat!("Size of: ", stringify!(tagSAFEARRAY))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSAFEARRAY>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSAFEARRAY))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).cDims as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(cDims)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).fFeatures as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(fFeatures)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).cbElements as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(cbElements)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).cLocks as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(cLocks)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).pvData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(pvData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSAFEARRAY>())).rgsabound as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSAFEARRAY),
      "::",
      stringify!(rgsabound)
    )
  );
}
pub type SAFEARRAY = tagSAFEARRAY;
pub type VARIANT = tagVARIANT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT {
  pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1 {
  pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1,
  pub decVal: DECIMAL,
  _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1 {
  pub vt: VARTYPE,
  pub wReserved1: WORD,
  pub wReserved2: WORD,
  pub wReserved3: WORD,
  pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub llVal: LONGLONG,
  pub lVal: LONG,
  pub bVal: BYTE,
  pub iVal: SHORT,
  pub fltVal: FLOAT,
  pub dblVal: DOUBLE,
  pub boolVal: VARIANT_BOOL,
  pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
  pub scode: SCODE,
  pub cyVal: CY,
  pub date: DATE,
  pub bstrVal: BSTR,
  pub punkVal: *mut IUnknown,
  pub pdispVal: *mut IDispatch,
  pub parray: *mut SAFEARRAY,
  pub pbVal: *mut BYTE,
  pub piVal: *mut SHORT,
  pub plVal: *mut LONG,
  pub pllVal: *mut LONGLONG,
  pub pfltVal: *mut FLOAT,
  pub pdblVal: *mut DOUBLE,
  pub pboolVal: *mut VARIANT_BOOL,
  pub __OBSOLETE__VARIANT_PBOOL: *mut VARIANT_BOOL,
  pub pscode: *mut SCODE,
  pub pcyVal: *mut CY,
  pub pdate: *mut DATE,
  pub pbstrVal: *mut BSTR,
  pub ppunkVal: *mut *mut IUnknown,
  pub ppdispVal: *mut *mut IDispatch,
  pub pparray: *mut *mut SAFEARRAY,
  pub pvarVal: *mut VARIANT,
  pub byref: PVOID,
  pub cVal: CHAR,
  pub uiVal: USHORT,
  pub ulVal: ULONG,
  pub ullVal: ULONGLONG,
  pub intVal: INT,
  pub uintVal: UINT,
  pub pdecVal: *mut DECIMAL,
  pub pcVal: *mut CHAR,
  pub puiVal: *mut USHORT,
  pub pulVal: *mut ULONG,
  pub pullVal: *mut ULONGLONG,
  pub pintVal: *mut INT,
  pub puintVal: *mut UINT,
  pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
  pub pvRecord: PVOID,
  pub pRecInfo: *mut IRecordInfo,
}
#[test]
fn bindgen_test_layout_tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .pvRecord as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pvRecord)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .pRecInfo as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pRecInfo)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).llVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(llVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).lVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(lVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).bVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(bVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).iVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(iVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).fltVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(fltVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).dblVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(dblVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).boolVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(boolVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .__OBSOLETE__VARIANT_BOOL as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(__OBSOLETE__VARIANT_BOOL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).scode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(scode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).cyVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(cyVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).date
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(date)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).bstrVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(bstrVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).punkVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(punkVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pdispVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pdispVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).parray
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(parray)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pbVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pbVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).piVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(piVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).plVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(plVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pllVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pllVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pfltVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pfltVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pdblVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pdblVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pboolVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pboolVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
        .__OBSOLETE__VARIANT_PBOOL as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(__OBSOLETE__VARIANT_PBOOL)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pscode
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pscode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pcyVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pcyVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pdate
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pdate)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pbstrVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pbstrVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).ppunkVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ppunkVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).ppdispVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ppdispVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pparray
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pparray)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pvarVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pvarVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).byref
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(byref)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).cVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(cVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).uiVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(uiVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).ulVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ulVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).ullVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(ullVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).intVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(intVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).uintVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(uintVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pdecVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pdecVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pcVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pcVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).puiVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(puiVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pulVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pulVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pullVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pullVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pintVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(pintVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).puintVal
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(puintVal)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARIANT__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>())).vt as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(vt)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>())).wReserved1 as *const _
        as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>())).wReserved2 as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved2)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1__bindgen_ty_1>())).wReserved3 as *const _
        as usize
    },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(wReserved3)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARIANT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT__bindgen_ty_1>(),
    24usize,
    concat!("Size of: ", stringify!(tagVARIANT__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagVARIANT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARIANT__bindgen_ty_1>())).decVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARIANT__bindgen_ty_1),
      "::",
      stringify!(decVal)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARIANT() {
  assert_eq!(
    ::std::mem::size_of::<tagVARIANT>(),
    24usize,
    concat!("Size of: ", stringify!(tagVARIANT))
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARIANT>(),
    8usize,
    concat!("Alignment of ", stringify!(tagVARIANT))
  );
}
pub type VARIANTARG = VARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _wireBRECORD {
  pub fFlags: ULONG,
  pub clSize: ULONG,
  pub pRecInfo: *mut IRecordInfo,
  pub pRecord: *mut byte,
}
#[test]
fn bindgen_test_layout__wireBRECORD() {
  assert_eq!(
    ::std::mem::size_of::<_wireBRECORD>(),
    24usize,
    concat!("Size of: ", stringify!(_wireBRECORD))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireBRECORD>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireBRECORD))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireBRECORD>())).fFlags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireBRECORD),
      "::",
      stringify!(fFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireBRECORD>())).clSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireBRECORD),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireBRECORD>())).pRecInfo as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireBRECORD),
      "::",
      stringify!(pRecInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireBRECORD>())).pRecord as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireBRECORD),
      "::",
      stringify!(pRecord)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wireVARIANT {
  pub clSize: DWORD,
  pub rpcReserved: DWORD,
  pub vt: USHORT,
  pub wReserved1: USHORT,
  pub wReserved2: USHORT,
  pub wReserved3: USHORT,
  pub __bindgen_anon_1: _wireVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _wireVARIANT__bindgen_ty_1 {
  pub llVal: LONGLONG,
  pub lVal: LONG,
  pub bVal: BYTE,
  pub iVal: SHORT,
  pub fltVal: FLOAT,
  pub dblVal: DOUBLE,
  pub boolVal: VARIANT_BOOL,
  pub scode: SCODE,
  pub cyVal: CY,
  pub date: DATE,
  pub bstrVal: wireBSTR,
  pub punkVal: *mut IUnknown,
  pub pdispVal: *mut IDispatch,
  pub parray: wirePSAFEARRAY,
  pub brecVal: wireBRECORD,
  pub pbVal: *mut BYTE,
  pub piVal: *mut SHORT,
  pub plVal: *mut LONG,
  pub pllVal: *mut LONGLONG,
  pub pfltVal: *mut FLOAT,
  pub pdblVal: *mut DOUBLE,
  pub pboolVal: *mut VARIANT_BOOL,
  pub pscode: *mut SCODE,
  pub pcyVal: *mut CY,
  pub pdate: *mut DATE,
  pub pbstrVal: *mut wireBSTR,
  pub ppunkVal: *mut *mut IUnknown,
  pub ppdispVal: *mut *mut IDispatch,
  pub pparray: *mut wirePSAFEARRAY,
  pub pvarVal: *mut wireVARIANT,
  pub cVal: CHAR,
  pub uiVal: USHORT,
  pub ulVal: ULONG,
  pub ullVal: ULONGLONG,
  pub intVal: INT,
  pub uintVal: UINT,
  pub decVal: DECIMAL,
  pub pdecVal: *mut DECIMAL,
  pub pcVal: *mut CHAR,
  pub puiVal: *mut USHORT,
  pub pulVal: *mut ULONG,
  pub pullVal: *mut ULONGLONG,
  pub pintVal: *mut INT,
  pub puintVal: *mut UINT,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__wireVARIANT__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_wireVARIANT__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(_wireVARIANT__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireVARIANT__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireVARIANT__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).llVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(llVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).lVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(lVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).bVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(bVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).iVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(iVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).fltVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(fltVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).dblVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(dblVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).boolVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(boolVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).scode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(scode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).cyVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(cyVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).date as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(date)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).bstrVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(bstrVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).punkVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(punkVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pdispVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pdispVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).parray as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(parray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).brecVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(brecVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pbVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pbVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).piVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(piVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).plVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(plVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pllVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pllVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pfltVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pfltVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pdblVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pdblVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pboolVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pboolVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pscode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pscode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pcyVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pcyVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pdate as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pdate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pbstrVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pbstrVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).ppunkVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(ppunkVal)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).ppdispVal as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(ppdispVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pparray as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pparray)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pvarVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pvarVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).cVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(cVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).uiVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(uiVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).ulVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(ulVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).ullVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(ullVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).intVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(intVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).uintVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(uintVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).decVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(decVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pdecVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pdecVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pcVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pcVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).puiVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(puiVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pulVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pulVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pullVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pullVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).pintVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(pintVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT__bindgen_ty_1>())).puintVal as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT__bindgen_ty_1),
      "::",
      stringify!(puintVal)
    )
  );
}
#[test]
fn bindgen_test_layout__wireVARIANT() {
  assert_eq!(
    ::std::mem::size_of::<_wireVARIANT>(),
    32usize,
    concat!("Size of: ", stringify!(_wireVARIANT))
  );
  assert_eq!(
    ::std::mem::align_of::<_wireVARIANT>(),
    8usize,
    concat!("Alignment of ", stringify!(_wireVARIANT))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).clSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(clSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).rpcReserved as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(rpcReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).vt as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(vt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).wReserved1 as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(wReserved1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).wReserved2 as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(wReserved2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_wireVARIANT>())).wReserved3 as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_wireVARIANT),
      "::",
      stringify!(wReserved3)
    )
  );
}
pub type DISPID = LONG;
pub type MEMBERID = DISPID;
pub type HREFTYPE = DWORD;
pub const tagTYPEKIND_TKIND_ENUM: tagTYPEKIND = 0;
pub const tagTYPEKIND_TKIND_RECORD: tagTYPEKIND = 1;
pub const tagTYPEKIND_TKIND_MODULE: tagTYPEKIND = 2;
pub const tagTYPEKIND_TKIND_INTERFACE: tagTYPEKIND = 3;
pub const tagTYPEKIND_TKIND_DISPATCH: tagTYPEKIND = 4;
pub const tagTYPEKIND_TKIND_COCLASS: tagTYPEKIND = 5;
pub const tagTYPEKIND_TKIND_ALIAS: tagTYPEKIND = 6;
pub const tagTYPEKIND_TKIND_UNION: tagTYPEKIND = 7;
pub const tagTYPEKIND_TKIND_MAX: tagTYPEKIND = 8;
pub type tagTYPEKIND = ::std::os::raw::c_int;
pub use self::tagTYPEKIND as TYPEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEDESC {
  pub __bindgen_anon_1: tagTYPEDESC__bindgen_ty_1,
  pub vt: VARTYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagTYPEDESC__bindgen_ty_1 {
  pub lptdesc: *mut tagTYPEDESC,
  pub lpadesc: *mut tagARRAYDESC,
  pub hreftype: HREFTYPE,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_tagTYPEDESC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagTYPEDESC__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagTYPEDESC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagTYPEDESC__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagTYPEDESC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEDESC__bindgen_ty_1>())).lptdesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEDESC__bindgen_ty_1),
      "::",
      stringify!(lptdesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEDESC__bindgen_ty_1>())).lpadesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEDESC__bindgen_ty_1),
      "::",
      stringify!(lpadesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEDESC__bindgen_ty_1>())).hreftype as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEDESC__bindgen_ty_1),
      "::",
      stringify!(hreftype)
    )
  );
}
#[test]
fn bindgen_test_layout_tagTYPEDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagTYPEDESC>(),
    16usize,
    concat!("Size of: ", stringify!(tagTYPEDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagTYPEDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagTYPEDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEDESC>())).vt as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEDESC),
      "::",
      stringify!(vt)
    )
  );
}
pub type TYPEDESC = tagTYPEDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagARRAYDESC {
  pub tdescElem: TYPEDESC,
  pub cDims: USHORT,
  pub rgbounds: [SAFEARRAYBOUND; 1usize],
}
#[test]
fn bindgen_test_layout_tagARRAYDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagARRAYDESC>(),
    32usize,
    concat!("Size of: ", stringify!(tagARRAYDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagARRAYDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagARRAYDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagARRAYDESC>())).tdescElem as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagARRAYDESC),
      "::",
      stringify!(tdescElem)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagARRAYDESC>())).cDims as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagARRAYDESC),
      "::",
      stringify!(cDims)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagARRAYDESC>())).rgbounds as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagARRAYDESC),
      "::",
      stringify!(rgbounds)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPARAMDESCEX {
  pub cBytes: ULONG,
  pub varDefaultValue: VARIANTARG,
}
#[test]
fn bindgen_test_layout_tagPARAMDESCEX() {
  assert_eq!(
    ::std::mem::size_of::<tagPARAMDESCEX>(),
    32usize,
    concat!("Size of: ", stringify!(tagPARAMDESCEX))
  );
  assert_eq!(
    ::std::mem::align_of::<tagPARAMDESCEX>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPARAMDESCEX))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagPARAMDESCEX>())).cBytes as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPARAMDESCEX),
      "::",
      stringify!(cBytes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagPARAMDESCEX>())).varDefaultValue as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPARAMDESCEX),
      "::",
      stringify!(varDefaultValue)
    )
  );
}
pub type LPPARAMDESCEX = *mut tagPARAMDESCEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPARAMDESC {
  pub pparamdescex: LPPARAMDESCEX,
  pub wParamFlags: USHORT,
}
#[test]
fn bindgen_test_layout_tagPARAMDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagPARAMDESC>(),
    16usize,
    concat!("Size of: ", stringify!(tagPARAMDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagPARAMDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagPARAMDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagPARAMDESC>())).pparamdescex as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPARAMDESC),
      "::",
      stringify!(pparamdescex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagPARAMDESC>())).wParamFlags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagPARAMDESC),
      "::",
      stringify!(wParamFlags)
    )
  );
}
pub type PARAMDESC = tagPARAMDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIDLDESC {
  pub dwReserved: ULONG_PTR,
  pub wIDLFlags: USHORT,
}
#[test]
fn bindgen_test_layout_tagIDLDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagIDLDESC>(),
    16usize,
    concat!("Size of: ", stringify!(tagIDLDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagIDLDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagIDLDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagIDLDESC>())).dwReserved as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIDLDESC),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagIDLDESC>())).wIDLFlags as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagIDLDESC),
      "::",
      stringify!(wIDLFlags)
    )
  );
}
pub type IDLDESC = tagIDLDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagELEMDESC {
  pub tdesc: TYPEDESC,
  pub __bindgen_anon_1: tagELEMDESC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagELEMDESC__bindgen_ty_1 {
  pub idldesc: IDLDESC,
  pub paramdesc: PARAMDESC,
  _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_tagELEMDESC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagELEMDESC__bindgen_ty_1>(),
    16usize,
    concat!("Size of: ", stringify!(tagELEMDESC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagELEMDESC__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagELEMDESC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagELEMDESC__bindgen_ty_1>())).idldesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagELEMDESC__bindgen_ty_1),
      "::",
      stringify!(idldesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagELEMDESC__bindgen_ty_1>())).paramdesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagELEMDESC__bindgen_ty_1),
      "::",
      stringify!(paramdesc)
    )
  );
}
#[test]
fn bindgen_test_layout_tagELEMDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagELEMDESC>(),
    32usize,
    concat!("Size of: ", stringify!(tagELEMDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagELEMDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagELEMDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagELEMDESC>())).tdesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagELEMDESC),
      "::",
      stringify!(tdesc)
    )
  );
}
pub type ELEMDESC = tagELEMDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEATTR {
  pub guid: GUID,
  pub lcid: LCID,
  pub dwReserved: DWORD,
  pub memidConstructor: MEMBERID,
  pub memidDestructor: MEMBERID,
  pub lpstrSchema: LPOLESTR,
  pub cbSizeInstance: ULONG,
  pub typekind: TYPEKIND,
  pub cFuncs: WORD,
  pub cVars: WORD,
  pub cImplTypes: WORD,
  pub cbSizeVft: WORD,
  pub cbAlignment: WORD,
  pub wTypeFlags: WORD,
  pub wMajorVerNum: WORD,
  pub wMinorVerNum: WORD,
  pub tdescAlias: TYPEDESC,
  pub idldescType: IDLDESC,
}
#[test]
fn bindgen_test_layout_tagTYPEATTR() {
  assert_eq!(
    ::std::mem::size_of::<tagTYPEATTR>(),
    96usize,
    concat!("Size of: ", stringify!(tagTYPEATTR))
  );
  assert_eq!(
    ::std::mem::align_of::<tagTYPEATTR>(),
    8usize,
    concat!("Alignment of ", stringify!(tagTYPEATTR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).guid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(guid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).lcid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(lcid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).dwReserved as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(dwReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).memidConstructor as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(memidConstructor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).memidDestructor as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(memidDestructor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).lpstrSchema as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(lpstrSchema)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cbSizeInstance as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cbSizeInstance)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).typekind as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(typekind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cFuncs as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cFuncs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cVars as *const _ as usize },
    50usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cVars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cImplTypes as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cImplTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cbSizeVft as *const _ as usize },
    54usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cbSizeVft)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).cbAlignment as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(cbAlignment)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).wTypeFlags as *const _ as usize },
    58usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(wTypeFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).wMajorVerNum as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(wMajorVerNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).wMinorVerNum as *const _ as usize },
    62usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(wMinorVerNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).tdescAlias as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(tdescAlias)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTYPEATTR>())).idldescType as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTYPEATTR),
      "::",
      stringify!(idldescType)
    )
  );
}
pub type TYPEATTR = tagTYPEATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDISPPARAMS {
  pub rgvarg: *mut VARIANTARG,
  pub rgdispidNamedArgs: *mut DISPID,
  pub cArgs: UINT,
  pub cNamedArgs: UINT,
}
#[test]
fn bindgen_test_layout_tagDISPPARAMS() {
  assert_eq!(
    ::std::mem::size_of::<tagDISPPARAMS>(),
    24usize,
    concat!("Size of: ", stringify!(tagDISPPARAMS))
  );
  assert_eq!(
    ::std::mem::align_of::<tagDISPPARAMS>(),
    8usize,
    concat!("Alignment of ", stringify!(tagDISPPARAMS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDISPPARAMS>())).rgvarg as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDISPPARAMS),
      "::",
      stringify!(rgvarg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDISPPARAMS>())).rgdispidNamedArgs as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDISPPARAMS),
      "::",
      stringify!(rgdispidNamedArgs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDISPPARAMS>())).cArgs as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDISPPARAMS),
      "::",
      stringify!(cArgs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagDISPPARAMS>())).cNamedArgs as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagDISPPARAMS),
      "::",
      stringify!(cNamedArgs)
    )
  );
}
pub type DISPPARAMS = tagDISPPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXCEPINFO {
  pub wCode: WORD,
  pub wReserved: WORD,
  pub bstrSource: BSTR,
  pub bstrDescription: BSTR,
  pub bstrHelpFile: BSTR,
  pub dwHelpContext: DWORD,
  pub pvReserved: PVOID,
  pub pfnDeferredFillIn:
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut tagEXCEPINFO) -> HRESULT>,
  pub scode: SCODE,
}
#[test]
fn bindgen_test_layout_tagEXCEPINFO() {
  assert_eq!(
    ::std::mem::size_of::<tagEXCEPINFO>(),
    64usize,
    concat!("Size of: ", stringify!(tagEXCEPINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<tagEXCEPINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(tagEXCEPINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).wCode as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(wCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).wReserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(wReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).bstrSource as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(bstrSource)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).bstrDescription as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(bstrDescription)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).bstrHelpFile as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(bstrHelpFile)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).dwHelpContext as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(dwHelpContext)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).pvReserved as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(pvReserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).pfnDeferredFillIn as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(pfnDeferredFillIn)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagEXCEPINFO>())).scode as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagEXCEPINFO),
      "::",
      stringify!(scode)
    )
  );
}
pub type EXCEPINFO = tagEXCEPINFO;
pub const tagCALLCONV_CC_FASTCALL: tagCALLCONV = 0;
pub const tagCALLCONV_CC_CDECL: tagCALLCONV = 1;
pub const tagCALLCONV_CC_MSCPASCAL: tagCALLCONV = 2;
pub const tagCALLCONV_CC_PASCAL: tagCALLCONV = 2;
pub const tagCALLCONV_CC_MACPASCAL: tagCALLCONV = 3;
pub const tagCALLCONV_CC_STDCALL: tagCALLCONV = 4;
pub const tagCALLCONV_CC_FPFASTCALL: tagCALLCONV = 5;
pub const tagCALLCONV_CC_SYSCALL: tagCALLCONV = 6;
pub const tagCALLCONV_CC_MPWCDECL: tagCALLCONV = 7;
pub const tagCALLCONV_CC_MPWPASCAL: tagCALLCONV = 8;
pub const tagCALLCONV_CC_MAX: tagCALLCONV = 9;
pub type tagCALLCONV = ::std::os::raw::c_int;
pub use self::tagCALLCONV as CALLCONV;
pub const tagFUNCKIND_FUNC_VIRTUAL: tagFUNCKIND = 0;
pub const tagFUNCKIND_FUNC_PUREVIRTUAL: tagFUNCKIND = 1;
pub const tagFUNCKIND_FUNC_NONVIRTUAL: tagFUNCKIND = 2;
pub const tagFUNCKIND_FUNC_STATIC: tagFUNCKIND = 3;
pub const tagFUNCKIND_FUNC_DISPATCH: tagFUNCKIND = 4;
pub type tagFUNCKIND = ::std::os::raw::c_int;
pub use self::tagFUNCKIND as FUNCKIND;
pub const tagINVOKEKIND_INVOKE_FUNC: tagINVOKEKIND = 1;
pub const tagINVOKEKIND_INVOKE_PROPERTYGET: tagINVOKEKIND = 2;
pub const tagINVOKEKIND_INVOKE_PROPERTYPUT: tagINVOKEKIND = 4;
pub const tagINVOKEKIND_INVOKE_PROPERTYPUTREF: tagINVOKEKIND = 8;
pub type tagINVOKEKIND = ::std::os::raw::c_int;
pub use self::tagINVOKEKIND as INVOKEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagFUNCDESC {
  pub memid: MEMBERID,
  pub lprgscode: *mut SCODE,
  pub lprgelemdescParam: *mut ELEMDESC,
  pub funckind: FUNCKIND,
  pub invkind: INVOKEKIND,
  pub callconv: CALLCONV,
  pub cParams: SHORT,
  pub cParamsOpt: SHORT,
  pub oVft: SHORT,
  pub cScodes: SHORT,
  pub elemdescFunc: ELEMDESC,
  pub wFuncFlags: WORD,
}
#[test]
fn bindgen_test_layout_tagFUNCDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagFUNCDESC>(),
    88usize,
    concat!("Size of: ", stringify!(tagFUNCDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagFUNCDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagFUNCDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).memid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(memid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).lprgscode as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(lprgscode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).lprgelemdescParam as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(lprgelemdescParam)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).funckind as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(funckind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).invkind as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(invkind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).callconv as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(callconv)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).cParams as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(cParams)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).cParamsOpt as *const _ as usize },
    38usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(cParamsOpt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).oVft as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(oVft)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).cScodes as *const _ as usize },
    42usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(cScodes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).elemdescFunc as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(elemdescFunc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagFUNCDESC>())).wFuncFlags as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(tagFUNCDESC),
      "::",
      stringify!(wFuncFlags)
    )
  );
}
pub type FUNCDESC = tagFUNCDESC;
pub const tagVARKIND_VAR_PERINSTANCE: tagVARKIND = 0;
pub const tagVARKIND_VAR_STATIC: tagVARKIND = 1;
pub const tagVARKIND_VAR_CONST: tagVARKIND = 2;
pub const tagVARKIND_VAR_DISPATCH: tagVARKIND = 3;
pub type tagVARKIND = ::std::os::raw::c_int;
pub use self::tagVARKIND as VARKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARDESC {
  pub memid: MEMBERID,
  pub lpstrSchema: LPOLESTR,
  pub __bindgen_anon_1: tagVARDESC__bindgen_ty_1,
  pub elemdescVar: ELEMDESC,
  pub wVarFlags: WORD,
  pub varkind: VARKIND,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARDESC__bindgen_ty_1 {
  pub oInst: ULONG,
  pub lpvarValue: *mut VARIANT,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_tagVARDESC__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<tagVARDESC__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(tagVARDESC__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARDESC__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(tagVARDESC__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC__bindgen_ty_1>())).oInst as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC__bindgen_ty_1),
      "::",
      stringify!(oInst)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC__bindgen_ty_1>())).lpvarValue as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC__bindgen_ty_1),
      "::",
      stringify!(lpvarValue)
    )
  );
}
#[test]
fn bindgen_test_layout_tagVARDESC() {
  assert_eq!(
    ::std::mem::size_of::<tagVARDESC>(),
    64usize,
    concat!("Size of: ", stringify!(tagVARDESC))
  );
  assert_eq!(
    ::std::mem::align_of::<tagVARDESC>(),
    8usize,
    concat!("Alignment of ", stringify!(tagVARDESC))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).memid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(memid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).lpstrSchema as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(lpstrSchema)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).elemdescVar as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(elemdescVar)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).wVarFlags as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(wVarFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagVARDESC>())).varkind as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagVARDESC),
      "::",
      stringify!(varkind)
    )
  );
}
pub type VARDESC = tagVARDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDispatch {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IDispatch() {
  assert_eq!(
    ::std::mem::size_of::<IDispatch>(),
    8usize,
    concat!("Size of: ", stringify!(IDispatch))
  );
  assert_eq!(
    ::std::mem::align_of::<IDispatch>(),
    8usize,
    concat!("Alignment of ", stringify!(IDispatch))
  );
}
pub const tagDESCKIND_DESCKIND_NONE: tagDESCKIND = 0;
pub const tagDESCKIND_DESCKIND_FUNCDESC: tagDESCKIND = 1;
pub const tagDESCKIND_DESCKIND_VARDESC: tagDESCKIND = 2;
pub const tagDESCKIND_DESCKIND_TYPECOMP: tagDESCKIND = 3;
pub const tagDESCKIND_DESCKIND_IMPLICITAPPOBJ: tagDESCKIND = 4;
pub const tagDESCKIND_DESCKIND_MAX: tagDESCKIND = 5;
pub type tagDESCKIND = ::std::os::raw::c_int;
pub use self::tagDESCKIND as DESCKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagBINDPTR {
  pub lpfuncdesc: *mut FUNCDESC,
  pub lpvardesc: *mut VARDESC,
  pub lptcomp: *mut ITypeComp,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_tagBINDPTR() {
  assert_eq!(
    ::std::mem::size_of::<tagBINDPTR>(),
    8usize,
    concat!("Size of: ", stringify!(tagBINDPTR))
  );
  assert_eq!(
    ::std::mem::align_of::<tagBINDPTR>(),
    8usize,
    concat!("Alignment of ", stringify!(tagBINDPTR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBINDPTR>())).lpfuncdesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBINDPTR),
      "::",
      stringify!(lpfuncdesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBINDPTR>())).lpvardesc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBINDPTR),
      "::",
      stringify!(lpvardesc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagBINDPTR>())).lptcomp as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagBINDPTR),
      "::",
      stringify!(lptcomp)
    )
  );
}
pub type BINDPTR = tagBINDPTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeComp {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ITypeComp() {
  assert_eq!(
    ::std::mem::size_of::<ITypeComp>(),
    8usize,
    concat!("Size of: ", stringify!(ITypeComp))
  );
  assert_eq!(
    ::std::mem::align_of::<ITypeComp>(),
    8usize,
    concat!("Alignment of ", stringify!(ITypeComp))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeInfo {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ITypeInfo() {
  assert_eq!(
    ::std::mem::size_of::<ITypeInfo>(),
    8usize,
    concat!("Size of: ", stringify!(ITypeInfo))
  );
  assert_eq!(
    ::std::mem::align_of::<ITypeInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(ITypeInfo))
  );
}
pub const tagSYSKIND_SYS_WIN16: tagSYSKIND = 0;
pub const tagSYSKIND_SYS_WIN32: tagSYSKIND = 1;
pub const tagSYSKIND_SYS_MAC: tagSYSKIND = 2;
pub const tagSYSKIND_SYS_WIN64: tagSYSKIND = 3;
pub type tagSYSKIND = ::std::os::raw::c_int;
pub use self::tagSYSKIND as SYSKIND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTLIBATTR {
  pub guid: GUID,
  pub lcid: LCID,
  pub syskind: SYSKIND,
  pub wMajorVerNum: WORD,
  pub wMinorVerNum: WORD,
  pub wLibFlags: WORD,
}
#[test]
fn bindgen_test_layout_tagTLIBATTR() {
  assert_eq!(
    ::std::mem::size_of::<tagTLIBATTR>(),
    32usize,
    concat!("Size of: ", stringify!(tagTLIBATTR))
  );
  assert_eq!(
    ::std::mem::align_of::<tagTLIBATTR>(),
    4usize,
    concat!("Alignment of ", stringify!(tagTLIBATTR))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).guid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(guid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).lcid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(lcid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).syskind as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(syskind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).wMajorVerNum as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(wMajorVerNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).wMinorVerNum as *const _ as usize },
    26usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(wMinorVerNum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagTLIBATTR>())).wLibFlags as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(tagTLIBATTR),
      "::",
      stringify!(wLibFlags)
    )
  );
}
pub type TLIBATTR = tagTLIBATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeLib {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ITypeLib() {
  assert_eq!(
    ::std::mem::size_of::<ITypeLib>(),
    8usize,
    concat!("Size of: ", stringify!(ITypeLib))
  );
  assert_eq!(
    ::std::mem::align_of::<ITypeLib>(),
    8usize,
    concat!("Alignment of ", stringify!(ITypeLib))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRecordInfo {
  pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_IRecordInfo() {
  assert_eq!(
    ::std::mem::size_of::<IRecordInfo>(),
    8usize,
    concat!("Size of: ", stringify!(IRecordInfo))
  );
  assert_eq!(
    ::std::mem::align_of::<IRecordInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(IRecordInfo))
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATPROPSTG {
  pub lpwstrName: LPOLESTR,
  pub propid: PROPID,
  pub vt: VARTYPE,
}
#[test]
fn bindgen_test_layout_tagSTATPROPSTG() {
  assert_eq!(
    ::std::mem::size_of::<tagSTATPROPSTG>(),
    16usize,
    concat!("Size of: ", stringify!(tagSTATPROPSTG))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTATPROPSTG>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTATPROPSTG))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSTG>())).lpwstrName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSTG),
      "::",
      stringify!(lpwstrName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSTG>())).propid as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSTG),
      "::",
      stringify!(propid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSTG>())).vt as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSTG),
      "::",
      stringify!(vt)
    )
  );
}
pub type STATPROPSTG = tagSTATPROPSTG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTATPROPSETSTG {
  pub fmtid: FMTID,
  pub clsid: CLSID,
  pub grfFlags: DWORD,
  pub mtime: FILETIME,
  pub ctime: FILETIME,
  pub atime: FILETIME,
  pub dwOSVersion: DWORD,
}
#[test]
fn bindgen_test_layout_tagSTATPROPSETSTG() {
  assert_eq!(
    ::std::mem::size_of::<tagSTATPROPSETSTG>(),
    64usize,
    concat!("Size of: ", stringify!(tagSTATPROPSETSTG))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTATPROPSETSTG>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTATPROPSETSTG))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).fmtid as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(fmtid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).clsid as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(clsid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).grfFlags as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(grfFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).mtime as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(mtime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).ctime as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(ctime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).atime as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(atime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTATPROPSETSTG>())).dwOSVersion as *const _ as usize },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTATPROPSETSTG),
      "::",
      stringify!(dwOSVersion)
    )
  );
}
pub type STATPROPSETSTG = tagSTATPROPSETSTG;
pub type STGFMT = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTGOPTIONS {
  pub usVersion: USHORT,
  pub reserved: USHORT,
  pub ulSectorSize: ULONG,
  pub pwcsTemplateFile: *const WCHAR,
}
#[test]
fn bindgen_test_layout_tagSTGOPTIONS() {
  assert_eq!(
    ::std::mem::size_of::<tagSTGOPTIONS>(),
    16usize,
    concat!("Size of: ", stringify!(tagSTGOPTIONS))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTGOPTIONS>(),
    8usize,
    concat!("Alignment of ", stringify!(tagSTGOPTIONS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGOPTIONS>())).usVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGOPTIONS),
      "::",
      stringify!(usVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGOPTIONS>())).reserved as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGOPTIONS),
      "::",
      stringify!(reserved)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGOPTIONS>())).ulSectorSize as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGOPTIONS),
      "::",
      stringify!(ulSectorSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTGOPTIONS>())).pwcsTemplateFile as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTGOPTIONS),
      "::",
      stringify!(pwcsTemplateFile)
    )
  );
}
pub type STGOPTIONS = tagSTGOPTIONS;
pub const __MIDL_IInternetSecurityManager_0003_SZM_CREATE: __MIDL_IInternetSecurityManager_0003 = 0;
pub const __MIDL_IInternetSecurityManager_0003_SZM_DELETE: __MIDL_IInternetSecurityManager_0003 = 1;
pub type __MIDL_IInternetSecurityManager_0003 = ::std::os::raw::c_int;
pub use self::__MIDL_IInternetSecurityManager_0003 as SZM_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _tagSOFTDISTINFO {
  pub cbSize: ULONG,
  pub dwFlags: DWORD,
  pub dwAdState: DWORD,
  pub szTitle: LPWSTR,
  pub szAbstract: LPWSTR,
  pub szHREF: LPWSTR,
  pub dwInstalledVersionMS: DWORD,
  pub dwInstalledVersionLS: DWORD,
  pub dwUpdateVersionMS: DWORD,
  pub dwUpdateVersionLS: DWORD,
  pub dwAdvertisedVersionMS: DWORD,
  pub dwAdvertisedVersionLS: DWORD,
  pub dwReserved: DWORD,
}
#[test]
fn bindgen_test_layout__tagSOFTDISTINFO() {
  assert_eq!(
    ::std::mem::size_of::<_tagSOFTDISTINFO>(),
    72usize,
    concat!("Size of: ", stringify!(_tagSOFTDISTINFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_tagSOFTDISTINFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_tagSOFTDISTINFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwFlags as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwAdState as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwAdState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).szTitle as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(szTitle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).szAbstract as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(szAbstract)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).szHREF as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(szHREF)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwInstalledVersionMS as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwInstalledVersionMS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwInstalledVersionLS as *const _ as usize
    },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwInstalledVersionLS)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwUpdateVersionMS as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwUpdateVersionMS)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwUpdateVersionLS as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwUpdateVersionLS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwAdvertisedVersionMS as *const _ as usize
    },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwAdvertisedVersionMS)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwAdvertisedVersionLS as *const _ as usize
    },
    60usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwAdvertisedVersionLS)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_tagSOFTDISTINFO>())).dwReserved as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_tagSOFTDISTINFO),
      "::",
      stringify!(dwReserved)
    )
  );
}
pub type SOFTDISTINFO = _tagSOFTDISTINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSERIALIZEDPROPERTYVALUE {
  pub dwType: DWORD,
  pub rgb: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_tagSERIALIZEDPROPERTYVALUE() {
  assert_eq!(
    ::std::mem::size_of::<tagSERIALIZEDPROPERTYVALUE>(),
    8usize,
    concat!("Size of: ", stringify!(tagSERIALIZEDPROPERTYVALUE))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSERIALIZEDPROPERTYVALUE>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSERIALIZEDPROPERTYVALUE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALIZEDPROPERTYVALUE>())).dwType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALIZEDPROPERTYVALUE),
      "::",
      stringify!(dwType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSERIALIZEDPROPERTYVALUE>())).rgb as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSERIALIZEDPROPERTYVALUE),
      "::",
      stringify!(rgb)
    )
  );
}
pub type SERIALIZEDPROPERTYVALUE = tagSERIALIZEDPROPERTYVALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SERVICE_TRIGGER_CUSTOM_STATE_ID {
  pub Data: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout_SERVICE_TRIGGER_CUSTOM_STATE_ID() {
  assert_eq!(
    ::std::mem::size_of::<SERVICE_TRIGGER_CUSTOM_STATE_ID>(),
    8usize,
    concat!("Size of: ", stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID))
  );
  assert_eq!(
    ::std::mem::align_of::<SERVICE_TRIGGER_CUSTOM_STATE_ID>(),
    4usize,
    concat!("Alignment of ", stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<SERVICE_TRIGGER_CUSTOM_STATE_ID>())).Data as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SERVICE_TRIGGER_CUSTOM_STATE_ID),
      "::",
      stringify!(Data)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
  pub u: _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1 {
  pub CustomStateId: SERVICE_TRIGGER_CUSTOM_STATE_ID,
  pub s: _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1 {
  pub DataOffset: DWORD,
  pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1>(
    ),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1>(
    ),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<
        _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
      >()))
      .DataOffset as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(DataOffset)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<
        _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1,
      >()))
      .Data as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(Data)
    )
  );
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>()))
        .CustomStateId as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1),
      "::",
      stringify!(CustomStateId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1>())).s
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM__bindgen_ty_1),
      "::",
      stringify!(s)
    )
  );
}
#[test]
fn bindgen_test_layout__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM>())).u as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM),
      "::",
      stringify!(u)
    )
  );
}
pub type SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM =
  _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DESCRIPTIONA {
  pub lpDescription: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_DESCRIPTIONA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_DESCRIPTIONA>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_DESCRIPTIONA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_DESCRIPTIONA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_DESCRIPTIONA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_DESCRIPTIONA>())).lpDescription as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DESCRIPTIONA),
      "::",
      stringify!(lpDescription)
    )
  );
}
pub type SERVICE_DESCRIPTIONA = _SERVICE_DESCRIPTIONA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DESCRIPTIONW {
  pub lpDescription: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_DESCRIPTIONW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_DESCRIPTIONW>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_DESCRIPTIONW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_DESCRIPTIONW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_DESCRIPTIONW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_DESCRIPTIONW>())).lpDescription as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DESCRIPTIONW),
      "::",
      stringify!(lpDescription)
    )
  );
}
pub type SERVICE_DESCRIPTIONW = _SERVICE_DESCRIPTIONW;
pub type SERVICE_DESCRIPTION = SERVICE_DESCRIPTIONW;
pub const _SC_ACTION_TYPE_SC_ACTION_NONE: _SC_ACTION_TYPE = 0;
pub const _SC_ACTION_TYPE_SC_ACTION_RESTART: _SC_ACTION_TYPE = 1;
pub const _SC_ACTION_TYPE_SC_ACTION_REBOOT: _SC_ACTION_TYPE = 2;
pub const _SC_ACTION_TYPE_SC_ACTION_RUN_COMMAND: _SC_ACTION_TYPE = 3;
pub const _SC_ACTION_TYPE_SC_ACTION_OWN_RESTART: _SC_ACTION_TYPE = 4;
pub type _SC_ACTION_TYPE = ::std::os::raw::c_int;
pub use self::_SC_ACTION_TYPE as SC_ACTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SC_ACTION {
  pub Type: SC_ACTION_TYPE,
  pub Delay: DWORD,
}
#[test]
fn bindgen_test_layout__SC_ACTION() {
  assert_eq!(
    ::std::mem::size_of::<_SC_ACTION>(),
    8usize,
    concat!("Size of: ", stringify!(_SC_ACTION))
  );
  assert_eq!(
    ::std::mem::align_of::<_SC_ACTION>(),
    4usize,
    concat!("Alignment of ", stringify!(_SC_ACTION))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SC_ACTION>())).Type as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SC_ACTION),
      "::",
      stringify!(Type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SC_ACTION>())).Delay as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SC_ACTION),
      "::",
      stringify!(Delay)
    )
  );
}
pub type SC_ACTION = _SC_ACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONSA {
  pub dwResetPeriod: DWORD,
  pub lpRebootMsg: LPSTR,
  pub lpCommand: LPSTR,
  pub cActions: DWORD,
  pub lpsaActions: *mut SC_ACTION,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONSA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_FAILURE_ACTIONSA>(),
    40usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONSA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_FAILURE_ACTIONSA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONSA))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).dwResetPeriod as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(dwResetPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpRebootMsg as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpRebootMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpCommand as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpCommand)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).cActions as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(cActions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSA>())).lpsaActions as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSA),
      "::",
      stringify!(lpsaActions)
    )
  );
}
pub type SERVICE_FAILURE_ACTIONSA = _SERVICE_FAILURE_ACTIONSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONSW {
  pub dwResetPeriod: DWORD,
  pub lpRebootMsg: LPWSTR,
  pub lpCommand: LPWSTR,
  pub cActions: DWORD,
  pub lpsaActions: *mut SC_ACTION,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONSW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_FAILURE_ACTIONSW>(),
    40usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONSW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_FAILURE_ACTIONSW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONSW))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).dwResetPeriod as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(dwResetPeriod)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpRebootMsg as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpRebootMsg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpCommand as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpCommand)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).cActions as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(cActions)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONSW>())).lpsaActions as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONSW),
      "::",
      stringify!(lpsaActions)
    )
  );
}
pub type SERVICE_FAILURE_ACTIONSW = _SERVICE_FAILURE_ACTIONSW;
pub type SERVICE_FAILURE_ACTIONS = SERVICE_FAILURE_ACTIONSW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_DELAYED_AUTO_START_INFO {
  pub fDelayedAutostart: BOOL,
}
#[test]
fn bindgen_test_layout__SERVICE_DELAYED_AUTO_START_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_DELAYED_AUTO_START_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_DELAYED_AUTO_START_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_DELAYED_AUTO_START_INFO>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_DELAYED_AUTO_START_INFO)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_DELAYED_AUTO_START_INFO>())).fDelayedAutostart as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_DELAYED_AUTO_START_INFO),
      "::",
      stringify!(fDelayedAutostart)
    )
  );
}
pub type SERVICE_DELAYED_AUTO_START_INFO = _SERVICE_DELAYED_AUTO_START_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_FAILURE_ACTIONS_FLAG {
  pub fFailureActionsOnNonCrashFailures: BOOL,
}
#[test]
fn bindgen_test_layout__SERVICE_FAILURE_ACTIONS_FLAG() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_FAILURE_ACTIONS_FLAG>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_FAILURE_ACTIONS_FLAG))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_FAILURE_ACTIONS_FLAG>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_FAILURE_ACTIONS_FLAG))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_FAILURE_ACTIONS_FLAG>())).fFailureActionsOnNonCrashFailures
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_FAILURE_ACTIONS_FLAG),
      "::",
      stringify!(fFailureActionsOnNonCrashFailures)
    )
  );
}
pub type SERVICE_FAILURE_ACTIONS_FLAG = _SERVICE_FAILURE_ACTIONS_FLAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_SID_INFO {
  pub dwServiceSidType: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_SID_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_SID_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_SID_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_SID_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_SID_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_SID_INFO>())).dwServiceSidType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_SID_INFO),
      "::",
      stringify!(dwServiceSidType)
    )
  );
}
pub type SERVICE_SID_INFO = _SERVICE_SID_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
  pub pmszRequiredPrivileges: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_REQUIRED_PRIVILEGES_INFOA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_REQUIRED_PRIVILEGES_INFOA>())).pmszRequiredPrivileges
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOA),
      "::",
      stringify!(pmszRequiredPrivileges)
    )
  );
}
pub type SERVICE_REQUIRED_PRIVILEGES_INFOA = _SERVICE_REQUIRED_PRIVILEGES_INFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
  pub pmszRequiredPrivileges: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_REQUIRED_PRIVILEGES_INFOW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>(),
    8usize,
    concat!("Size of: ", stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_REQUIRED_PRIVILEGES_INFOW>())).pmszRequiredPrivileges
        as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_REQUIRED_PRIVILEGES_INFOW),
      "::",
      stringify!(pmszRequiredPrivileges)
    )
  );
}
pub type SERVICE_REQUIRED_PRIVILEGES_INFOW = _SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub type SERVICE_REQUIRED_PRIVILEGES_INFO = SERVICE_REQUIRED_PRIVILEGES_INFOW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_PRESHUTDOWN_INFO {
  pub dwPreshutdownTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_PRESHUTDOWN_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_PRESHUTDOWN_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_PRESHUTDOWN_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_PRESHUTDOWN_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_PRESHUTDOWN_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_PRESHUTDOWN_INFO>())).dwPreshutdownTimeout as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PRESHUTDOWN_INFO),
      "::",
      stringify!(dwPreshutdownTimeout)
    )
  );
}
pub type SERVICE_PRESHUTDOWN_INFO = _SERVICE_PRESHUTDOWN_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM {
  pub dwDataType: DWORD,
  pub cbData: DWORD,
  pub pData: PBYTE,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER_SPECIFIC_DATA_ITEM() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).dwDataType as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(dwDataType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).cbData as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(cbData)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM>())).pData as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_SPECIFIC_DATA_ITEM),
      "::",
      stringify!(pData)
    )
  );
}
pub type SERVICE_TRIGGER_SPECIFIC_DATA_ITEM = _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
pub type PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM = *mut _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER {
  pub dwTriggerType: DWORD,
  pub dwAction: DWORD,
  pub pTriggerSubtype: *mut GUID,
  pub cDataItems: DWORD,
  pub pDataItems: PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TRIGGER>(),
    32usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TRIGGER>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TRIGGER))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).dwTriggerType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(dwTriggerType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).dwAction as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(dwAction)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).pTriggerSubtype as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(pTriggerSubtype)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).cDataItems as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(cDataItems)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER>())).pDataItems as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER),
      "::",
      stringify!(pDataItems)
    )
  );
}
pub type SERVICE_TRIGGER = _SERVICE_TRIGGER;
pub type PSERVICE_TRIGGER = *mut _SERVICE_TRIGGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TRIGGER_INFO {
  pub cTriggers: DWORD,
  pub pTriggers: PSERVICE_TRIGGER,
  pub pReserved: PBYTE,
}
#[test]
fn bindgen_test_layout__SERVICE_TRIGGER_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TRIGGER_INFO>(),
    24usize,
    concat!("Size of: ", stringify!(_SERVICE_TRIGGER_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TRIGGER_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TRIGGER_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER_INFO>())).cTriggers as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(cTriggers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER_INFO>())).pTriggers as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(pTriggers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TRIGGER_INFO>())).pReserved as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TRIGGER_INFO),
      "::",
      stringify!(pReserved)
    )
  );
}
pub type SERVICE_TRIGGER_INFO = _SERVICE_TRIGGER_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_PREFERRED_NODE_INFO {
  pub usPreferredNode: USHORT,
  pub fDelete: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SERVICE_PREFERRED_NODE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_PREFERRED_NODE_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_PREFERRED_NODE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_PREFERRED_NODE_INFO>(),
    2usize,
    concat!("Alignment of ", stringify!(_SERVICE_PREFERRED_NODE_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_PREFERRED_NODE_INFO>())).usPreferredNode as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PREFERRED_NODE_INFO),
      "::",
      stringify!(usPreferredNode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_PREFERRED_NODE_INFO>())).fDelete as *const _ as usize
    },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_PREFERRED_NODE_INFO),
      "::",
      stringify!(fDelete)
    )
  );
}
pub type SERVICE_PREFERRED_NODE_INFO = _SERVICE_PREFERRED_NODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SERVICE_TIMECHANGE_INFO {
  pub liNewTime: LARGE_INTEGER,
  pub liOldTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__SERVICE_TIMECHANGE_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TIMECHANGE_INFO>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TIMECHANGE_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TIMECHANGE_INFO>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TIMECHANGE_INFO))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TIMECHANGE_INFO>())).liNewTime as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TIMECHANGE_INFO),
      "::",
      stringify!(liNewTime)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TIMECHANGE_INFO>())).liOldTime as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TIMECHANGE_INFO),
      "::",
      stringify!(liOldTime)
    )
  );
}
pub type SERVICE_TIMECHANGE_INFO = _SERVICE_TIMECHANGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_LAUNCH_PROTECTED_INFO {
  pub dwLaunchProtected: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_LAUNCH_PROTECTED_INFO() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_LAUNCH_PROTECTED_INFO>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_LAUNCH_PROTECTED_INFO))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_LAUNCH_PROTECTED_INFO>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_LAUNCH_PROTECTED_INFO))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_LAUNCH_PROTECTED_INFO>())).dwLaunchProtected as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_LAUNCH_PROTECTED_INFO),
      "::",
      stringify!(dwLaunchProtected)
    )
  );
}
pub type SERVICE_LAUNCH_PROTECTED_INFO = _SERVICE_LAUNCH_PROTECTED_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SC_HANDLE__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SC_HANDLE__() {
  assert_eq!(
    ::std::mem::size_of::<SC_HANDLE__>(),
    4usize,
    concat!("Size of: ", stringify!(SC_HANDLE__))
  );
  assert_eq!(
    ::std::mem::align_of::<SC_HANDLE__>(),
    4usize,
    concat!("Alignment of ", stringify!(SC_HANDLE__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SC_HANDLE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SC_HANDLE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type SC_HANDLE = *mut SC_HANDLE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SERVICE_STATUS_HANDLE__ {
  pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SERVICE_STATUS_HANDLE__() {
  assert_eq!(
    ::std::mem::size_of::<SERVICE_STATUS_HANDLE__>(),
    4usize,
    concat!("Size of: ", stringify!(SERVICE_STATUS_HANDLE__))
  );
  assert_eq!(
    ::std::mem::align_of::<SERVICE_STATUS_HANDLE__>(),
    4usize,
    concat!("Alignment of ", stringify!(SERVICE_STATUS_HANDLE__))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<SERVICE_STATUS_HANDLE__>())).unused as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(SERVICE_STATUS_HANDLE__),
      "::",
      stringify!(unused)
    )
  );
}
pub type SERVICE_STATUS_HANDLE = *mut SERVICE_STATUS_HANDLE__;
pub const _SC_STATUS_TYPE_SC_STATUS_PROCESS_INFO: _SC_STATUS_TYPE = 0;
pub type _SC_STATUS_TYPE = ::std::os::raw::c_int;
pub use self::_SC_STATUS_TYPE as SC_STATUS_TYPE;
pub const _SC_ENUM_TYPE_SC_ENUM_PROCESS_INFO: _SC_ENUM_TYPE = 0;
pub type _SC_ENUM_TYPE = ::std::os::raw::c_int;
pub use self::_SC_ENUM_TYPE as SC_ENUM_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_STATUS {
  pub dwServiceType: DWORD,
  pub dwCurrentState: DWORD,
  pub dwControlsAccepted: DWORD,
  pub dwWin32ExitCode: DWORD,
  pub dwServiceSpecificExitCode: DWORD,
  pub dwCheckPoint: DWORD,
  pub dwWaitHint: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_STATUS() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_STATUS>(),
    28usize,
    concat!("Size of: ", stringify!(_SERVICE_STATUS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_STATUS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_STATUS))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwServiceType as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwServiceType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwCurrentState as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwControlsAccepted as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwControlsAccepted)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwWin32ExitCode as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwWin32ExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwServiceSpecificExitCode as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwServiceSpecificExitCode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwCheckPoint as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwCheckPoint)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS>())).dwWaitHint as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS),
      "::",
      stringify!(dwWaitHint)
    )
  );
}
pub type SERVICE_STATUS = _SERVICE_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_STATUS_PROCESS {
  pub dwServiceType: DWORD,
  pub dwCurrentState: DWORD,
  pub dwControlsAccepted: DWORD,
  pub dwWin32ExitCode: DWORD,
  pub dwServiceSpecificExitCode: DWORD,
  pub dwCheckPoint: DWORD,
  pub dwWaitHint: DWORD,
  pub dwProcessId: DWORD,
  pub dwServiceFlags: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_STATUS_PROCESS() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_STATUS_PROCESS>(),
    36usize,
    concat!("Size of: ", stringify!(_SERVICE_STATUS_PROCESS))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_STATUS_PROCESS>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_STATUS_PROCESS))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceType as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceType)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwCurrentState as *const _ as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwCurrentState)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwControlsAccepted as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwControlsAccepted)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwWin32ExitCode as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwWin32ExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceSpecificExitCode as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceSpecificExitCode)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwCheckPoint as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwCheckPoint)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwWaitHint as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwWaitHint)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwProcessId as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwProcessId)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_STATUS_PROCESS>())).dwServiceFlags as *const _ as usize
    },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_STATUS_PROCESS),
      "::",
      stringify!(dwServiceFlags)
    )
  );
}
pub type SERVICE_STATUS_PROCESS = _SERVICE_STATUS_PROCESS;
pub type SC_LOCK = LPVOID;
pub type LPSERVICE_MAIN_FUNCTIONW = ::std::option::Option<
  unsafe extern "C" fn(dwNumServicesArgs: DWORD, lpServiceArgVectors: *mut LPWSTR),
>;
pub type LPSERVICE_MAIN_FUNCTIONA = ::std::option::Option<
  unsafe extern "C" fn(dwNumServicesArgs: DWORD, lpServiceArgVectors: *mut LPSTR),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TABLE_ENTRYA {
  pub lpServiceName: LPSTR,
  pub lpServiceProc: LPSERVICE_MAIN_FUNCTIONA,
}
#[test]
fn bindgen_test_layout__SERVICE_TABLE_ENTRYA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TABLE_ENTRYA>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TABLE_ENTRYA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TABLE_ENTRYA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TABLE_ENTRYA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TABLE_ENTRYA>())).lpServiceName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYA),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TABLE_ENTRYA>())).lpServiceProc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYA),
      "::",
      stringify!(lpServiceProc)
    )
  );
}
pub type SERVICE_TABLE_ENTRYA = _SERVICE_TABLE_ENTRYA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_TABLE_ENTRYW {
  pub lpServiceName: LPWSTR,
  pub lpServiceProc: LPSERVICE_MAIN_FUNCTIONW,
}
#[test]
fn bindgen_test_layout__SERVICE_TABLE_ENTRYW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_TABLE_ENTRYW>(),
    16usize,
    concat!("Size of: ", stringify!(_SERVICE_TABLE_ENTRYW))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_TABLE_ENTRYW>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_TABLE_ENTRYW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TABLE_ENTRYW>())).lpServiceName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYW),
      "::",
      stringify!(lpServiceName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_TABLE_ENTRYW>())).lpServiceProc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_TABLE_ENTRYW),
      "::",
      stringify!(lpServiceProc)
    )
  );
}
pub type SERVICE_TABLE_ENTRYW = _SERVICE_TABLE_ENTRYW;
pub type SERVICE_TABLE_ENTRY = SERVICE_TABLE_ENTRYW;
pub type PFN_SC_NOTIFY_CALLBACK = ::std::option::Option<unsafe extern "C" fn(pParameter: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_1 {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_1() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_NOTIFY_1>(),
    64usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_1))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_NOTIFY_1>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).pfnNotifyCallback as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_1>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_1),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
pub type SERVICE_NOTIFY_1 = _SERVICE_NOTIFY_1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_2A {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
  pub dwNotificationTriggered: DWORD,
  pub pszServiceNames: LPSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_2A() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_NOTIFY_2A>(),
    80usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_2A))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_NOTIFY_2A>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_2A))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).pfnNotifyCallback as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(ServiceStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).dwNotificationTriggered as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(dwNotificationTriggered)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2A>())).pszServiceNames as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2A),
      "::",
      stringify!(pszServiceNames)
    )
  );
}
pub type SERVICE_NOTIFY_2A = _SERVICE_NOTIFY_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_NOTIFY_2W {
  pub dwVersion: DWORD,
  pub pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
  pub pContext: PVOID,
  pub dwNotificationStatus: DWORD,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
  pub dwNotificationTriggered: DWORD,
  pub pszServiceNames: LPWSTR,
}
#[test]
fn bindgen_test_layout__SERVICE_NOTIFY_2W() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_NOTIFY_2W>(),
    80usize,
    concat!("Size of: ", stringify!(_SERVICE_NOTIFY_2W))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_NOTIFY_2W>(),
    8usize,
    concat!("Alignment of ", stringify!(_SERVICE_NOTIFY_2W))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).dwVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).pfnNotifyCallback as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pfnNotifyCallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).pContext as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).dwNotificationStatus as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwNotificationStatus)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).ServiceStatus as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(ServiceStatus)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).dwNotificationTriggered as *const _ as usize
    },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(dwNotificationTriggered)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_NOTIFY_2W>())).pszServiceNames as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_NOTIFY_2W),
      "::",
      stringify!(pszServiceNames)
    )
  );
}
pub type SERVICE_NOTIFY_2W = _SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFY_2 = SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFYA = SERVICE_NOTIFY_2A;
pub type SERVICE_NOTIFYW = SERVICE_NOTIFY_2W;
pub type SERVICE_NOTIFY = SERVICE_NOTIFYW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
  pub dwReason: DWORD,
  pub pszComment: LPSTR,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_CONTROL_STATUS_REASON_PARAMSA() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).dwReason as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(dwReason)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).pszComment as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(pszComment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSA>())).ServiceStatus as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSA),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
pub type SERVICE_CONTROL_STATUS_REASON_PARAMSA = _SERVICE_CONTROL_STATUS_REASON_PARAMSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
  pub dwReason: DWORD,
  pub pszComment: LPWSTR,
  pub ServiceStatus: SERVICE_STATUS_PROCESS,
}
#[test]
fn bindgen_test_layout__SERVICE_CONTROL_STATUS_REASON_PARAMSW() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>(),
    56usize,
    concat!(
      "Size of: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).dwReason as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(dwReason)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).pszComment as *const _
        as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(pszComment)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_SERVICE_CONTROL_STATUS_REASON_PARAMSW>())).ServiceStatus as *const _
        as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_CONTROL_STATUS_REASON_PARAMSW),
      "::",
      stringify!(ServiceStatus)
    )
  );
}
pub type SERVICE_CONTROL_STATUS_REASON_PARAMSW = _SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub type SERVICE_CONTROL_STATUS_REASON_PARAMS = SERVICE_CONTROL_STATUS_REASON_PARAMSW;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVICE_START_REASON {
  pub dwReason: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_START_REASON() {
  assert_eq!(
    ::std::mem::size_of::<_SERVICE_START_REASON>(),
    4usize,
    concat!("Size of: ", stringify!(_SERVICE_START_REASON))
  );
  assert_eq!(
    ::std::mem::align_of::<_SERVICE_START_REASON>(),
    4usize,
    concat!("Alignment of ", stringify!(_SERVICE_START_REASON))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SERVICE_START_REASON>())).dwReason as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SERVICE_START_REASON),
      "::",
      stringify!(dwReason)
    )
  );
}
pub type SERVICE_START_REASON = _SERVICE_START_REASON;
pub const _SC_EVENT_TYPE_SC_EVENT_DATABASE_CHANGE: _SC_EVENT_TYPE = 0;
pub const _SC_EVENT_TYPE_SC_EVENT_PROPERTY_CHANGE: _SC_EVENT_TYPE = 1;
pub const _SC_EVENT_TYPE_SC_EVENT_STATUS_CHANGE: _SC_EVENT_TYPE = 2;
pub type _SC_EVENT_TYPE = ::std::os::raw::c_int;
pub use self::_SC_EVENT_TYPE as SC_EVENT_TYPE;
pub const SERVICE_REGISTRY_STATE_TYPE_ServiceRegistryStateParameters: SERVICE_REGISTRY_STATE_TYPE =
  0;
pub const SERVICE_REGISTRY_STATE_TYPE_ServiceRegistryStatePersistent: SERVICE_REGISTRY_STATE_TYPE =
  1;
pub const SERVICE_REGISTRY_STATE_TYPE_MaxServiceRegistryStateType: SERVICE_REGISTRY_STATE_TYPE = 2;
pub type SERVICE_REGISTRY_STATE_TYPE = ::std::os::raw::c_int;
pub const SERVICE_DIRECTORY_TYPE_ServiceDirectoryPersistentState: SERVICE_DIRECTORY_TYPE = 0;
pub const SERVICE_DIRECTORY_TYPE_ServiceDirectoryTypeMax: SERVICE_DIRECTORY_TYPE = 1;
pub type SERVICE_DIRECTORY_TYPE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLEBUFA {
  pub dwStyle: DWORD,
  pub szDescription: [CHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagSTYLEBUFA() {
  assert_eq!(
    ::std::mem::size_of::<tagSTYLEBUFA>(),
    36usize,
    concat!("Size of: ", stringify!(tagSTYLEBUFA))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTYLEBUFA>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLEBUFA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLEBUFA>())).dwStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFA),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLEBUFA>())).szDescription as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFA),
      "::",
      stringify!(szDescription)
    )
  );
}
pub type STYLEBUFA = tagSTYLEBUFA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSTYLEBUFW {
  pub dwStyle: DWORD,
  pub szDescription: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_tagSTYLEBUFW() {
  assert_eq!(
    ::std::mem::size_of::<tagSTYLEBUFW>(),
    68usize,
    concat!("Size of: ", stringify!(tagSTYLEBUFW))
  );
  assert_eq!(
    ::std::mem::align_of::<tagSTYLEBUFW>(),
    4usize,
    concat!("Alignment of ", stringify!(tagSTYLEBUFW))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLEBUFW>())).dwStyle as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFW),
      "::",
      stringify!(dwStyle)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<tagSTYLEBUFW>())).szDescription as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(tagSTYLEBUFW),
      "::",
      stringify!(szDescription)
    )
  );
}
pub type STYLEBUFW = tagSTYLEBUFW;
pub type STYLEBUF = STYLEBUFW;
pub const _SFileInfoClass_SFileMpqFileName: _SFileInfoClass = 0;
pub const _SFileInfoClass_SFileMpqStreamBitmap: _SFileInfoClass = 1;
pub const _SFileInfoClass_SFileMpqUserDataOffset: _SFileInfoClass = 2;
pub const _SFileInfoClass_SFileMpqUserDataHeader: _SFileInfoClass = 3;
pub const _SFileInfoClass_SFileMpqUserData: _SFileInfoClass = 4;
pub const _SFileInfoClass_SFileMpqHeaderOffset: _SFileInfoClass = 5;
pub const _SFileInfoClass_SFileMpqHeaderSize: _SFileInfoClass = 6;
pub const _SFileInfoClass_SFileMpqHeader: _SFileInfoClass = 7;
pub const _SFileInfoClass_SFileMpqHetTableOffset: _SFileInfoClass = 8;
pub const _SFileInfoClass_SFileMpqHetTableSize: _SFileInfoClass = 9;
pub const _SFileInfoClass_SFileMpqHetHeader: _SFileInfoClass = 10;
pub const _SFileInfoClass_SFileMpqHetTable: _SFileInfoClass = 11;
pub const _SFileInfoClass_SFileMpqBetTableOffset: _SFileInfoClass = 12;
pub const _SFileInfoClass_SFileMpqBetTableSize: _SFileInfoClass = 13;
pub const _SFileInfoClass_SFileMpqBetHeader: _SFileInfoClass = 14;
pub const _SFileInfoClass_SFileMpqBetTable: _SFileInfoClass = 15;
pub const _SFileInfoClass_SFileMpqHashTableOffset: _SFileInfoClass = 16;
pub const _SFileInfoClass_SFileMpqHashTableSize64: _SFileInfoClass = 17;
pub const _SFileInfoClass_SFileMpqHashTableSize: _SFileInfoClass = 18;
pub const _SFileInfoClass_SFileMpqHashTable: _SFileInfoClass = 19;
pub const _SFileInfoClass_SFileMpqBlockTableOffset: _SFileInfoClass = 20;
pub const _SFileInfoClass_SFileMpqBlockTableSize64: _SFileInfoClass = 21;
pub const _SFileInfoClass_SFileMpqBlockTableSize: _SFileInfoClass = 22;
pub const _SFileInfoClass_SFileMpqBlockTable: _SFileInfoClass = 23;
pub const _SFileInfoClass_SFileMpqHiBlockTableOffset: _SFileInfoClass = 24;
pub const _SFileInfoClass_SFileMpqHiBlockTableSize64: _SFileInfoClass = 25;
pub const _SFileInfoClass_SFileMpqHiBlockTable: _SFileInfoClass = 26;
pub const _SFileInfoClass_SFileMpqSignatures: _SFileInfoClass = 27;
pub const _SFileInfoClass_SFileMpqStrongSignatureOffset: _SFileInfoClass = 28;
pub const _SFileInfoClass_SFileMpqStrongSignatureSize: _SFileInfoClass = 29;
pub const _SFileInfoClass_SFileMpqStrongSignature: _SFileInfoClass = 30;
pub const _SFileInfoClass_SFileMpqArchiveSize64: _SFileInfoClass = 31;
pub const _SFileInfoClass_SFileMpqArchiveSize: _SFileInfoClass = 32;
pub const _SFileInfoClass_SFileMpqMaxFileCount: _SFileInfoClass = 33;
pub const _SFileInfoClass_SFileMpqFileTableSize: _SFileInfoClass = 34;
pub const _SFileInfoClass_SFileMpqSectorSize: _SFileInfoClass = 35;
pub const _SFileInfoClass_SFileMpqNumberOfFiles: _SFileInfoClass = 36;
pub const _SFileInfoClass_SFileMpqRawChunkSize: _SFileInfoClass = 37;
pub const _SFileInfoClass_SFileMpqStreamFlags: _SFileInfoClass = 38;
pub const _SFileInfoClass_SFileMpqFlags: _SFileInfoClass = 39;
pub const _SFileInfoClass_SFileInfoPatchChain: _SFileInfoClass = 40;
pub const _SFileInfoClass_SFileInfoFileEntry: _SFileInfoClass = 41;
pub const _SFileInfoClass_SFileInfoHashEntry: _SFileInfoClass = 42;
pub const _SFileInfoClass_SFileInfoHashIndex: _SFileInfoClass = 43;
pub const _SFileInfoClass_SFileInfoNameHash1: _SFileInfoClass = 44;
pub const _SFileInfoClass_SFileInfoNameHash2: _SFileInfoClass = 45;
pub const _SFileInfoClass_SFileInfoNameHash3: _SFileInfoClass = 46;
pub const _SFileInfoClass_SFileInfoLocale: _SFileInfoClass = 47;
pub const _SFileInfoClass_SFileInfoFileIndex: _SFileInfoClass = 48;
pub const _SFileInfoClass_SFileInfoByteOffset: _SFileInfoClass = 49;
pub const _SFileInfoClass_SFileInfoFileTime: _SFileInfoClass = 50;
pub const _SFileInfoClass_SFileInfoFileSize: _SFileInfoClass = 51;
pub const _SFileInfoClass_SFileInfoCompressedSize: _SFileInfoClass = 52;
pub const _SFileInfoClass_SFileInfoFlags: _SFileInfoClass = 53;
pub const _SFileInfoClass_SFileInfoEncryptionKey: _SFileInfoClass = 54;
pub const _SFileInfoClass_SFileInfoEncryptionKeyRaw: _SFileInfoClass = 55;
pub const _SFileInfoClass_SFileInfoCRC32: _SFileInfoClass = 56;
pub type _SFileInfoClass = ::std::os::raw::c_int;
pub use self::_SFileInfoClass as SFileInfoClass;
pub type SFILE_DOWNLOAD_CALLBACK = ::std::option::Option<
  unsafe extern "C" fn(
    pvUserData: *mut ::std::os::raw::c_void,
    ByteOffset: ULONGLONG,
    dwTotalBytes: DWORD,
  ),
>;
pub type SFILE_ADDFILE_CALLBACK = ::std::option::Option<
  unsafe extern "C" fn(
    pvUserData: *mut ::std::os::raw::c_void,
    dwBytesWritten: DWORD,
    dwTotalBytes: DWORD,
    bFinalCall: bool,
  ),
>;
pub type SFILE_COMPACT_CALLBACK = ::std::option::Option<
  unsafe extern "C" fn(
    pvUserData: *mut ::std::os::raw::c_void,
    dwWorkType: DWORD,
    BytesProcessed: ULONGLONG,
    TotalBytes: ULONGLONG,
  ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SFILE_FIND_DATA {
  pub cFileName: [::std::os::raw::c_char; 260usize],
  pub szPlainName: *mut ::std::os::raw::c_char,
  pub dwHashIndex: DWORD,
  pub dwBlockIndex: DWORD,
  pub dwFileSize: DWORD,
  pub dwFileFlags: DWORD,
  pub dwCompSize: DWORD,
  pub dwFileTimeLo: DWORD,
  pub dwFileTimeHi: DWORD,
  pub lcLocale: LCID,
}
#[test]
fn bindgen_test_layout__SFILE_FIND_DATA() {
  assert_eq!(
    ::std::mem::size_of::<_SFILE_FIND_DATA>(),
    304usize,
    concat!("Size of: ", stringify!(_SFILE_FIND_DATA))
  );
  assert_eq!(
    ::std::mem::align_of::<_SFILE_FIND_DATA>(),
    8usize,
    concat!("Alignment of ", stringify!(_SFILE_FIND_DATA))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).cFileName as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(cFileName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).szPlainName as *const _ as usize },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(szPlainName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwHashIndex as *const _ as usize },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwHashIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwBlockIndex as *const _ as usize },
    276usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwBlockIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwFileSize as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwFileSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwFileFlags as *const _ as usize },
    284usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwFileFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwCompSize as *const _ as usize },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwCompSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwFileTimeLo as *const _ as usize },
    292usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwFileTimeLo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).dwFileTimeHi as *const _ as usize },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(dwFileTimeHi)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_FIND_DATA>())).lcLocale as *const _ as usize },
    300usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_FIND_DATA),
      "::",
      stringify!(lcLocale)
    )
  );
}
pub type SFILE_FIND_DATA = _SFILE_FIND_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SFILE_CREATE_MPQ {
  pub cbSize: DWORD,
  pub dwMpqVersion: DWORD,
  pub pvUserData: *mut ::std::os::raw::c_void,
  pub cbUserData: DWORD,
  pub dwStreamFlags: DWORD,
  pub dwFileFlags1: DWORD,
  pub dwFileFlags2: DWORD,
  pub dwFileFlags3: DWORD,
  pub dwAttrFlags: DWORD,
  pub dwSectorSize: DWORD,
  pub dwRawChunkSize: DWORD,
  pub dwMaxFileCount: DWORD,
}
#[test]
fn bindgen_test_layout__SFILE_CREATE_MPQ() {
  assert_eq!(
    ::std::mem::size_of::<_SFILE_CREATE_MPQ>(),
    56usize,
    concat!("Size of: ", stringify!(_SFILE_CREATE_MPQ))
  );
  assert_eq!(
    ::std::mem::align_of::<_SFILE_CREATE_MPQ>(),
    8usize,
    concat!("Alignment of ", stringify!(_SFILE_CREATE_MPQ))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).cbSize as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(cbSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwMpqVersion as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwMpqVersion)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).pvUserData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(pvUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).cbUserData as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(cbUserData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwStreamFlags as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwStreamFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwFileFlags1 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwFileFlags1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwFileFlags2 as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwFileFlags2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwFileFlags3 as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwFileFlags3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwAttrFlags as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwAttrFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwSectorSize as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwSectorSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwRawChunkSize as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwRawChunkSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_SFILE_CREATE_MPQ>())).dwMaxFileCount as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_SFILE_CREATE_MPQ),
      "::",
      stringify!(dwMaxFileCount)
    )
  );
}
pub type SFILE_CREATE_MPQ = _SFILE_CREATE_MPQ;
pub type PSFILE_CREATE_MPQ = *mut _SFILE_CREATE_MPQ;
pub type SFILESETLOCALE = ::std::option::Option<unsafe extern "C" fn(arg1: LCID) -> LCID>;
pub type SFILEOPENARCHIVE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *const ::std::os::raw::c_char,
    arg2: DWORD,
    arg3: DWORD,
    arg4: *mut HANDLE,
  ) -> bool,
>;
pub type SFILECLOSEARCHIVE = ::std::option::Option<unsafe extern "C" fn(arg1: HANDLE) -> bool>;
pub type SFILEOPENFILEEX = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: HANDLE,
    arg2: *const ::std::os::raw::c_char,
    arg3: DWORD,
    arg4: *mut HANDLE,
  ) -> bool,
>;
pub type SFILECLOSEFILE = ::std::option::Option<unsafe extern "C" fn(arg1: HANDLE) -> bool>;
pub type SFILEGETFILESIZE =
  ::std::option::Option<unsafe extern "C" fn(arg1: HANDLE, arg2: LPDWORD) -> DWORD>;
pub type SFILESETFILEPOINTER = ::std::option::Option<
  unsafe extern "C" fn(arg1: HANDLE, arg2: LONG, arg3: *mut LONG, arg4: DWORD) -> DWORD,
>;
pub type SFILEREADFILE = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: HANDLE,
    arg2: *mut ::std::os::raw::c_void,
    arg3: DWORD,
    arg4: LPDWORD,
    arg5: LPOVERLAPPED,
  ) -> bool,
>;
extern "C" {
  pub fn SFileGetLocale() -> LCID;
}
extern "C" {
  pub fn SFileSetLocale(lcNewLocale: LCID) -> LCID;
}
extern "C" {
  pub fn SFileOpenArchive(
    szMpqName: *const TCHAR,
    dwPriority: DWORD,
    dwFlags: DWORD,
    phMpq: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileCreateArchive(
    szMpqName: *const TCHAR,
    dwCreateFlags: DWORD,
    dwMaxFileCount: DWORD,
    phMpq: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileCreateArchive2(
    szMpqName: *const TCHAR,
    pCreateInfo: PSFILE_CREATE_MPQ,
    phMpq: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileSetDownloadCallback(
    hMpq: HANDLE,
    DownloadCB: SFILE_DOWNLOAD_CALLBACK,
    pvUserData: *mut ::std::os::raw::c_void,
  ) -> bool;
}
extern "C" {
  pub fn SFileFlushArchive(hMpq: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileCloseArchive(hMpq: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileAddListFile(hMpq: HANDLE, szListFile: *const TCHAR) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SFileSetCompactCallback(
    hMpq: HANDLE,
    CompactCB: SFILE_COMPACT_CALLBACK,
    pvUserData: *mut ::std::os::raw::c_void,
  ) -> bool;
}
extern "C" {
  pub fn SFileCompactArchive(hMpq: HANDLE, szListFile: *const TCHAR, bReserved: bool) -> bool;
}
extern "C" {
  pub fn SFileGetMaxFileCount(hMpq: HANDLE) -> DWORD;
}
extern "C" {
  pub fn SFileSetMaxFileCount(hMpq: HANDLE, dwMaxFileCount: DWORD) -> bool;
}
extern "C" {
  pub fn SFileGetAttributes(hMpq: HANDLE) -> DWORD;
}
extern "C" {
  pub fn SFileSetAttributes(hMpq: HANDLE, dwFlags: DWORD) -> bool;
}
extern "C" {
  pub fn SFileUpdateFileAttributes(hMpq: HANDLE, szFileName: *const ::std::os::raw::c_char)
    -> bool;
}
extern "C" {
  pub fn SFileOpenPatchArchive(
    hMpq: HANDLE,
    szPatchMpqName: *const TCHAR,
    szPatchPathPrefix: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileIsPatchedArchive(hMpq: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileHasFile(hMpq: HANDLE, szFileName: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
  pub fn SFileOpenFileEx(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    dwSearchScope: DWORD,
    phFile: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileGetFileSize(hFile: HANDLE, pdwFileSizeHigh: LPDWORD) -> DWORD;
}
extern "C" {
  pub fn SFileSetFilePointer(
    hFile: HANDLE,
    lFilePos: LONG,
    plFilePosHigh: *mut LONG,
    dwMoveMethod: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn SFileReadFile(
    hFile: HANDLE,
    lpBuffer: *mut ::std::os::raw::c_void,
    dwToRead: DWORD,
    pdwRead: LPDWORD,
    lpOverlapped: LPOVERLAPPED,
  ) -> bool;
}
extern "C" {
  pub fn SFileCloseFile(hFile: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileGetFileInfo(
    hMpqOrFile: HANDLE,
    InfoClass: SFileInfoClass,
    pvFileInfo: *mut ::std::os::raw::c_void,
    cbFileInfo: DWORD,
    pcbLengthNeeded: LPDWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileGetFileName(hFile: HANDLE, szFileName: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
  pub fn SFileFreeFileInfo(
    pvFileInfo: *mut ::std::os::raw::c_void,
    InfoClass: SFileInfoClass,
  ) -> bool;
}
extern "C" {
  pub fn SFileExtractFile(
    hMpq: HANDLE,
    szToExtract: *const ::std::os::raw::c_char,
    szExtracted: *const TCHAR,
    dwSearchScope: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileGetFileChecksums(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    pdwCrc32: LPDWORD,
    pMD5: *mut ::std::os::raw::c_char,
  ) -> bool;
}
extern "C" {
  pub fn SFileVerifyFile(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
  ) -> DWORD;
}
extern "C" {
  pub fn SFileVerifyRawData(
    hMpq: HANDLE,
    dwWhatToVerify: DWORD,
    szFileName: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SFileSignArchive(hMpq: HANDLE, dwSignatureType: DWORD) -> bool;
}
extern "C" {
  pub fn SFileVerifyArchive(hMpq: HANDLE) -> DWORD;
}
extern "C" {
  pub fn SFileFindFirstFile(
    hMpq: HANDLE,
    szMask: *const ::std::os::raw::c_char,
    lpFindFileData: *mut SFILE_FIND_DATA,
    szListFile: *const TCHAR,
  ) -> HANDLE;
}
extern "C" {
  pub fn SFileFindNextFile(hFind: HANDLE, lpFindFileData: *mut SFILE_FIND_DATA) -> bool;
}
extern "C" {
  pub fn SFileFindClose(hFind: HANDLE) -> bool;
}
extern "C" {
  pub fn SListFileFindFirstFile(
    hMpq: HANDLE,
    szListFile: *const TCHAR,
    szMask: *const ::std::os::raw::c_char,
    lpFindFileData: *mut SFILE_FIND_DATA,
  ) -> HANDLE;
}
extern "C" {
  pub fn SListFileFindNextFile(hFind: HANDLE, lpFindFileData: *mut SFILE_FIND_DATA) -> bool;
}
extern "C" {
  pub fn SListFileFindClose(hFind: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileEnumLocales(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    plcLocales: *mut LCID,
    pdwMaxLocales: LPDWORD,
    dwSearchScope: DWORD,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SFileCreateFile(
    hMpq: HANDLE,
    szArchivedName: *const ::std::os::raw::c_char,
    FileTime: ULONGLONG,
    dwFileSize: DWORD,
    lcLocale: LCID,
    dwFlags: DWORD,
    phFile: *mut HANDLE,
  ) -> bool;
}
extern "C" {
  pub fn SFileWriteFile(
    hFile: HANDLE,
    pvData: *const ::std::os::raw::c_void,
    dwSize: DWORD,
    dwCompression: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileFinishFile(hFile: HANDLE) -> bool;
}
extern "C" {
  pub fn SFileAddFileEx(
    hMpq: HANDLE,
    szFileName: *const TCHAR,
    szArchivedName: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
    dwCompression: DWORD,
    dwCompressionNext: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileAddFile(
    hMpq: HANDLE,
    szFileName: *const TCHAR,
    szArchivedName: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileAddWave(
    hMpq: HANDLE,
    szFileName: *const TCHAR,
    szArchivedName: *const ::std::os::raw::c_char,
    dwFlags: DWORD,
    dwQuality: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileRemoveFile(
    hMpq: HANDLE,
    szFileName: *const ::std::os::raw::c_char,
    dwSearchScope: DWORD,
  ) -> bool;
}
extern "C" {
  pub fn SFileRenameFile(
    hMpq: HANDLE,
    szOldFileName: *const ::std::os::raw::c_char,
    szNewFileName: *const ::std::os::raw::c_char,
  ) -> bool;
}
extern "C" {
  pub fn SFileSetFileLocale(hFile: HANDLE, lcNewLocale: LCID) -> bool;
}
extern "C" {
  pub fn SFileSetDataCompression(DataCompression: DWORD) -> bool;
}
extern "C" {
  pub fn SFileSetAddFileCallback(
    hMpq: HANDLE,
    AddFileCB: SFILE_ADDFILE_CALLBACK,
    pvUserData: *mut ::std::os::raw::c_void,
  ) -> bool;
}
extern "C" {
  pub fn SCompImplode(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SCompExplode(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SCompCompress(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
    uCompressionMask: ::std::os::raw::c_uint,
    nCmpType: ::std::os::raw::c_int,
    nCmpLevel: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SCompDecompress(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn SCompDecompress2(
    pvOutBuffer: *mut ::std::os::raw::c_void,
    pcbOutBuffer: *mut ::std::os::raw::c_int,
    pvInBuffer: *mut ::std::os::raw::c_void,
    cbInBuffer: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
